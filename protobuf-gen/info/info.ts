/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "info/info.proto" (package "mavsdk.rpc.info", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.info.GetFlightInformationRequest
 */
export interface GetFlightInformationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetFlightInformationResponse
 */
export interface GetFlightInformationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult info_result = 1;
     */
    infoResult?: InfoResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.info.FlightInfo flight_info = 2;
     */
    flightInfo?: FlightInfo; // Flight information of the system
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetIdentificationRequest
 */
export interface GetIdentificationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetIdentificationResponse
 */
export interface GetIdentificationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult info_result = 1;
     */
    infoResult?: InfoResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.info.Identification identification = 2;
     */
    identification?: Identification; // Identification of the system
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetProductRequest
 */
export interface GetProductRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetProductResponse
 */
export interface GetProductResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult info_result = 1;
     */
    infoResult?: InfoResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.info.Product product = 2;
     */
    product?: Product; // Product information of the system
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetVersionRequest
 */
export interface GetVersionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetVersionResponse
 */
export interface GetVersionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult info_result = 1;
     */
    infoResult?: InfoResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.info.Version version = 2;
     */
    version?: Version; // Version information about the system
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetSpeedFactorRequest
 */
export interface GetSpeedFactorRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.GetSpeedFactorResponse
 */
export interface GetSpeedFactorResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult info_result = 1;
     */
    infoResult?: InfoResult;
    /**
     * @generated from protobuf field: double speed_factor = 2;
     */
    speedFactor: number; // Speed factor of simulation
}
/**
 * @generated from protobuf message mavsdk.rpc.info.SubscribeFlightInformationRequest
 */
export interface SubscribeFlightInformationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.info.FlightInformationResponse
 */
export interface FlightInformationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.FlightInfo flight_info = 1;
     */
    flightInfo?: FlightInfo; // The next flight information
}
/**
 * System flight information.
 *
 * @generated from protobuf message mavsdk.rpc.info.FlightInfo
 */
export interface FlightInfo {
    /**
     * @generated from protobuf field: uint32 time_boot_ms = 1;
     */
    timeBootMs: number; // Time since system boot
    /**
     * @generated from protobuf field: uint64 flight_uid = 2;
     */
    flightUid: bigint; // Flight counter. Starts from zero, is incremented at every disarm and is never reset (even after reboot)
    /**
     * @generated from protobuf field: uint32 duration_since_arming_ms = 3;
     */
    durationSinceArmingMs: number; // Duration since arming in milliseconds
    /**
     * @generated from protobuf field: uint32 duration_since_takeoff_ms = 4;
     */
    durationSinceTakeoffMs: number; // Duration since takeoff in milliseconds
}
/**
 * System identification.
 *
 * @generated from protobuf message mavsdk.rpc.info.Identification
 */
export interface Identification {
    /**
     * @generated from protobuf field: string hardware_uid = 1;
     */
    hardwareUid: string; // UID of the hardware. This refers to uid2 of MAVLink. If the system does not support uid2 yet, this is all zeros.
    /**
     * @generated from protobuf field: uint64 legacy_uid = 2;
     */
    legacyUid: bigint; // Legacy UID of the hardware, referred to as uid in MAVLink (formerly exposed during system discovery as UUID).
}
/**
 * System product information.
 *
 * @generated from protobuf message mavsdk.rpc.info.Product
 */
export interface Product {
    /**
     * @generated from protobuf field: int32 vendor_id = 1;
     */
    vendorId: number; // ID of the board vendor
    /**
     * @generated from protobuf field: string vendor_name = 2;
     */
    vendorName: string; // Name of the vendor
    /**
     * @generated from protobuf field: int32 product_id = 3;
     */
    productId: number; // ID of the product
    /**
     * @generated from protobuf field: string product_name = 4;
     */
    productName: string; // Name of the product
}
/**
 * System version information.
 *
 * @generated from protobuf message mavsdk.rpc.info.Version
 */
export interface Version {
    /**
     * @generated from protobuf field: int32 flight_sw_major = 1;
     */
    flightSwMajor: number; // Flight software major version
    /**
     * @generated from protobuf field: int32 flight_sw_minor = 2;
     */
    flightSwMinor: number; // Flight software minor version
    /**
     * @generated from protobuf field: int32 flight_sw_patch = 3;
     */
    flightSwPatch: number; // Flight software patch version
    /**
     * @generated from protobuf field: int32 flight_sw_vendor_major = 4;
     */
    flightSwVendorMajor: number; // Flight software vendor major version
    /**
     * @generated from protobuf field: int32 flight_sw_vendor_minor = 5;
     */
    flightSwVendorMinor: number; // Flight software vendor minor version
    /**
     * @generated from protobuf field: int32 flight_sw_vendor_patch = 6;
     */
    flightSwVendorPatch: number; // Flight software vendor patch version
    /**
     * @generated from protobuf field: int32 os_sw_major = 7;
     */
    osSwMajor: number; // Operating system software major version
    /**
     * @generated from protobuf field: int32 os_sw_minor = 8;
     */
    osSwMinor: number; // Operating system software minor version
    /**
     * @generated from protobuf field: int32 os_sw_patch = 9;
     */
    osSwPatch: number; // Operating system software patch version
    /**
     * @generated from protobuf field: string flight_sw_git_hash = 10;
     */
    flightSwGitHash: string; // Flight software git hash
    /**
     * @generated from protobuf field: string os_sw_git_hash = 11;
     */
    osSwGitHash: string; // Operating system software git hash
    /**
     * @generated from protobuf field: mavsdk.rpc.info.Version.FlightSoftwareVersionType flight_sw_version_type = 12;
     */
    flightSwVersionType: Version_FlightSoftwareVersionType; // Flight software version type
}
/**
 * These values define the type of firmware/flight software release
 *
 * @generated from protobuf enum mavsdk.rpc.info.Version.FlightSoftwareVersionType
 */
export enum Version_FlightSoftwareVersionType {
    /**
     * Unknown type
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Development release
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_DEV = 1;
     */
    DEV = 1,
    /**
     * Alpha release
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_ALPHA = 2;
     */
    ALPHA = 2,
    /**
     * Beta release
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_BETA = 3;
     */
    BETA = 3,
    /**
     * Release candidate
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_RC = 4;
     */
    RC = 4,
    /**
     * Official stable release
     *
     * @generated from protobuf enum value: FLIGHT_SOFTWARE_VERSION_TYPE_RELEASE = 5;
     */
    RELEASE = 5
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.info.InfoResult
 */
export interface InfoResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.info.InfoResult.Result result = 1;
     */
    result: InfoResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for info requests.
 *
 * @generated from protobuf enum mavsdk.rpc.info.InfoResult.Result
 */
export enum InfoResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request succeeded
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Information has not been received yet
     *
     * @generated from protobuf enum value: RESULT_INFORMATION_NOT_RECEIVED_YET = 2;
     */
    INFORMATION_NOT_RECEIVED_YET = 2,
    /**
     * No system is connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 3;
     */
    NO_SYSTEM = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class GetFlightInformationRequest$Type extends MessageType<GetFlightInformationRequest> {
    constructor() {
        super("mavsdk.rpc.info.GetFlightInformationRequest", []);
    }
    create(value?: PartialMessage<GetFlightInformationRequest>): GetFlightInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFlightInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFlightInformationRequest): GetFlightInformationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFlightInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetFlightInformationRequest
 */
export const GetFlightInformationRequest = new GetFlightInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFlightInformationResponse$Type extends MessageType<GetFlightInformationResponse> {
    constructor() {
        super("mavsdk.rpc.info.GetFlightInformationResponse", [
            { no: 1, name: "info_result", kind: "message", T: () => InfoResult },
            { no: 2, name: "flight_info", kind: "message", T: () => FlightInfo }
        ]);
    }
    create(value?: PartialMessage<GetFlightInformationResponse>): GetFlightInformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetFlightInformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFlightInformationResponse): GetFlightInformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult info_result */ 1:
                    message.infoResult = InfoResult.internalBinaryRead(reader, reader.uint32(), options, message.infoResult);
                    break;
                case /* mavsdk.rpc.info.FlightInfo flight_info */ 2:
                    message.flightInfo = FlightInfo.internalBinaryRead(reader, reader.uint32(), options, message.flightInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFlightInformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult info_result = 1; */
        if (message.infoResult)
            InfoResult.internalBinaryWrite(message.infoResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.info.FlightInfo flight_info = 2; */
        if (message.flightInfo)
            FlightInfo.internalBinaryWrite(message.flightInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetFlightInformationResponse
 */
export const GetFlightInformationResponse = new GetFlightInformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentificationRequest$Type extends MessageType<GetIdentificationRequest> {
    constructor() {
        super("mavsdk.rpc.info.GetIdentificationRequest", []);
    }
    create(value?: PartialMessage<GetIdentificationRequest>): GetIdentificationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetIdentificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentificationRequest): GetIdentificationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetIdentificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetIdentificationRequest
 */
export const GetIdentificationRequest = new GetIdentificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentificationResponse$Type extends MessageType<GetIdentificationResponse> {
    constructor() {
        super("mavsdk.rpc.info.GetIdentificationResponse", [
            { no: 1, name: "info_result", kind: "message", T: () => InfoResult },
            { no: 2, name: "identification", kind: "message", T: () => Identification }
        ]);
    }
    create(value?: PartialMessage<GetIdentificationResponse>): GetIdentificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetIdentificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentificationResponse): GetIdentificationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult info_result */ 1:
                    message.infoResult = InfoResult.internalBinaryRead(reader, reader.uint32(), options, message.infoResult);
                    break;
                case /* mavsdk.rpc.info.Identification identification */ 2:
                    message.identification = Identification.internalBinaryRead(reader, reader.uint32(), options, message.identification);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult info_result = 1; */
        if (message.infoResult)
            InfoResult.internalBinaryWrite(message.infoResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.info.Identification identification = 2; */
        if (message.identification)
            Identification.internalBinaryWrite(message.identification, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetIdentificationResponse
 */
export const GetIdentificationResponse = new GetIdentificationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductRequest$Type extends MessageType<GetProductRequest> {
    constructor() {
        super("mavsdk.rpc.info.GetProductRequest", []);
    }
    create(value?: PartialMessage<GetProductRequest>): GetProductRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductRequest): GetProductRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetProductRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetProductRequest
 */
export const GetProductRequest = new GetProductRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductResponse$Type extends MessageType<GetProductResponse> {
    constructor() {
        super("mavsdk.rpc.info.GetProductResponse", [
            { no: 1, name: "info_result", kind: "message", T: () => InfoResult },
            { no: 2, name: "product", kind: "message", T: () => Product }
        ]);
    }
    create(value?: PartialMessage<GetProductResponse>): GetProductResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductResponse): GetProductResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult info_result */ 1:
                    message.infoResult = InfoResult.internalBinaryRead(reader, reader.uint32(), options, message.infoResult);
                    break;
                case /* mavsdk.rpc.info.Product product */ 2:
                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult info_result = 1; */
        if (message.infoResult)
            InfoResult.internalBinaryWrite(message.infoResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.info.Product product = 2; */
        if (message.product)
            Product.internalBinaryWrite(message.product, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetProductResponse
 */
export const GetProductResponse = new GetProductResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVersionRequest$Type extends MessageType<GetVersionRequest> {
    constructor() {
        super("mavsdk.rpc.info.GetVersionRequest", []);
    }
    create(value?: PartialMessage<GetVersionRequest>): GetVersionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVersionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVersionRequest): GetVersionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetVersionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetVersionRequest
 */
export const GetVersionRequest = new GetVersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetVersionResponse$Type extends MessageType<GetVersionResponse> {
    constructor() {
        super("mavsdk.rpc.info.GetVersionResponse", [
            { no: 1, name: "info_result", kind: "message", T: () => InfoResult },
            { no: 2, name: "version", kind: "message", T: () => Version }
        ]);
    }
    create(value?: PartialMessage<GetVersionResponse>): GetVersionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetVersionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetVersionResponse): GetVersionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult info_result */ 1:
                    message.infoResult = InfoResult.internalBinaryRead(reader, reader.uint32(), options, message.infoResult);
                    break;
                case /* mavsdk.rpc.info.Version version */ 2:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetVersionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult info_result = 1; */
        if (message.infoResult)
            InfoResult.internalBinaryWrite(message.infoResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.info.Version version = 2; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetVersionResponse
 */
export const GetVersionResponse = new GetVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSpeedFactorRequest$Type extends MessageType<GetSpeedFactorRequest> {
    constructor() {
        super("mavsdk.rpc.info.GetSpeedFactorRequest", []);
    }
    create(value?: PartialMessage<GetSpeedFactorRequest>): GetSpeedFactorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSpeedFactorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSpeedFactorRequest): GetSpeedFactorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetSpeedFactorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetSpeedFactorRequest
 */
export const GetSpeedFactorRequest = new GetSpeedFactorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSpeedFactorResponse$Type extends MessageType<GetSpeedFactorResponse> {
    constructor() {
        super("mavsdk.rpc.info.GetSpeedFactorResponse", [
            { no: 1, name: "info_result", kind: "message", T: () => InfoResult },
            { no: 2, name: "speed_factor", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<GetSpeedFactorResponse>): GetSpeedFactorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.speedFactor = 0;
        if (value !== undefined)
            reflectionMergePartial<GetSpeedFactorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSpeedFactorResponse): GetSpeedFactorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult info_result */ 1:
                    message.infoResult = InfoResult.internalBinaryRead(reader, reader.uint32(), options, message.infoResult);
                    break;
                case /* double speed_factor */ 2:
                    message.speedFactor = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSpeedFactorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult info_result = 1; */
        if (message.infoResult)
            InfoResult.internalBinaryWrite(message.infoResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* double speed_factor = 2; */
        if (message.speedFactor !== 0)
            writer.tag(2, WireType.Bit64).double(message.speedFactor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.GetSpeedFactorResponse
 */
export const GetSpeedFactorResponse = new GetSpeedFactorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFlightInformationRequest$Type extends MessageType<SubscribeFlightInformationRequest> {
    constructor() {
        super("mavsdk.rpc.info.SubscribeFlightInformationRequest", []);
    }
    create(value?: PartialMessage<SubscribeFlightInformationRequest>): SubscribeFlightInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeFlightInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFlightInformationRequest): SubscribeFlightInformationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeFlightInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.SubscribeFlightInformationRequest
 */
export const SubscribeFlightInformationRequest = new SubscribeFlightInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightInformationResponse$Type extends MessageType<FlightInformationResponse> {
    constructor() {
        super("mavsdk.rpc.info.FlightInformationResponse", [
            { no: 1, name: "flight_info", kind: "message", T: () => FlightInfo }
        ]);
    }
    create(value?: PartialMessage<FlightInformationResponse>): FlightInformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FlightInformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightInformationResponse): FlightInformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.FlightInfo flight_info */ 1:
                    message.flightInfo = FlightInfo.internalBinaryRead(reader, reader.uint32(), options, message.flightInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightInformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.FlightInfo flight_info = 1; */
        if (message.flightInfo)
            FlightInfo.internalBinaryWrite(message.flightInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.FlightInformationResponse
 */
export const FlightInformationResponse = new FlightInformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightInfo$Type extends MessageType<FlightInfo> {
    constructor() {
        super("mavsdk.rpc.info.FlightInfo", [
            { no: 1, name: "time_boot_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "flight_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "duration_since_arming_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "duration_since_takeoff_ms", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FlightInfo>): FlightInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeBootMs = 0;
        message.flightUid = 0n;
        message.durationSinceArmingMs = 0;
        message.durationSinceTakeoffMs = 0;
        if (value !== undefined)
            reflectionMergePartial<FlightInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightInfo): FlightInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 time_boot_ms */ 1:
                    message.timeBootMs = reader.uint32();
                    break;
                case /* uint64 flight_uid */ 2:
                    message.flightUid = reader.uint64().toBigInt();
                    break;
                case /* uint32 duration_since_arming_ms */ 3:
                    message.durationSinceArmingMs = reader.uint32();
                    break;
                case /* uint32 duration_since_takeoff_ms */ 4:
                    message.durationSinceTakeoffMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 time_boot_ms = 1; */
        if (message.timeBootMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.timeBootMs);
        /* uint64 flight_uid = 2; */
        if (message.flightUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.flightUid);
        /* uint32 duration_since_arming_ms = 3; */
        if (message.durationSinceArmingMs !== 0)
            writer.tag(3, WireType.Varint).uint32(message.durationSinceArmingMs);
        /* uint32 duration_since_takeoff_ms = 4; */
        if (message.durationSinceTakeoffMs !== 0)
            writer.tag(4, WireType.Varint).uint32(message.durationSinceTakeoffMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.FlightInfo
 */
export const FlightInfo = new FlightInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Identification$Type extends MessageType<Identification> {
    constructor() {
        super("mavsdk.rpc.info.Identification", [
            { no: 1, name: "hardware_uid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "legacy_uid", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Identification>): Identification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hardwareUid = "";
        message.legacyUid = 0n;
        if (value !== undefined)
            reflectionMergePartial<Identification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Identification): Identification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hardware_uid */ 1:
                    message.hardwareUid = reader.string();
                    break;
                case /* uint64 legacy_uid */ 2:
                    message.legacyUid = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Identification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hardware_uid = 1; */
        if (message.hardwareUid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hardwareUid);
        /* uint64 legacy_uid = 2; */
        if (message.legacyUid !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.legacyUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.Identification
 */
export const Identification = new Identification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Product$Type extends MessageType<Product> {
    constructor() {
        super("mavsdk.rpc.info.Product", [
            { no: 1, name: "vendor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "vendor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "product_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "product_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Product>): Product {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vendorId = 0;
        message.vendorName = "";
        message.productId = 0;
        message.productName = "";
        if (value !== undefined)
            reflectionMergePartial<Product>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Product): Product {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 vendor_id */ 1:
                    message.vendorId = reader.int32();
                    break;
                case /* string vendor_name */ 2:
                    message.vendorName = reader.string();
                    break;
                case /* int32 product_id */ 3:
                    message.productId = reader.int32();
                    break;
                case /* string product_name */ 4:
                    message.productName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Product, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 vendor_id = 1; */
        if (message.vendorId !== 0)
            writer.tag(1, WireType.Varint).int32(message.vendorId);
        /* string vendor_name = 2; */
        if (message.vendorName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vendorName);
        /* int32 product_id = 3; */
        if (message.productId !== 0)
            writer.tag(3, WireType.Varint).int32(message.productId);
        /* string product_name = 4; */
        if (message.productName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.productName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.Product
 */
export const Product = new Product$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Version$Type extends MessageType<Version> {
    constructor() {
        super("mavsdk.rpc.info.Version", [
            { no: 1, name: "flight_sw_major", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "flight_sw_minor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "flight_sw_patch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "flight_sw_vendor_major", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "flight_sw_vendor_minor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "flight_sw_vendor_patch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "os_sw_major", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "os_sw_minor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "os_sw_patch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "flight_sw_git_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "os_sw_git_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "flight_sw_version_type", kind: "enum", T: () => ["mavsdk.rpc.info.Version.FlightSoftwareVersionType", Version_FlightSoftwareVersionType, "FLIGHT_SOFTWARE_VERSION_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Version>): Version {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flightSwMajor = 0;
        message.flightSwMinor = 0;
        message.flightSwPatch = 0;
        message.flightSwVendorMajor = 0;
        message.flightSwVendorMinor = 0;
        message.flightSwVendorPatch = 0;
        message.osSwMajor = 0;
        message.osSwMinor = 0;
        message.osSwPatch = 0;
        message.flightSwGitHash = "";
        message.osSwGitHash = "";
        message.flightSwVersionType = 0;
        if (value !== undefined)
            reflectionMergePartial<Version>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Version): Version {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 flight_sw_major */ 1:
                    message.flightSwMajor = reader.int32();
                    break;
                case /* int32 flight_sw_minor */ 2:
                    message.flightSwMinor = reader.int32();
                    break;
                case /* int32 flight_sw_patch */ 3:
                    message.flightSwPatch = reader.int32();
                    break;
                case /* int32 flight_sw_vendor_major */ 4:
                    message.flightSwVendorMajor = reader.int32();
                    break;
                case /* int32 flight_sw_vendor_minor */ 5:
                    message.flightSwVendorMinor = reader.int32();
                    break;
                case /* int32 flight_sw_vendor_patch */ 6:
                    message.flightSwVendorPatch = reader.int32();
                    break;
                case /* int32 os_sw_major */ 7:
                    message.osSwMajor = reader.int32();
                    break;
                case /* int32 os_sw_minor */ 8:
                    message.osSwMinor = reader.int32();
                    break;
                case /* int32 os_sw_patch */ 9:
                    message.osSwPatch = reader.int32();
                    break;
                case /* string flight_sw_git_hash */ 10:
                    message.flightSwGitHash = reader.string();
                    break;
                case /* string os_sw_git_hash */ 11:
                    message.osSwGitHash = reader.string();
                    break;
                case /* mavsdk.rpc.info.Version.FlightSoftwareVersionType flight_sw_version_type */ 12:
                    message.flightSwVersionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 flight_sw_major = 1; */
        if (message.flightSwMajor !== 0)
            writer.tag(1, WireType.Varint).int32(message.flightSwMajor);
        /* int32 flight_sw_minor = 2; */
        if (message.flightSwMinor !== 0)
            writer.tag(2, WireType.Varint).int32(message.flightSwMinor);
        /* int32 flight_sw_patch = 3; */
        if (message.flightSwPatch !== 0)
            writer.tag(3, WireType.Varint).int32(message.flightSwPatch);
        /* int32 flight_sw_vendor_major = 4; */
        if (message.flightSwVendorMajor !== 0)
            writer.tag(4, WireType.Varint).int32(message.flightSwVendorMajor);
        /* int32 flight_sw_vendor_minor = 5; */
        if (message.flightSwVendorMinor !== 0)
            writer.tag(5, WireType.Varint).int32(message.flightSwVendorMinor);
        /* int32 flight_sw_vendor_patch = 6; */
        if (message.flightSwVendorPatch !== 0)
            writer.tag(6, WireType.Varint).int32(message.flightSwVendorPatch);
        /* int32 os_sw_major = 7; */
        if (message.osSwMajor !== 0)
            writer.tag(7, WireType.Varint).int32(message.osSwMajor);
        /* int32 os_sw_minor = 8; */
        if (message.osSwMinor !== 0)
            writer.tag(8, WireType.Varint).int32(message.osSwMinor);
        /* int32 os_sw_patch = 9; */
        if (message.osSwPatch !== 0)
            writer.tag(9, WireType.Varint).int32(message.osSwPatch);
        /* string flight_sw_git_hash = 10; */
        if (message.flightSwGitHash !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.flightSwGitHash);
        /* string os_sw_git_hash = 11; */
        if (message.osSwGitHash !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.osSwGitHash);
        /* mavsdk.rpc.info.Version.FlightSoftwareVersionType flight_sw_version_type = 12; */
        if (message.flightSwVersionType !== 0)
            writer.tag(12, WireType.Varint).int32(message.flightSwVersionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.Version
 */
export const Version = new Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoResult$Type extends MessageType<InfoResult> {
    constructor() {
        super("mavsdk.rpc.info.InfoResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.info.InfoResult.Result", InfoResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InfoResult>): InfoResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<InfoResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InfoResult): InfoResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.info.InfoResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InfoResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.info.InfoResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.info.InfoResult
 */
export const InfoResult = new InfoResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.info.InfoService
 */
export const InfoService = new ServiceType("mavsdk.rpc.info.InfoService", [
    { name: "GetFlightInformation", options: { "mavsdk.options.async_type": "SYNC" }, I: GetFlightInformationRequest, O: GetFlightInformationResponse },
    { name: "GetIdentification", options: { "mavsdk.options.async_type": "SYNC" }, I: GetIdentificationRequest, O: GetIdentificationResponse },
    { name: "GetProduct", options: { "mavsdk.options.async_type": "SYNC" }, I: GetProductRequest, O: GetProductResponse },
    { name: "GetVersion", options: { "mavsdk.options.async_type": "SYNC" }, I: GetVersionRequest, O: GetVersionResponse },
    { name: "GetSpeedFactor", options: { "mavsdk.options.async_type": "SYNC" }, I: GetSpeedFactorRequest, O: GetSpeedFactorResponse },
    { name: "SubscribeFlightInformation", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeFlightInformationRequest, O: FlightInformationResponse }
]);
