/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "winch/winch.proto" (package "mavsdk.rpc.winch", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.winch.SubscribeStatusRequest
 */
export interface SubscribeStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.StatusResponse
 */
export interface StatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.Status status = 1;
     */
    status?: Status; // The next 'winch status' state
}
/**
 *
 * Winch Status Flags.
 *
 * The status flags are defined in mavlink
 * https://mavlink.io/en/messages/common.html#MAV_WINCH_STATUS_FLAG.
 *
 * Multiple status fields can be set simultaneously. Mavlink does
 * not specify which states are mutually exclusive.
 *
 * @generated from protobuf message mavsdk.rpc.winch.StatusFlags
 */
export interface StatusFlags {
    /**
     * @generated from protobuf field: bool healthy = 1;
     */
    healthy: boolean; // Winch is healthy
    /**
     * @generated from protobuf field: bool fully_retracted = 2;
     */
    fullyRetracted: boolean; // Winch line is fully retracted
    /**
     * @generated from protobuf field: bool moving = 3;
     */
    moving: boolean; // Winch motor is moving
    /**
     * @generated from protobuf field: bool clutch_engaged = 4;
     */
    clutchEngaged: boolean; // Winch clutch is engaged allowing motor to move freely
    /**
     * @generated from protobuf field: bool locked = 5;
     */
    locked: boolean; // Winch is locked by locking mechanism
    /**
     * @generated from protobuf field: bool dropping = 6;
     */
    dropping: boolean; // Winch is gravity dropping payload
    /**
     * @generated from protobuf field: bool arresting = 7;
     */
    arresting: boolean; // Winch is arresting payload descent
    /**
     * @generated from protobuf field: bool ground_sense = 8;
     */
    groundSense: boolean; // Winch is using torque measurements to sense the ground
    /**
     * @generated from protobuf field: bool retracting = 9;
     */
    retracting: boolean; // Winch is returning to the fully retracted position
    /**
     * @generated from protobuf field: bool redeliver = 10;
     */
    redeliver: boolean; // Winch is redelivering the payload. This is a failover state if the line tension goes above a threshold during RETRACTING.
    /**
     * @generated from protobuf field: bool abandon_line = 11;
     */
    abandonLine: boolean; // Winch is abandoning the line and possibly payload. Winch unspools the entire calculated line length. This is a failover state from REDELIVER if the number of attempts exceeds a threshold.
    /**
     * @generated from protobuf field: bool locking = 12;
     */
    locking: boolean; // Winch is engaging the locking mechanism
    /**
     * @generated from protobuf field: bool load_line = 13;
     */
    loadLine: boolean; // Winch is spooling on line
    /**
     * @generated from protobuf field: bool load_payload = 14;
     */
    loadPayload: boolean; // Winch is loading a payload
}
/**
 * Status type.
 *
 * @generated from protobuf message mavsdk.rpc.winch.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // Time in usec
    /**
     * @generated from protobuf field: float line_length_m = 2;
     */
    lineLengthM: number; // Length of the line in meters
    /**
     * @generated from protobuf field: float speed_m_s = 3;
     */
    speedMS: number; // Speed in meters per second
    /**
     * @generated from protobuf field: float tension_kg = 4;
     */
    tensionKg: number; // Tension in kilograms
    /**
     * @generated from protobuf field: float voltage_v = 5;
     */
    voltageV: number; // Voltage in volts
    /**
     * @generated from protobuf field: float current_a = 6;
     */
    currentA: number; // Current in amperes
    /**
     * @generated from protobuf field: int32 temperature_c = 7;
     */
    temperatureC: number; // Temperature in Celsius
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.StatusFlags status_flags = 8;
     */
    statusFlags?: StatusFlags; // Status flags
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RelaxRequest
 */
export interface RelaxRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RelaxResponse
 */
export interface RelaxResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RelativeLengthControlRequest
 */
export interface RelativeLengthControlRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number; // Instance ID of the winch addressed by this request
    /**
     * @generated from protobuf field: float length_m = 2;
     */
    lengthM: number; // Length of line to unwind or wind
    /**
     * @generated from protobuf field: float rate_m_s = 3;
     */
    rateMS: number; // Rate at which to wind or unwind the line
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RelativeLengthControlResponse
 */
export interface RelativeLengthControlResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RateControlRequest
 */
export interface RateControlRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
    /**
     * @generated from protobuf field: float rate_m_s = 2;
     */
    rateMS: number; // Rate at which to wind or unwind the line
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RateControlResponse
 */
export interface RateControlResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LockRequest
 */
export interface LockRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LockResponse
 */
export interface LockResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.DeliverRequest
 */
export interface DeliverRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.DeliverResponse
 */
export interface DeliverResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.HoldRequest
 */
export interface HoldRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.HoldResponse
 */
export interface HoldResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RetractRequest
 */
export interface RetractRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.RetractResponse
 */
export interface RetractResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LoadLineRequest
 */
export interface LoadLineRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LoadLineResponse
 */
export interface LoadLineResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.AbandonLineRequest
 */
export interface AbandonLineRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.AbandonLineResponse
 */
export interface AbandonLineResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LoadPayloadRequest
 */
export interface LoadPayloadRequest {
    /**
     * @generated from protobuf field: uint32 instance = 1;
     */
    instance: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.winch.LoadPayloadResponse
 */
export interface LoadPayloadResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult winch_result = 1;
     */
    winchResult?: WinchResult;
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.winch.WinchResult
 */
export interface WinchResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.winch.WinchResult.Result result = 1;
     */
    result: WinchResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for winch action requests.
 *
 * @generated from protobuf enum mavsdk.rpc.winch.WinchResult.Result
 */
export enum WinchResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request was successful
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system is connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Temporarily rejected
     *
     * @generated from protobuf enum value: RESULT_BUSY = 3;
     */
    BUSY = 3,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 4;
     */
    TIMEOUT = 4,
    /**
     * Action not supported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 5;
     */
    UNSUPPORTED = 5,
    /**
     * Action failed
     *
     * @generated from protobuf enum value: RESULT_FAILED = 6;
     */
    FAILED = 6
}
/**
 * Winch Action type.
 *
 * @generated from protobuf enum mavsdk.rpc.winch.WinchAction
 */
export enum WinchAction {
    /**
     * Allow motor to freewheel
     *
     * @generated from protobuf enum value: WINCH_ACTION_RELAXED = 0;
     */
    RELAXED = 0,
    /**
     * Wind or unwind specified length of line, optionally using specified rate
     *
     * @generated from protobuf enum value: WINCH_ACTION_RELATIVE_LENGTH_CONTROL = 1;
     */
    RELATIVE_LENGTH_CONTROL = 1,
    /**
     * Wind or unwind line at specified rate
     *
     * @generated from protobuf enum value: WINCH_ACTION_RATE_CONTROL = 2;
     */
    RATE_CONTROL = 2,
    /**
     * Perform the locking sequence to relieve motor while in the fully retracted position
     *
     * @generated from protobuf enum value: WINCH_ACTION_LOCK = 3;
     */
    LOCK = 3,
    /**
     * Sequence of drop, slow down, touch down, reel up, lock
     *
     * @generated from protobuf enum value: WINCH_ACTION_DELIVER = 4;
     */
    DELIVER = 4,
    /**
     * Engage motor and hold current position
     *
     * @generated from protobuf enum value: WINCH_ACTION_HOLD = 5;
     */
    HOLD = 5,
    /**
     * Return the reel to the fully retracted position
     *
     * @generated from protobuf enum value: WINCH_ACTION_RETRACT = 6;
     */
    RETRACT = 6,
    /**
     * Load the reel with line. The winch will calculate the total loaded length and stop when the tension exceeds a threshold
     *
     * @generated from protobuf enum value: WINCH_ACTION_LOAD_LINE = 7;
     */
    LOAD_LINE = 7,
    /**
     * Spool out the entire length of the line
     *
     * @generated from protobuf enum value: WINCH_ACTION_ABANDON_LINE = 8;
     */
    ABANDON_LINE = 8,
    /**
     * Spools out just enough to present the hook to the user to load the payload
     *
     * @generated from protobuf enum value: WINCH_ACTION_LOAD_PAYLOAD = 9;
     */
    LOAD_PAYLOAD = 9
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatusRequest$Type extends MessageType<SubscribeStatusRequest> {
    constructor() {
        super("mavsdk.rpc.winch.SubscribeStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeStatusRequest>): SubscribeStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStatusRequest): SubscribeStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.SubscribeStatusRequest
 */
export const SubscribeStatusRequest = new SubscribeStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusResponse$Type extends MessageType<StatusResponse> {
    constructor() {
        super("mavsdk.rpc.winch.StatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StatusResponse>): StatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusResponse): StatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.StatusResponse
 */
export const StatusResponse = new StatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusFlags$Type extends MessageType<StatusFlags> {
    constructor() {
        super("mavsdk.rpc.winch.StatusFlags", [
            { no: 1, name: "healthy", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "fully_retracted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "moving", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "clutch_engaged", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "dropping", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "arresting", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "ground_sense", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "retracting", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "redeliver", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "abandon_line", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "locking", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "load_line", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "load_payload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StatusFlags>): StatusFlags {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthy = false;
        message.fullyRetracted = false;
        message.moving = false;
        message.clutchEngaged = false;
        message.locked = false;
        message.dropping = false;
        message.arresting = false;
        message.groundSense = false;
        message.retracting = false;
        message.redeliver = false;
        message.abandonLine = false;
        message.locking = false;
        message.loadLine = false;
        message.loadPayload = false;
        if (value !== undefined)
            reflectionMergePartial<StatusFlags>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusFlags): StatusFlags {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool healthy */ 1:
                    message.healthy = reader.bool();
                    break;
                case /* bool fully_retracted */ 2:
                    message.fullyRetracted = reader.bool();
                    break;
                case /* bool moving */ 3:
                    message.moving = reader.bool();
                    break;
                case /* bool clutch_engaged */ 4:
                    message.clutchEngaged = reader.bool();
                    break;
                case /* bool locked */ 5:
                    message.locked = reader.bool();
                    break;
                case /* bool dropping */ 6:
                    message.dropping = reader.bool();
                    break;
                case /* bool arresting */ 7:
                    message.arresting = reader.bool();
                    break;
                case /* bool ground_sense */ 8:
                    message.groundSense = reader.bool();
                    break;
                case /* bool retracting */ 9:
                    message.retracting = reader.bool();
                    break;
                case /* bool redeliver */ 10:
                    message.redeliver = reader.bool();
                    break;
                case /* bool abandon_line */ 11:
                    message.abandonLine = reader.bool();
                    break;
                case /* bool locking */ 12:
                    message.locking = reader.bool();
                    break;
                case /* bool load_line */ 13:
                    message.loadLine = reader.bool();
                    break;
                case /* bool load_payload */ 14:
                    message.loadPayload = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusFlags, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool healthy = 1; */
        if (message.healthy !== false)
            writer.tag(1, WireType.Varint).bool(message.healthy);
        /* bool fully_retracted = 2; */
        if (message.fullyRetracted !== false)
            writer.tag(2, WireType.Varint).bool(message.fullyRetracted);
        /* bool moving = 3; */
        if (message.moving !== false)
            writer.tag(3, WireType.Varint).bool(message.moving);
        /* bool clutch_engaged = 4; */
        if (message.clutchEngaged !== false)
            writer.tag(4, WireType.Varint).bool(message.clutchEngaged);
        /* bool locked = 5; */
        if (message.locked !== false)
            writer.tag(5, WireType.Varint).bool(message.locked);
        /* bool dropping = 6; */
        if (message.dropping !== false)
            writer.tag(6, WireType.Varint).bool(message.dropping);
        /* bool arresting = 7; */
        if (message.arresting !== false)
            writer.tag(7, WireType.Varint).bool(message.arresting);
        /* bool ground_sense = 8; */
        if (message.groundSense !== false)
            writer.tag(8, WireType.Varint).bool(message.groundSense);
        /* bool retracting = 9; */
        if (message.retracting !== false)
            writer.tag(9, WireType.Varint).bool(message.retracting);
        /* bool redeliver = 10; */
        if (message.redeliver !== false)
            writer.tag(10, WireType.Varint).bool(message.redeliver);
        /* bool abandon_line = 11; */
        if (message.abandonLine !== false)
            writer.tag(11, WireType.Varint).bool(message.abandonLine);
        /* bool locking = 12; */
        if (message.locking !== false)
            writer.tag(12, WireType.Varint).bool(message.locking);
        /* bool load_line = 13; */
        if (message.loadLine !== false)
            writer.tag(13, WireType.Varint).bool(message.loadLine);
        /* bool load_payload = 14; */
        if (message.loadPayload !== false)
            writer.tag(14, WireType.Varint).bool(message.loadPayload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.StatusFlags
 */
export const StatusFlags = new StatusFlags$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("mavsdk.rpc.winch.Status", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "line_length_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "speed_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "tension_kg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "voltage_v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "current_a", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "temperature_c", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "status_flags", kind: "message", T: () => StatusFlags }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        message.lineLengthM = 0;
        message.speedMS = 0;
        message.tensionKg = 0;
        message.voltageV = 0;
        message.currentA = 0;
        message.temperatureC = 0;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* float line_length_m */ 2:
                    message.lineLengthM = reader.float();
                    break;
                case /* float speed_m_s */ 3:
                    message.speedMS = reader.float();
                    break;
                case /* float tension_kg */ 4:
                    message.tensionKg = reader.float();
                    break;
                case /* float voltage_v */ 5:
                    message.voltageV = reader.float();
                    break;
                case /* float current_a */ 6:
                    message.currentA = reader.float();
                    break;
                case /* int32 temperature_c */ 7:
                    message.temperatureC = reader.int32();
                    break;
                case /* mavsdk.rpc.winch.StatusFlags status_flags */ 8:
                    message.statusFlags = StatusFlags.internalBinaryRead(reader, reader.uint32(), options, message.statusFlags);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* float line_length_m = 2; */
        if (message.lineLengthM !== 0)
            writer.tag(2, WireType.Bit32).float(message.lineLengthM);
        /* float speed_m_s = 3; */
        if (message.speedMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.speedMS);
        /* float tension_kg = 4; */
        if (message.tensionKg !== 0)
            writer.tag(4, WireType.Bit32).float(message.tensionKg);
        /* float voltage_v = 5; */
        if (message.voltageV !== 0)
            writer.tag(5, WireType.Bit32).float(message.voltageV);
        /* float current_a = 6; */
        if (message.currentA !== 0)
            writer.tag(6, WireType.Bit32).float(message.currentA);
        /* int32 temperature_c = 7; */
        if (message.temperatureC !== 0)
            writer.tag(7, WireType.Varint).int32(message.temperatureC);
        /* mavsdk.rpc.winch.StatusFlags status_flags = 8; */
        if (message.statusFlags)
            StatusFlags.internalBinaryWrite(message.statusFlags, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelaxRequest$Type extends MessageType<RelaxRequest> {
    constructor() {
        super("mavsdk.rpc.winch.RelaxRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RelaxRequest>): RelaxRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<RelaxRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelaxRequest): RelaxRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelaxRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RelaxRequest
 */
export const RelaxRequest = new RelaxRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelaxResponse$Type extends MessageType<RelaxResponse> {
    constructor() {
        super("mavsdk.rpc.winch.RelaxResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<RelaxResponse>): RelaxResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RelaxResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelaxResponse): RelaxResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelaxResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RelaxResponse
 */
export const RelaxResponse = new RelaxResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelativeLengthControlRequest$Type extends MessageType<RelativeLengthControlRequest> {
    constructor() {
        super("mavsdk.rpc.winch.RelativeLengthControlRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "length_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "rate_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<RelativeLengthControlRequest>): RelativeLengthControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        message.lengthM = 0;
        message.rateMS = 0;
        if (value !== undefined)
            reflectionMergePartial<RelativeLengthControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelativeLengthControlRequest): RelativeLengthControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                case /* float length_m */ 2:
                    message.lengthM = reader.float();
                    break;
                case /* float rate_m_s */ 3:
                    message.rateMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelativeLengthControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        /* float length_m = 2; */
        if (message.lengthM !== 0)
            writer.tag(2, WireType.Bit32).float(message.lengthM);
        /* float rate_m_s = 3; */
        if (message.rateMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.rateMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RelativeLengthControlRequest
 */
export const RelativeLengthControlRequest = new RelativeLengthControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelativeLengthControlResponse$Type extends MessageType<RelativeLengthControlResponse> {
    constructor() {
        super("mavsdk.rpc.winch.RelativeLengthControlResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<RelativeLengthControlResponse>): RelativeLengthControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RelativeLengthControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelativeLengthControlResponse): RelativeLengthControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelativeLengthControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RelativeLengthControlResponse
 */
export const RelativeLengthControlResponse = new RelativeLengthControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateControlRequest$Type extends MessageType<RateControlRequest> {
    constructor() {
        super("mavsdk.rpc.winch.RateControlRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rate_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<RateControlRequest>): RateControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        message.rateMS = 0;
        if (value !== undefined)
            reflectionMergePartial<RateControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateControlRequest): RateControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                case /* float rate_m_s */ 2:
                    message.rateMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        /* float rate_m_s = 2; */
        if (message.rateMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.rateMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RateControlRequest
 */
export const RateControlRequest = new RateControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateControlResponse$Type extends MessageType<RateControlResponse> {
    constructor() {
        super("mavsdk.rpc.winch.RateControlResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<RateControlResponse>): RateControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateControlResponse): RateControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RateControlResponse
 */
export const RateControlResponse = new RateControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockRequest$Type extends MessageType<LockRequest> {
    constructor() {
        super("mavsdk.rpc.winch.LockRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LockRequest>): LockRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<LockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockRequest): LockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LockRequest
 */
export const LockRequest = new LockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LockResponse$Type extends MessageType<LockResponse> {
    constructor() {
        super("mavsdk.rpc.winch.LockResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<LockResponse>): LockResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LockResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LockResponse): LockResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LockResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LockResponse
 */
export const LockResponse = new LockResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeliverRequest$Type extends MessageType<DeliverRequest> {
    constructor() {
        super("mavsdk.rpc.winch.DeliverRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeliverRequest>): DeliverRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<DeliverRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeliverRequest): DeliverRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeliverRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.DeliverRequest
 */
export const DeliverRequest = new DeliverRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeliverResponse$Type extends MessageType<DeliverResponse> {
    constructor() {
        super("mavsdk.rpc.winch.DeliverResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<DeliverResponse>): DeliverResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeliverResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeliverResponse): DeliverResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeliverResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.DeliverResponse
 */
export const DeliverResponse = new DeliverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HoldRequest$Type extends MessageType<HoldRequest> {
    constructor() {
        super("mavsdk.rpc.winch.HoldRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HoldRequest>): HoldRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<HoldRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HoldRequest): HoldRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HoldRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.HoldRequest
 */
export const HoldRequest = new HoldRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HoldResponse$Type extends MessageType<HoldResponse> {
    constructor() {
        super("mavsdk.rpc.winch.HoldResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<HoldResponse>): HoldResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HoldResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HoldResponse): HoldResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HoldResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.HoldResponse
 */
export const HoldResponse = new HoldResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetractRequest$Type extends MessageType<RetractRequest> {
    constructor() {
        super("mavsdk.rpc.winch.RetractRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RetractRequest>): RetractRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<RetractRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetractRequest): RetractRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetractRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RetractRequest
 */
export const RetractRequest = new RetractRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetractResponse$Type extends MessageType<RetractResponse> {
    constructor() {
        super("mavsdk.rpc.winch.RetractResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<RetractResponse>): RetractResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetractResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetractResponse): RetractResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetractResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.RetractResponse
 */
export const RetractResponse = new RetractResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadLineRequest$Type extends MessageType<LoadLineRequest> {
    constructor() {
        super("mavsdk.rpc.winch.LoadLineRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadLineRequest>): LoadLineRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<LoadLineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadLineRequest): LoadLineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadLineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LoadLineRequest
 */
export const LoadLineRequest = new LoadLineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadLineResponse$Type extends MessageType<LoadLineResponse> {
    constructor() {
        super("mavsdk.rpc.winch.LoadLineResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<LoadLineResponse>): LoadLineResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoadLineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadLineResponse): LoadLineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadLineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LoadLineResponse
 */
export const LoadLineResponse = new LoadLineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbandonLineRequest$Type extends MessageType<AbandonLineRequest> {
    constructor() {
        super("mavsdk.rpc.winch.AbandonLineRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AbandonLineRequest>): AbandonLineRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<AbandonLineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonLineRequest): AbandonLineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbandonLineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.AbandonLineRequest
 */
export const AbandonLineRequest = new AbandonLineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbandonLineResponse$Type extends MessageType<AbandonLineResponse> {
    constructor() {
        super("mavsdk.rpc.winch.AbandonLineResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<AbandonLineResponse>): AbandonLineResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AbandonLineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AbandonLineResponse): AbandonLineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AbandonLineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.AbandonLineResponse
 */
export const AbandonLineResponse = new AbandonLineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadPayloadRequest$Type extends MessageType<LoadPayloadRequest> {
    constructor() {
        super("mavsdk.rpc.winch.LoadPayloadRequest", [
            { no: 1, name: "instance", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LoadPayloadRequest>): LoadPayloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instance = 0;
        if (value !== undefined)
            reflectionMergePartial<LoadPayloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadPayloadRequest): LoadPayloadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instance */ 1:
                    message.instance = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadPayloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instance = 1; */
        if (message.instance !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LoadPayloadRequest
 */
export const LoadPayloadRequest = new LoadPayloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadPayloadResponse$Type extends MessageType<LoadPayloadResponse> {
    constructor() {
        super("mavsdk.rpc.winch.LoadPayloadResponse", [
            { no: 1, name: "winch_result", kind: "message", T: () => WinchResult }
        ]);
    }
    create(value?: PartialMessage<LoadPayloadResponse>): LoadPayloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LoadPayloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadPayloadResponse): LoadPayloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult winch_result */ 1:
                    message.winchResult = WinchResult.internalBinaryRead(reader, reader.uint32(), options, message.winchResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadPayloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult winch_result = 1; */
        if (message.winchResult)
            WinchResult.internalBinaryWrite(message.winchResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.LoadPayloadResponse
 */
export const LoadPayloadResponse = new LoadPayloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WinchResult$Type extends MessageType<WinchResult> {
    constructor() {
        super("mavsdk.rpc.winch.WinchResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.winch.WinchResult.Result", WinchResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WinchResult>): WinchResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<WinchResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WinchResult): WinchResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.winch.WinchResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WinchResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.winch.WinchResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.winch.WinchResult
 */
export const WinchResult = new WinchResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.winch.WinchService
 */
export const WinchService = new ServiceType("mavsdk.rpc.winch.WinchService", [
    { name: "SubscribeStatus", serverStreaming: true, options: {}, I: SubscribeStatusRequest, O: StatusResponse },
    { name: "Relax", options: {}, I: RelaxRequest, O: RelaxResponse },
    { name: "RelativeLengthControl", options: {}, I: RelativeLengthControlRequest, O: RelativeLengthControlResponse },
    { name: "RateControl", options: {}, I: RateControlRequest, O: RateControlResponse },
    { name: "Lock", options: {}, I: LockRequest, O: LockResponse },
    { name: "Deliver", options: {}, I: DeliverRequest, O: DeliverResponse },
    { name: "Hold", options: {}, I: HoldRequest, O: HoldResponse },
    { name: "Retract", options: {}, I: RetractRequest, O: RetractResponse },
    { name: "LoadLine", options: {}, I: LoadLineRequest, O: LoadLineResponse },
    { name: "AbandonLine", options: {}, I: AbandonLineRequest, O: AbandonLineResponse },
    { name: "LoadPayload", options: {}, I: LoadPayloadRequest, O: LoadPayloadResponse }
]);
