/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "camera_server/camera_server.proto" (package "mavsdk.rpc.camera_server", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetInformationRequest
 */
export interface SetInformationRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.Information information = 1;
     */
    information?: Information; // information about the camera
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetInformationResponse
 */
export interface SetInformationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetVideoStreamingRequest
 */
export interface SetVideoStreamingRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.VideoStreaming video_streaming = 1;
     */
    videoStreaming?: VideoStreaming; // information about the video stream
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetVideoStreamingResponse
 */
export interface SetVideoStreamingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetInProgressRequest
 */
export interface SetInProgressRequest {
    /**
     * @generated from protobuf field: bool in_progress = 1;
     */
    inProgress: boolean; // true if capture is in progress or false for idle.
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetInProgressResponse
 */
export interface SetInProgressResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeTakePhotoRequest
 */
export interface SubscribeTakePhotoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.TakePhotoResponse
 */
export interface TakePhotoResponse {
    /**
     * @generated from protobuf field: int32 index = 1;
     */
    index: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTakePhotoRequest
 */
export interface RespondTakePhotoRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback take_photo_feedback = 1;
     */
    takePhotoFeedback: CameraFeedback; // the feedback
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CaptureInfo capture_info = 2;
     */
    captureInfo?: CaptureInfo; // the capture information
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTakePhotoResponse
 */
export interface RespondTakePhotoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeStartVideoRequest
 */
export interface SubscribeStartVideoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.StartVideoResponse
 */
export interface StartVideoResponse {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStartVideoRequest
 */
export interface RespondStartVideoRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback start_video_feedback = 1;
     */
    startVideoFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStartVideoResponse
 */
export interface RespondStartVideoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeStopVideoRequest
 */
export interface SubscribeStopVideoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.StopVideoResponse
 */
export interface StopVideoResponse {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStopVideoRequest
 */
export interface RespondStopVideoRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
     */
    stopVideoFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStopVideoResponse
 */
export interface RespondStopVideoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest
 */
export interface SubscribeStartVideoStreamingRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.StartVideoStreamingResponse
 */
export interface StartVideoStreamingResponse {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest
 */
export interface RespondStartVideoStreamingRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback start_video_streaming_feedback = 1;
     */
    startVideoStreamingFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse
 */
export interface RespondStartVideoStreamingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest
 */
export interface SubscribeStopVideoStreamingRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.StopVideoStreamingResponse
 */
export interface StopVideoStreamingResponse {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest
 */
export interface RespondStopVideoStreamingRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback stop_video_streaming_feedback = 1;
     */
    stopVideoStreamingFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse
 */
export interface RespondStopVideoStreamingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeSetModeRequest
 */
export interface SubscribeSetModeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetModeResponse
 */
export interface SetModeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.Mode mode = 1;
     */
    mode: Mode;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondSetModeRequest
 */
export interface RespondSetModeRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback set_mode_feedback = 1;
     */
    setModeFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondSetModeResponse
 */
export interface RespondSetModeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeStorageInformationRequest
 */
export interface SubscribeStorageInformationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.StorageInformationResponse
 */
export interface StorageInformationResponse {
    /**
     * @generated from protobuf field: int32 storage_id = 1;
     */
    storageId: number;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStorageInformationRequest
 */
export interface RespondStorageInformationRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback storage_information_feedback = 1;
     */
    storageInformationFeedback: CameraFeedback; // the feedback
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.StorageInformation storage_information = 2;
     */
    storageInformation?: StorageInformation; // the storage information
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondStorageInformationResponse
 */
export interface RespondStorageInformationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest
 */
export interface SubscribeCaptureStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.CaptureStatusResponse
 */
export interface CaptureStatusResponse {
    /**
     * @generated from protobuf field: int32 reserved = 1;
     */
    reserved: number; // reserved, just make protoc-gen-mavsdk working
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondCaptureStatusRequest
 */
export interface RespondCaptureStatusRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback capture_status_feedback = 1;
     */
    captureStatusFeedback: CameraFeedback; // the feedback
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CaptureStatus capture_status = 2;
     */
    captureStatus?: CaptureStatus; // the capture status
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondCaptureStatusResponse
 */
export interface RespondCaptureStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeFormatStorageRequest
 */
export interface SubscribeFormatStorageRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.FormatStorageResponse
 */
export interface FormatStorageResponse {
    /**
     * @generated from protobuf field: int32 storage_id = 1;
     */
    storageId: number; // the storage id to format
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondFormatStorageRequest
 */
export interface RespondFormatStorageRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback format_storage_feedback = 1;
     */
    formatStorageFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondFormatStorageResponse
 */
export interface RespondFormatStorageResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeResetSettingsRequest
 */
export interface SubscribeResetSettingsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.ResetSettingsResponse
 */
export interface ResetSettingsResponse {
    /**
     * @generated from protobuf field: int32 reserved = 1;
     */
    reserved: number; // reserved, just make protoc-gen-mavsdk working
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondResetSettingsRequest
 */
export interface RespondResetSettingsRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback reset_settings_feedback = 1;
     */
    resetSettingsFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondResetSettingsResponse
 */
export interface RespondResetSettingsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeZoomInStartRequest
 */
export interface SubscribeZoomInStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.ZoomInStartResponse
 */
export interface ZoomInStartResponse {
    /**
     * @generated from protobuf field: int32 reserved = 1;
     */
    reserved: number; // reserved, just make protoc-gen-mavsdk working
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomInStartRequest
 */
export interface RespondZoomInStartRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback zoom_in_start_feedback = 1;
     */
    zoomInStartFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomInStartResponse
 */
export interface RespondZoomInStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest
 */
export interface SubscribeZoomOutStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.ZoomOutStartResponse
 */
export interface ZoomOutStartResponse {
    /**
     * @generated from protobuf field: int32 reserved = 1;
     */
    reserved: number; // reserved, just make protoc-gen-mavsdk working
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomOutStartRequest
 */
export interface RespondZoomOutStartRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback zoom_out_start_feedback = 1;
     */
    zoomOutStartFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomOutStartResponse
 */
export interface RespondZoomOutStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeZoomStopRequest
 */
export interface SubscribeZoomStopRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.ZoomStopResponse
 */
export interface ZoomStopResponse {
    /**
     * @generated from protobuf field: int32 reserved = 1;
     */
    reserved: number; // reserved, just make protoc-gen-mavsdk working
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomStopRequest
 */
export interface RespondZoomStopRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback zoom_stop_feedback = 1;
     */
    zoomStopFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomStopResponse
 */
export interface RespondZoomStopResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeZoomRangeRequest
 */
export interface SubscribeZoomRangeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.ZoomRangeResponse
 */
export interface ZoomRangeResponse {
    /**
     * @generated from protobuf field: float factor = 1;
     */
    factor: number; // The zoom factor, starting at 1x.
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomRangeRequest
 */
export interface RespondZoomRangeRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback zoom_range_feedback = 1;
     */
    zoomRangeFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondZoomRangeResponse
 */
export interface RespondZoomRangeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult;
}
/**
 * Type to represent a camera information.
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.Information
 */
export interface Information {
    /**
     * @generated from protobuf field: string vendor_name = 1;
     */
    vendorName: string; // Name of the camera vendor
    /**
     * @generated from protobuf field: string model_name = 2;
     */
    modelName: string; // Name of the camera model
    /**
     * @generated from protobuf field: string firmware_version = 3;
     */
    firmwareVersion: string; // Camera firmware version in major[.minor[.patch[.dev]]] format
    /**
     * @generated from protobuf field: float focal_length_mm = 4;
     */
    focalLengthMm: number; // Focal length
    /**
     * @generated from protobuf field: float horizontal_sensor_size_mm = 5;
     */
    horizontalSensorSizeMm: number; // Horizontal sensor size
    /**
     * @generated from protobuf field: float vertical_sensor_size_mm = 6;
     */
    verticalSensorSizeMm: number; // Vertical sensor size
    /**
     * @generated from protobuf field: uint32 horizontal_resolution_px = 7;
     */
    horizontalResolutionPx: number; // Horizontal image resolution in pixels
    /**
     * @generated from protobuf field: uint32 vertical_resolution_px = 8;
     */
    verticalResolutionPx: number; // Vertical image resolution in pixels
    /**
     * @generated from protobuf field: uint32 lens_id = 9;
     */
    lensId: number; // Lens ID
    /**
     * @generated from protobuf field: uint32 definition_file_version = 10;
     */
    definitionFileVersion: number; // Camera definition file version (iteration)
    /**
     * @generated from protobuf field: string definition_file_uri = 11;
     */
    definitionFileUri: string; // Camera definition URI (http or mavlink ftp)
    /**
     * @generated from protobuf field: bool image_in_video_mode_supported = 12;
     */
    imageInVideoModeSupported: boolean; // Camera supports taking images while in video mode
    /**
     * @generated from protobuf field: bool video_in_image_mode_supported = 13;
     */
    videoInImageModeSupported: boolean; // Camera supports recording video while in image mode
}
/**
 * Type to represent video streaming settings
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.VideoStreaming
 */
export interface VideoStreaming {
    /**
     * @generated from protobuf field: bool has_rtsp_server = 1;
     */
    hasRtspServer: boolean; // True if the capture was successful
    /**
     * @generated from protobuf field: string rtsp_uri = 2;
     */
    rtspUri: string; // RTSP URI (e.g. rtsp://192.168.1.42:8554/live)
}
/**
 * Position type in global coordinates.
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to +180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float relative_altitude_m = 4;
     */
    relativeAltitudeM: number; // Altitude relative to takeoff altitude in metres
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
}
/**
 * Information about a picture just captured.
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.CaptureInfo
 */
export interface CaptureInfo {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.Position position = 1;
     */
    position?: Position; // Location where the picture was taken
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.Quaternion attitude_quaternion = 2;
     */
    attitudeQuaternion?: Quaternion; // Attitude of the camera when the picture was taken (quaternion)
    /**
     * @generated from protobuf field: uint64 time_utc_us = 3;
     */
    timeUtcUs: bigint; // Timestamp in UTC (since UNIX epoch) in microseconds
    /**
     * @generated from protobuf field: bool is_success = 4;
     */
    isSuccess: boolean; // True if the capture was successful
    /**
     * @generated from protobuf field: int32 index = 5;
     */
    index: number; // Index from TakePhotoResponse
    /**
     * @generated from protobuf field: string file_url = 6;
     */
    fileUrl: string; // Download URL of this image
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.CameraServerResult
 */
export interface CameraServerResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult.Result result = 1;
     */
    result: CameraServerResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for action requests.
 *
 * @generated from protobuf enum mavsdk.rpc.camera_server.CameraServerResult.Result
 */
export enum CameraServerResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Command executed successfully
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Command in progress
     *
     * @generated from protobuf enum value: RESULT_IN_PROGRESS = 2;
     */
    IN_PROGRESS = 2,
    /**
     * Camera is busy and rejected command
     *
     * @generated from protobuf enum value: RESULT_BUSY = 3;
     */
    BUSY = 3,
    /**
     * Camera denied the command
     *
     * @generated from protobuf enum value: RESULT_DENIED = 4;
     */
    DENIED = 4,
    /**
     * An error has occurred while executing the command
     *
     * @generated from protobuf enum value: RESULT_ERROR = 5;
     */
    ERROR = 5,
    /**
     * Command timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * Command has wrong argument(s)
     *
     * @generated from protobuf enum value: RESULT_WRONG_ARGUMENT = 7;
     */
    WRONG_ARGUMENT = 7,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 8;
     */
    NO_SYSTEM = 8
}
/**
 * Information about the camera storage.
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.StorageInformation
 */
export interface StorageInformation {
    /**
     * @generated from protobuf field: float used_storage_mib = 1;
     */
    usedStorageMib: number; // Used storage (in MiB)
    /**
     * @generated from protobuf field: float available_storage_mib = 2;
     */
    availableStorageMib: number; // Available storage (in MiB)
    /**
     * @generated from protobuf field: float total_storage_mib = 3;
     */
    totalStorageMib: number; // Total storage (in MiB)
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.StorageInformation.StorageStatus storage_status = 4;
     */
    storageStatus: StorageInformation_StorageStatus; // Storage status
    /**
     * @generated from protobuf field: uint32 storage_id = 5;
     */
    storageId: number; // Storage ID starting at 1
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.StorageInformation.StorageType storage_type = 6;
     */
    storageType: StorageInformation_StorageType; // Storage type
    /**
     * @generated from protobuf field: float read_speed_mib_s = 7;
     */
    readSpeedMibS: number; // Read speed [MiB/s]
    /**
     * @generated from protobuf field: float write_speed_mib_s = 8;
     */
    writeSpeedMibS: number; // Write speed [MiB/s]
}
/**
 * Storage status type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera_server.StorageInformation.StorageStatus
 */
export enum StorageInformation_StorageStatus {
    /**
     * Storage not available
     *
     * @generated from protobuf enum value: STORAGE_STATUS_NOT_AVAILABLE = 0;
     */
    NOT_AVAILABLE = 0,
    /**
     * Storage is not formatted (i.e. has no recognized file system)
     *
     * @generated from protobuf enum value: STORAGE_STATUS_UNFORMATTED = 1;
     */
    UNFORMATTED = 1,
    /**
     * Storage is formatted (i.e. has recognized a file system)
     *
     * @generated from protobuf enum value: STORAGE_STATUS_FORMATTED = 2;
     */
    FORMATTED = 2,
    /**
     * Storage status is not supported
     *
     * @generated from protobuf enum value: STORAGE_STATUS_NOT_SUPPORTED = 3;
     */
    NOT_SUPPORTED = 3
}
/**
 * Storage type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera_server.StorageInformation.StorageType
 */
export enum StorageInformation_StorageType {
    /**
     * Storage type unknown
     *
     * @generated from protobuf enum value: STORAGE_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Storage type USB stick
     *
     * @generated from protobuf enum value: STORAGE_TYPE_USB_STICK = 1;
     */
    USB_STICK = 1,
    /**
     * Storage type SD card
     *
     * @generated from protobuf enum value: STORAGE_TYPE_SD = 2;
     */
    SD = 2,
    /**
     * Storage type MicroSD card
     *
     * @generated from protobuf enum value: STORAGE_TYPE_MICROSD = 3;
     */
    MICROSD = 3,
    /**
     * Storage type HD mass storage
     *
     * @generated from protobuf enum value: STORAGE_TYPE_HD = 7;
     */
    HD = 7,
    /**
     * Storage type other, not listed
     *
     * @generated from protobuf enum value: STORAGE_TYPE_OTHER = 254;
     */
    OTHER = 254
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.CaptureStatus
 */
export interface CaptureStatus {
    /**
     * @generated from protobuf field: float image_interval_s = 1;
     */
    imageIntervalS: number; // Image capture interval (in s)
    /**
     * @generated from protobuf field: float recording_time_s = 2;
     */
    recordingTimeS: number; // Elapsed time since recording started (in s)
    /**
     * @generated from protobuf field: float available_capacity_mib = 3;
     */
    availableCapacityMib: number; // Available storage capacity. (in MiB)
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CaptureStatus.ImageStatus image_status = 4;
     */
    imageStatus: CaptureStatus_ImageStatus; // Current status of image capturing
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CaptureStatus.VideoStatus video_status = 5;
     */
    videoStatus: CaptureStatus_VideoStatus; // Current status of video capturing
    /**
     * @generated from protobuf field: int32 image_count = 6;
     */
    imageCount: number; // Total number of images captured ('forever', or until reset using MAV_CMD_STORAGE_FORMAT)
}
/**
 * @generated from protobuf enum mavsdk.rpc.camera_server.CaptureStatus.ImageStatus
 */
export enum CaptureStatus_ImageStatus {
    /**
     * idle
     *
     * @generated from protobuf enum value: IMAGE_STATUS_IDLE = 0;
     */
    IDLE = 0,
    /**
     * capture in progress
     *
     * @generated from protobuf enum value: IMAGE_STATUS_CAPTURE_IN_PROGRESS = 1;
     */
    CAPTURE_IN_PROGRESS = 1,
    /**
     * interval set but idle
     *
     * @generated from protobuf enum value: IMAGE_STATUS_INTERVAL_IDLE = 2;
     */
    INTERVAL_IDLE = 2,
    /**
     * interval set and capture in progress)
     *
     * @generated from protobuf enum value: IMAGE_STATUS_INTERVAL_IN_PROGRESS = 3;
     */
    INTERVAL_IN_PROGRESS = 3
}
/**
 * @generated from protobuf enum mavsdk.rpc.camera_server.CaptureStatus.VideoStatus
 */
export enum CaptureStatus_VideoStatus {
    /**
     * idle
     *
     * @generated from protobuf enum value: VIDEO_STATUS_IDLE = 0;
     */
    IDLE = 0,
    /**
     * capture in progress
     *
     * @generated from protobuf enum value: VIDEO_STATUS_CAPTURE_IN_PROGRESS = 1;
     */
    CAPTURE_IN_PROGRESS = 1
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingPointStatusRequest
 */
export interface SetTrackingPointStatusRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.TrackPoint tracked_point = 1;
     */
    trackedPoint?: TrackPoint; // The tracked point
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingPointStatusResponse
 */
export interface SetTrackingPointStatusResponse {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest
 */
export interface SetTrackingRectangleStatusRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.TrackRectangle tracked_rectangle = 1;
     */
    trackedRectangle?: TrackRectangle; // The tracked rectangle
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse
 */
export interface SetTrackingRectangleStatusResponse {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingOffStatusRequest
 */
export interface SetTrackingOffStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SetTrackingOffStatusResponse
 */
export interface SetTrackingOffStatusResponse {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest
 */
export interface SubscribeTrackingPointCommandRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.TrackingPointCommandResponse
 */
export interface TrackingPointCommandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.TrackPoint track_point = 1;
     */
    trackPoint?: TrackPoint; // The point to track if a point is to be tracked
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest
 */
export interface SubscribeTrackingRectangleCommandRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.TrackingRectangleCommandResponse
 */
export interface TrackingRectangleCommandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.TrackRectangle track_rectangle = 1;
     */
    trackRectangle?: TrackRectangle; // The point to track if a point is to be tracked
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest
 */
export interface SubscribeTrackingOffCommandRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.TrackingOffCommandResponse
 */
export interface TrackingOffCommandResponse {
    /**
     * @generated from protobuf field: int32 dummy = 1;
     */
    dummy: number; // Unused
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest
 */
export interface RespondTrackingPointCommandRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
     */
    stopVideoFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse
 */
export interface RespondTrackingPointCommandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult; // The result of sending the response.
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest
 */
export interface RespondTrackingRectangleCommandRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
     */
    stopVideoFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse
 */
export interface RespondTrackingRectangleCommandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult; // The result of sending the response.
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest
 */
export interface RespondTrackingOffCommandRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1;
     */
    stopVideoFeedback: CameraFeedback; // the feedback
}
/**
 * @generated from protobuf message mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse
 */
export interface RespondTrackingOffCommandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1;
     */
    cameraServerResult?: CameraServerResult; // The result of sending the response.
}
/**
 * Point description type
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.TrackPoint
 */
export interface TrackPoint {
    /**
     * @generated from protobuf field: float point_x = 1;
     */
    pointX: number; // Point to track x value (normalized 0..1, 0 is left, 1 is right).
    /**
     * @generated from protobuf field: float point_y = 2;
     */
    pointY: number; // Point to track y value (normalized 0..1, 0 is top, 1 is bottom).
    /**
     * @generated from protobuf field: float radius = 3;
     */
    radius: number; // Point to track y value (normalized 0..1, 0 is top, 1 is bottom).
}
/**
 * Rectangle description type
 *
 * @generated from protobuf message mavsdk.rpc.camera_server.TrackRectangle
 */
export interface TrackRectangle {
    /**
     * @generated from protobuf field: float top_left_corner_x = 1;
     */
    topLeftCornerX: number; // Top left corner of rectangle x value (normalized 0..1, 0 is left, 1 is right).
    /**
     * @generated from protobuf field: float top_left_corner_y = 2;
     */
    topLeftCornerY: number; // Top left corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom).
    /**
     * @generated from protobuf field: float bottom_right_corner_x = 3;
     */
    bottomRightCornerX: number; // Bottom right corner of rectangle x value (normalized 0..1, 0 is left, 1 is right).
    /**
     * @generated from protobuf field: float bottom_right_corner_y = 4;
     */
    bottomRightCornerY: number; // Bottom right corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom).
}
/**
 * Possible feedback results for camera respond command.
 *
 * @generated from protobuf enum mavsdk.rpc.camera_server.CameraFeedback
 */
export enum CameraFeedback {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: CAMERA_FEEDBACK_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Ok
     *
     * @generated from protobuf enum value: CAMERA_FEEDBACK_OK = 1;
     */
    OK = 1,
    /**
     * Busy
     *
     * @generated from protobuf enum value: CAMERA_FEEDBACK_BUSY = 2;
     */
    BUSY = 2,
    /**
     * Failed
     *
     * @generated from protobuf enum value: CAMERA_FEEDBACK_FAILED = 3;
     */
    FAILED = 3
}
/**
 * Camera mode type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera_server.Mode
 */
export enum Mode {
    /**
     * Unknown mode
     *
     * @generated from protobuf enum value: MODE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Photo mode
     *
     * @generated from protobuf enum value: MODE_PHOTO = 1;
     */
    PHOTO = 1,
    /**
     * Video mode
     *
     * @generated from protobuf enum value: MODE_VIDEO = 2;
     */
    VIDEO = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SetInformationRequest$Type extends MessageType<SetInformationRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetInformationRequest", [
            { no: 1, name: "information", kind: "message", T: () => Information }
        ]);
    }
    create(value?: PartialMessage<SetInformationRequest>): SetInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetInformationRequest): SetInformationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.Information information */ 1:
                    message.information = Information.internalBinaryRead(reader, reader.uint32(), options, message.information);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.Information information = 1; */
        if (message.information)
            Information.internalBinaryWrite(message.information, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetInformationRequest
 */
export const SetInformationRequest = new SetInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetInformationResponse$Type extends MessageType<SetInformationResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetInformationResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<SetInformationResponse>): SetInformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetInformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetInformationResponse): SetInformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetInformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetInformationResponse
 */
export const SetInformationResponse = new SetInformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetVideoStreamingRequest$Type extends MessageType<SetVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetVideoStreamingRequest", [
            { no: 1, name: "video_streaming", kind: "message", T: () => VideoStreaming }
        ]);
    }
    create(value?: PartialMessage<SetVideoStreamingRequest>): SetVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetVideoStreamingRequest): SetVideoStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.VideoStreaming video_streaming */ 1:
                    message.videoStreaming = VideoStreaming.internalBinaryRead(reader, reader.uint32(), options, message.videoStreaming);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.VideoStreaming video_streaming = 1; */
        if (message.videoStreaming)
            VideoStreaming.internalBinaryWrite(message.videoStreaming, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetVideoStreamingRequest
 */
export const SetVideoStreamingRequest = new SetVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetVideoStreamingResponse$Type extends MessageType<SetVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetVideoStreamingResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<SetVideoStreamingResponse>): SetVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetVideoStreamingResponse): SetVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetVideoStreamingResponse
 */
export const SetVideoStreamingResponse = new SetVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetInProgressRequest$Type extends MessageType<SetInProgressRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetInProgressRequest", [
            { no: 1, name: "in_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetInProgressRequest>): SetInProgressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inProgress = false;
        if (value !== undefined)
            reflectionMergePartial<SetInProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetInProgressRequest): SetInProgressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool in_progress */ 1:
                    message.inProgress = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetInProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool in_progress = 1; */
        if (message.inProgress !== false)
            writer.tag(1, WireType.Varint).bool(message.inProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetInProgressRequest
 */
export const SetInProgressRequest = new SetInProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetInProgressResponse$Type extends MessageType<SetInProgressResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetInProgressResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<SetInProgressResponse>): SetInProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetInProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetInProgressResponse): SetInProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetInProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetInProgressResponse
 */
export const SetInProgressResponse = new SetInProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTakePhotoRequest$Type extends MessageType<SubscribeTakePhotoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeTakePhotoRequest", []);
    }
    create(value?: PartialMessage<SubscribeTakePhotoRequest>): SubscribeTakePhotoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTakePhotoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTakePhotoRequest): SubscribeTakePhotoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTakePhotoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeTakePhotoRequest
 */
export const SubscribeTakePhotoRequest = new SubscribeTakePhotoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakePhotoResponse$Type extends MessageType<TakePhotoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.TakePhotoResponse", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakePhotoResponse>): TakePhotoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        if (value !== undefined)
            reflectionMergePartial<TakePhotoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakePhotoResponse): TakePhotoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakePhotoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TakePhotoResponse
 */
export const TakePhotoResponse = new TakePhotoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTakePhotoRequest$Type extends MessageType<RespondTakePhotoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTakePhotoRequest", [
            { no: 1, name: "take_photo_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] },
            { no: 2, name: "capture_info", kind: "message", T: () => CaptureInfo }
        ]);
    }
    create(value?: PartialMessage<RespondTakePhotoRequest>): RespondTakePhotoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.takePhotoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondTakePhotoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTakePhotoRequest): RespondTakePhotoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback take_photo_feedback */ 1:
                    message.takePhotoFeedback = reader.int32();
                    break;
                case /* mavsdk.rpc.camera_server.CaptureInfo capture_info */ 2:
                    message.captureInfo = CaptureInfo.internalBinaryRead(reader, reader.uint32(), options, message.captureInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTakePhotoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback take_photo_feedback = 1; */
        if (message.takePhotoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.takePhotoFeedback);
        /* mavsdk.rpc.camera_server.CaptureInfo capture_info = 2; */
        if (message.captureInfo)
            CaptureInfo.internalBinaryWrite(message.captureInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTakePhotoRequest
 */
export const RespondTakePhotoRequest = new RespondTakePhotoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTakePhotoResponse$Type extends MessageType<RespondTakePhotoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTakePhotoResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondTakePhotoResponse>): RespondTakePhotoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondTakePhotoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTakePhotoResponse): RespondTakePhotoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTakePhotoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTakePhotoResponse
 */
export const RespondTakePhotoResponse = new RespondTakePhotoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStartVideoRequest$Type extends MessageType<SubscribeStartVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeStartVideoRequest", []);
    }
    create(value?: PartialMessage<SubscribeStartVideoRequest>): SubscribeStartVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStartVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStartVideoRequest): SubscribeStartVideoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStartVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeStartVideoRequest
 */
export const SubscribeStartVideoRequest = new SubscribeStartVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoResponse$Type extends MessageType<StartVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.StartVideoResponse", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartVideoResponse>): StartVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StartVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoResponse): StartVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StartVideoResponse
 */
export const StartVideoResponse = new StartVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStartVideoRequest$Type extends MessageType<RespondStartVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStartVideoRequest", [
            { no: 1, name: "start_video_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondStartVideoRequest>): RespondStartVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startVideoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondStartVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStartVideoRequest): RespondStartVideoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback start_video_feedback */ 1:
                    message.startVideoFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStartVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback start_video_feedback = 1; */
        if (message.startVideoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.startVideoFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStartVideoRequest
 */
export const RespondStartVideoRequest = new RespondStartVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStartVideoResponse$Type extends MessageType<RespondStartVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStartVideoResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondStartVideoResponse>): RespondStartVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondStartVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStartVideoResponse): RespondStartVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStartVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStartVideoResponse
 */
export const RespondStartVideoResponse = new RespondStartVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStopVideoRequest$Type extends MessageType<SubscribeStopVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeStopVideoRequest", []);
    }
    create(value?: PartialMessage<SubscribeStopVideoRequest>): SubscribeStopVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStopVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStopVideoRequest): SubscribeStopVideoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStopVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeStopVideoRequest
 */
export const SubscribeStopVideoRequest = new SubscribeStopVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoResponse$Type extends MessageType<StopVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.StopVideoResponse", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopVideoResponse>): StopVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StopVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoResponse): StopVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StopVideoResponse
 */
export const StopVideoResponse = new StopVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStopVideoRequest$Type extends MessageType<RespondStopVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStopVideoRequest", [
            { no: 1, name: "stop_video_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondStopVideoRequest>): RespondStopVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopVideoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondStopVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStopVideoRequest): RespondStopVideoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback */ 1:
                    message.stopVideoFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStopVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1; */
        if (message.stopVideoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.stopVideoFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStopVideoRequest
 */
export const RespondStopVideoRequest = new RespondStopVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStopVideoResponse$Type extends MessageType<RespondStopVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStopVideoResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondStopVideoResponse>): RespondStopVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondStopVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStopVideoResponse): RespondStopVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStopVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStopVideoResponse
 */
export const RespondStopVideoResponse = new RespondStopVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStartVideoStreamingRequest$Type extends MessageType<SubscribeStartVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest", []);
    }
    create(value?: PartialMessage<SubscribeStartVideoStreamingRequest>): SubscribeStartVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStartVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStartVideoStreamingRequest): SubscribeStartVideoStreamingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStartVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeStartVideoStreamingRequest
 */
export const SubscribeStartVideoStreamingRequest = new SubscribeStartVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoStreamingResponse$Type extends MessageType<StartVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.StartVideoStreamingResponse", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartVideoStreamingResponse>): StartVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StartVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoStreamingResponse): StartVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StartVideoStreamingResponse
 */
export const StartVideoStreamingResponse = new StartVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStartVideoStreamingRequest$Type extends MessageType<RespondStartVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest", [
            { no: 1, name: "start_video_streaming_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondStartVideoStreamingRequest>): RespondStartVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startVideoStreamingFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondStartVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStartVideoStreamingRequest): RespondStartVideoStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback start_video_streaming_feedback */ 1:
                    message.startVideoStreamingFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStartVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback start_video_streaming_feedback = 1; */
        if (message.startVideoStreamingFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.startVideoStreamingFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStartVideoStreamingRequest
 */
export const RespondStartVideoStreamingRequest = new RespondStartVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStartVideoStreamingResponse$Type extends MessageType<RespondStartVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondStartVideoStreamingResponse>): RespondStartVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondStartVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStartVideoStreamingResponse): RespondStartVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStartVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStartVideoStreamingResponse
 */
export const RespondStartVideoStreamingResponse = new RespondStartVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStopVideoStreamingRequest$Type extends MessageType<SubscribeStopVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest", []);
    }
    create(value?: PartialMessage<SubscribeStopVideoStreamingRequest>): SubscribeStopVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStopVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStopVideoStreamingRequest): SubscribeStopVideoStreamingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStopVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeStopVideoStreamingRequest
 */
export const SubscribeStopVideoStreamingRequest = new SubscribeStopVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoStreamingResponse$Type extends MessageType<StopVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.StopVideoStreamingResponse", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopVideoStreamingResponse>): StopVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StopVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoStreamingResponse): StopVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StopVideoStreamingResponse
 */
export const StopVideoStreamingResponse = new StopVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStopVideoStreamingRequest$Type extends MessageType<RespondStopVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest", [
            { no: 1, name: "stop_video_streaming_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondStopVideoStreamingRequest>): RespondStopVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopVideoStreamingFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondStopVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStopVideoStreamingRequest): RespondStopVideoStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback stop_video_streaming_feedback */ 1:
                    message.stopVideoStreamingFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStopVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback stop_video_streaming_feedback = 1; */
        if (message.stopVideoStreamingFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.stopVideoStreamingFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStopVideoStreamingRequest
 */
export const RespondStopVideoStreamingRequest = new RespondStopVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStopVideoStreamingResponse$Type extends MessageType<RespondStopVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondStopVideoStreamingResponse>): RespondStopVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondStopVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStopVideoStreamingResponse): RespondStopVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStopVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStopVideoStreamingResponse
 */
export const RespondStopVideoStreamingResponse = new RespondStopVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeSetModeRequest$Type extends MessageType<SubscribeSetModeRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeSetModeRequest", []);
    }
    create(value?: PartialMessage<SubscribeSetModeRequest>): SubscribeSetModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeSetModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeSetModeRequest): SubscribeSetModeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeSetModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeSetModeRequest
 */
export const SubscribeSetModeRequest = new SubscribeSetModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetModeResponse$Type extends MessageType<SetModeResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetModeResponse", [
            { no: 1, name: "mode", kind: "enum", T: () => ["mavsdk.rpc.camera_server.Mode", Mode, "MODE_"] }
        ]);
    }
    create(value?: PartialMessage<SetModeResponse>): SetModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<SetModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetModeResponse): SetModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.Mode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.Mode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetModeResponse
 */
export const SetModeResponse = new SetModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondSetModeRequest$Type extends MessageType<RespondSetModeRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondSetModeRequest", [
            { no: 1, name: "set_mode_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondSetModeRequest>): RespondSetModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setModeFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondSetModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondSetModeRequest): RespondSetModeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback set_mode_feedback */ 1:
                    message.setModeFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondSetModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback set_mode_feedback = 1; */
        if (message.setModeFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.setModeFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondSetModeRequest
 */
export const RespondSetModeRequest = new RespondSetModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondSetModeResponse$Type extends MessageType<RespondSetModeResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondSetModeResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondSetModeResponse>): RespondSetModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondSetModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondSetModeResponse): RespondSetModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondSetModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondSetModeResponse
 */
export const RespondSetModeResponse = new RespondSetModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStorageInformationRequest$Type extends MessageType<SubscribeStorageInformationRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeStorageInformationRequest", []);
    }
    create(value?: PartialMessage<SubscribeStorageInformationRequest>): SubscribeStorageInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStorageInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStorageInformationRequest): SubscribeStorageInformationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStorageInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeStorageInformationRequest
 */
export const SubscribeStorageInformationRequest = new SubscribeStorageInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageInformationResponse$Type extends MessageType<StorageInformationResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.StorageInformationResponse", [
            { no: 1, name: "storage_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StorageInformationResponse>): StorageInformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storageId = 0;
        if (value !== undefined)
            reflectionMergePartial<StorageInformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageInformationResponse): StorageInformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 storage_id */ 1:
                    message.storageId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageInformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 storage_id = 1; */
        if (message.storageId !== 0)
            writer.tag(1, WireType.Varint).int32(message.storageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StorageInformationResponse
 */
export const StorageInformationResponse = new StorageInformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStorageInformationRequest$Type extends MessageType<RespondStorageInformationRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStorageInformationRequest", [
            { no: 1, name: "storage_information_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] },
            { no: 2, name: "storage_information", kind: "message", T: () => StorageInformation }
        ]);
    }
    create(value?: PartialMessage<RespondStorageInformationRequest>): RespondStorageInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storageInformationFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondStorageInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStorageInformationRequest): RespondStorageInformationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback storage_information_feedback */ 1:
                    message.storageInformationFeedback = reader.int32();
                    break;
                case /* mavsdk.rpc.camera_server.StorageInformation storage_information */ 2:
                    message.storageInformation = StorageInformation.internalBinaryRead(reader, reader.uint32(), options, message.storageInformation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStorageInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback storage_information_feedback = 1; */
        if (message.storageInformationFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.storageInformationFeedback);
        /* mavsdk.rpc.camera_server.StorageInformation storage_information = 2; */
        if (message.storageInformation)
            StorageInformation.internalBinaryWrite(message.storageInformation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStorageInformationRequest
 */
export const RespondStorageInformationRequest = new RespondStorageInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondStorageInformationResponse$Type extends MessageType<RespondStorageInformationResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondStorageInformationResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondStorageInformationResponse>): RespondStorageInformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondStorageInformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondStorageInformationResponse): RespondStorageInformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondStorageInformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondStorageInformationResponse
 */
export const RespondStorageInformationResponse = new RespondStorageInformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCaptureStatusRequest$Type extends MessageType<SubscribeCaptureStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeCaptureStatusRequest>): SubscribeCaptureStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeCaptureStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCaptureStatusRequest): SubscribeCaptureStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeCaptureStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeCaptureStatusRequest
 */
export const SubscribeCaptureStatusRequest = new SubscribeCaptureStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureStatusResponse$Type extends MessageType<CaptureStatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.CaptureStatusResponse", [
            { no: 1, name: "reserved", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CaptureStatusResponse>): CaptureStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reserved = 0;
        if (value !== undefined)
            reflectionMergePartial<CaptureStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureStatusResponse): CaptureStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 reserved */ 1:
                    message.reserved = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 reserved = 1; */
        if (message.reserved !== 0)
            writer.tag(1, WireType.Varint).int32(message.reserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.CaptureStatusResponse
 */
export const CaptureStatusResponse = new CaptureStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondCaptureStatusRequest$Type extends MessageType<RespondCaptureStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondCaptureStatusRequest", [
            { no: 1, name: "capture_status_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] },
            { no: 2, name: "capture_status", kind: "message", T: () => CaptureStatus }
        ]);
    }
    create(value?: PartialMessage<RespondCaptureStatusRequest>): RespondCaptureStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.captureStatusFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondCaptureStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondCaptureStatusRequest): RespondCaptureStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback capture_status_feedback */ 1:
                    message.captureStatusFeedback = reader.int32();
                    break;
                case /* mavsdk.rpc.camera_server.CaptureStatus capture_status */ 2:
                    message.captureStatus = CaptureStatus.internalBinaryRead(reader, reader.uint32(), options, message.captureStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondCaptureStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback capture_status_feedback = 1; */
        if (message.captureStatusFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.captureStatusFeedback);
        /* mavsdk.rpc.camera_server.CaptureStatus capture_status = 2; */
        if (message.captureStatus)
            CaptureStatus.internalBinaryWrite(message.captureStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondCaptureStatusRequest
 */
export const RespondCaptureStatusRequest = new RespondCaptureStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondCaptureStatusResponse$Type extends MessageType<RespondCaptureStatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondCaptureStatusResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondCaptureStatusResponse>): RespondCaptureStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondCaptureStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondCaptureStatusResponse): RespondCaptureStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondCaptureStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondCaptureStatusResponse
 */
export const RespondCaptureStatusResponse = new RespondCaptureStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFormatStorageRequest$Type extends MessageType<SubscribeFormatStorageRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeFormatStorageRequest", []);
    }
    create(value?: PartialMessage<SubscribeFormatStorageRequest>): SubscribeFormatStorageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeFormatStorageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFormatStorageRequest): SubscribeFormatStorageRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeFormatStorageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeFormatStorageRequest
 */
export const SubscribeFormatStorageRequest = new SubscribeFormatStorageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormatStorageResponse$Type extends MessageType<FormatStorageResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.FormatStorageResponse", [
            { no: 1, name: "storage_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FormatStorageResponse>): FormatStorageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storageId = 0;
        if (value !== undefined)
            reflectionMergePartial<FormatStorageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormatStorageResponse): FormatStorageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 storage_id */ 1:
                    message.storageId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormatStorageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 storage_id = 1; */
        if (message.storageId !== 0)
            writer.tag(1, WireType.Varint).int32(message.storageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.FormatStorageResponse
 */
export const FormatStorageResponse = new FormatStorageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondFormatStorageRequest$Type extends MessageType<RespondFormatStorageRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondFormatStorageRequest", [
            { no: 1, name: "format_storage_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondFormatStorageRequest>): RespondFormatStorageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.formatStorageFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondFormatStorageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondFormatStorageRequest): RespondFormatStorageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback format_storage_feedback */ 1:
                    message.formatStorageFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondFormatStorageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback format_storage_feedback = 1; */
        if (message.formatStorageFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.formatStorageFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondFormatStorageRequest
 */
export const RespondFormatStorageRequest = new RespondFormatStorageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondFormatStorageResponse$Type extends MessageType<RespondFormatStorageResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondFormatStorageResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondFormatStorageResponse>): RespondFormatStorageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondFormatStorageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondFormatStorageResponse): RespondFormatStorageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondFormatStorageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondFormatStorageResponse
 */
export const RespondFormatStorageResponse = new RespondFormatStorageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeResetSettingsRequest$Type extends MessageType<SubscribeResetSettingsRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeResetSettingsRequest", []);
    }
    create(value?: PartialMessage<SubscribeResetSettingsRequest>): SubscribeResetSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeResetSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeResetSettingsRequest): SubscribeResetSettingsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeResetSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeResetSettingsRequest
 */
export const SubscribeResetSettingsRequest = new SubscribeResetSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetSettingsResponse$Type extends MessageType<ResetSettingsResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.ResetSettingsResponse", [
            { no: 1, name: "reserved", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResetSettingsResponse>): ResetSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reserved = 0;
        if (value !== undefined)
            reflectionMergePartial<ResetSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetSettingsResponse): ResetSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 reserved */ 1:
                    message.reserved = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 reserved = 1; */
        if (message.reserved !== 0)
            writer.tag(1, WireType.Varint).int32(message.reserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.ResetSettingsResponse
 */
export const ResetSettingsResponse = new ResetSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondResetSettingsRequest$Type extends MessageType<RespondResetSettingsRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondResetSettingsRequest", [
            { no: 1, name: "reset_settings_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondResetSettingsRequest>): RespondResetSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resetSettingsFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondResetSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondResetSettingsRequest): RespondResetSettingsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback reset_settings_feedback */ 1:
                    message.resetSettingsFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondResetSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback reset_settings_feedback = 1; */
        if (message.resetSettingsFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.resetSettingsFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondResetSettingsRequest
 */
export const RespondResetSettingsRequest = new RespondResetSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondResetSettingsResponse$Type extends MessageType<RespondResetSettingsResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondResetSettingsResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondResetSettingsResponse>): RespondResetSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondResetSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondResetSettingsResponse): RespondResetSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondResetSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondResetSettingsResponse
 */
export const RespondResetSettingsResponse = new RespondResetSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeZoomInStartRequest$Type extends MessageType<SubscribeZoomInStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeZoomInStartRequest", []);
    }
    create(value?: PartialMessage<SubscribeZoomInStartRequest>): SubscribeZoomInStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeZoomInStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeZoomInStartRequest): SubscribeZoomInStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeZoomInStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeZoomInStartRequest
 */
export const SubscribeZoomInStartRequest = new SubscribeZoomInStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomInStartResponse$Type extends MessageType<ZoomInStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.ZoomInStartResponse", [
            { no: 1, name: "reserved", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZoomInStartResponse>): ZoomInStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reserved = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoomInStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomInStartResponse): ZoomInStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 reserved */ 1:
                    message.reserved = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomInStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 reserved = 1; */
        if (message.reserved !== 0)
            writer.tag(1, WireType.Varint).int32(message.reserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.ZoomInStartResponse
 */
export const ZoomInStartResponse = new ZoomInStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomInStartRequest$Type extends MessageType<RespondZoomInStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomInStartRequest", [
            { no: 1, name: "zoom_in_start_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondZoomInStartRequest>): RespondZoomInStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoomInStartFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondZoomInStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomInStartRequest): RespondZoomInStartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback zoom_in_start_feedback */ 1:
                    message.zoomInStartFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomInStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback zoom_in_start_feedback = 1; */
        if (message.zoomInStartFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoomInStartFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomInStartRequest
 */
export const RespondZoomInStartRequest = new RespondZoomInStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomInStartResponse$Type extends MessageType<RespondZoomInStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomInStartResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondZoomInStartResponse>): RespondZoomInStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondZoomInStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomInStartResponse): RespondZoomInStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomInStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomInStartResponse
 */
export const RespondZoomInStartResponse = new RespondZoomInStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeZoomOutStartRequest$Type extends MessageType<SubscribeZoomOutStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest", []);
    }
    create(value?: PartialMessage<SubscribeZoomOutStartRequest>): SubscribeZoomOutStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeZoomOutStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeZoomOutStartRequest): SubscribeZoomOutStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeZoomOutStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeZoomOutStartRequest
 */
export const SubscribeZoomOutStartRequest = new SubscribeZoomOutStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomOutStartResponse$Type extends MessageType<ZoomOutStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.ZoomOutStartResponse", [
            { no: 1, name: "reserved", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZoomOutStartResponse>): ZoomOutStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reserved = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoomOutStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomOutStartResponse): ZoomOutStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 reserved */ 1:
                    message.reserved = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomOutStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 reserved = 1; */
        if (message.reserved !== 0)
            writer.tag(1, WireType.Varint).int32(message.reserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.ZoomOutStartResponse
 */
export const ZoomOutStartResponse = new ZoomOutStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomOutStartRequest$Type extends MessageType<RespondZoomOutStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomOutStartRequest", [
            { no: 1, name: "zoom_out_start_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondZoomOutStartRequest>): RespondZoomOutStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoomOutStartFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondZoomOutStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomOutStartRequest): RespondZoomOutStartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback zoom_out_start_feedback */ 1:
                    message.zoomOutStartFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomOutStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback zoom_out_start_feedback = 1; */
        if (message.zoomOutStartFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoomOutStartFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomOutStartRequest
 */
export const RespondZoomOutStartRequest = new RespondZoomOutStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomOutStartResponse$Type extends MessageType<RespondZoomOutStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomOutStartResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondZoomOutStartResponse>): RespondZoomOutStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondZoomOutStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomOutStartResponse): RespondZoomOutStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomOutStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomOutStartResponse
 */
export const RespondZoomOutStartResponse = new RespondZoomOutStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeZoomStopRequest$Type extends MessageType<SubscribeZoomStopRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeZoomStopRequest", []);
    }
    create(value?: PartialMessage<SubscribeZoomStopRequest>): SubscribeZoomStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeZoomStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeZoomStopRequest): SubscribeZoomStopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeZoomStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeZoomStopRequest
 */
export const SubscribeZoomStopRequest = new SubscribeZoomStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomStopResponse$Type extends MessageType<ZoomStopResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.ZoomStopResponse", [
            { no: 1, name: "reserved", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ZoomStopResponse>): ZoomStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reserved = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoomStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomStopResponse): ZoomStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 reserved */ 1:
                    message.reserved = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 reserved = 1; */
        if (message.reserved !== 0)
            writer.tag(1, WireType.Varint).int32(message.reserved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.ZoomStopResponse
 */
export const ZoomStopResponse = new ZoomStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomStopRequest$Type extends MessageType<RespondZoomStopRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomStopRequest", [
            { no: 1, name: "zoom_stop_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondZoomStopRequest>): RespondZoomStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoomStopFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondZoomStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomStopRequest): RespondZoomStopRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback zoom_stop_feedback */ 1:
                    message.zoomStopFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback zoom_stop_feedback = 1; */
        if (message.zoomStopFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoomStopFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomStopRequest
 */
export const RespondZoomStopRequest = new RespondZoomStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomStopResponse$Type extends MessageType<RespondZoomStopResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomStopResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondZoomStopResponse>): RespondZoomStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondZoomStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomStopResponse): RespondZoomStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomStopResponse
 */
export const RespondZoomStopResponse = new RespondZoomStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeZoomRangeRequest$Type extends MessageType<SubscribeZoomRangeRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeZoomRangeRequest", []);
    }
    create(value?: PartialMessage<SubscribeZoomRangeRequest>): SubscribeZoomRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeZoomRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeZoomRangeRequest): SubscribeZoomRangeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeZoomRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeZoomRangeRequest
 */
export const SubscribeZoomRangeRequest = new SubscribeZoomRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomRangeResponse$Type extends MessageType<ZoomRangeResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.ZoomRangeResponse", [
            { no: 1, name: "factor", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ZoomRangeResponse>): ZoomRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.factor = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoomRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomRangeResponse): ZoomRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float factor */ 1:
                    message.factor = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float factor = 1; */
        if (message.factor !== 0)
            writer.tag(1, WireType.Bit32).float(message.factor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.ZoomRangeResponse
 */
export const ZoomRangeResponse = new ZoomRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomRangeRequest$Type extends MessageType<RespondZoomRangeRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomRangeRequest", [
            { no: 1, name: "zoom_range_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondZoomRangeRequest>): RespondZoomRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoomRangeFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondZoomRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomRangeRequest): RespondZoomRangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback zoom_range_feedback */ 1:
                    message.zoomRangeFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback zoom_range_feedback = 1; */
        if (message.zoomRangeFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.zoomRangeFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomRangeRequest
 */
export const RespondZoomRangeRequest = new RespondZoomRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondZoomRangeResponse$Type extends MessageType<RespondZoomRangeResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondZoomRangeResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondZoomRangeResponse>): RespondZoomRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondZoomRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondZoomRangeResponse): RespondZoomRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondZoomRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondZoomRangeResponse
 */
export const RespondZoomRangeResponse = new RespondZoomRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Information$Type extends MessageType<Information> {
    constructor() {
        super("mavsdk.rpc.camera_server.Information", [
            { no: 1, name: "vendor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "model_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "firmware_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "focal_length_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "horizontal_sensor_size_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "vertical_sensor_size_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "horizontal_resolution_px", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "vertical_resolution_px", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "lens_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "definition_file_version", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "definition_file_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "image_in_video_mode_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "video_in_image_mode_supported", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Information>): Information {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vendorName = "";
        message.modelName = "";
        message.firmwareVersion = "";
        message.focalLengthMm = 0;
        message.horizontalSensorSizeMm = 0;
        message.verticalSensorSizeMm = 0;
        message.horizontalResolutionPx = 0;
        message.verticalResolutionPx = 0;
        message.lensId = 0;
        message.definitionFileVersion = 0;
        message.definitionFileUri = "";
        message.imageInVideoModeSupported = false;
        message.videoInImageModeSupported = false;
        if (value !== undefined)
            reflectionMergePartial<Information>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Information): Information {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vendor_name */ 1:
                    message.vendorName = reader.string();
                    break;
                case /* string model_name */ 2:
                    message.modelName = reader.string();
                    break;
                case /* string firmware_version */ 3:
                    message.firmwareVersion = reader.string();
                    break;
                case /* float focal_length_mm */ 4:
                    message.focalLengthMm = reader.float();
                    break;
                case /* float horizontal_sensor_size_mm */ 5:
                    message.horizontalSensorSizeMm = reader.float();
                    break;
                case /* float vertical_sensor_size_mm */ 6:
                    message.verticalSensorSizeMm = reader.float();
                    break;
                case /* uint32 horizontal_resolution_px */ 7:
                    message.horizontalResolutionPx = reader.uint32();
                    break;
                case /* uint32 vertical_resolution_px */ 8:
                    message.verticalResolutionPx = reader.uint32();
                    break;
                case /* uint32 lens_id */ 9:
                    message.lensId = reader.uint32();
                    break;
                case /* uint32 definition_file_version */ 10:
                    message.definitionFileVersion = reader.uint32();
                    break;
                case /* string definition_file_uri */ 11:
                    message.definitionFileUri = reader.string();
                    break;
                case /* bool image_in_video_mode_supported */ 12:
                    message.imageInVideoModeSupported = reader.bool();
                    break;
                case /* bool video_in_image_mode_supported */ 13:
                    message.videoInImageModeSupported = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Information, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vendor_name = 1; */
        if (message.vendorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vendorName);
        /* string model_name = 2; */
        if (message.modelName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modelName);
        /* string firmware_version = 3; */
        if (message.firmwareVersion !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.firmwareVersion);
        /* float focal_length_mm = 4; */
        if (message.focalLengthMm !== 0)
            writer.tag(4, WireType.Bit32).float(message.focalLengthMm);
        /* float horizontal_sensor_size_mm = 5; */
        if (message.horizontalSensorSizeMm !== 0)
            writer.tag(5, WireType.Bit32).float(message.horizontalSensorSizeMm);
        /* float vertical_sensor_size_mm = 6; */
        if (message.verticalSensorSizeMm !== 0)
            writer.tag(6, WireType.Bit32).float(message.verticalSensorSizeMm);
        /* uint32 horizontal_resolution_px = 7; */
        if (message.horizontalResolutionPx !== 0)
            writer.tag(7, WireType.Varint).uint32(message.horizontalResolutionPx);
        /* uint32 vertical_resolution_px = 8; */
        if (message.verticalResolutionPx !== 0)
            writer.tag(8, WireType.Varint).uint32(message.verticalResolutionPx);
        /* uint32 lens_id = 9; */
        if (message.lensId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.lensId);
        /* uint32 definition_file_version = 10; */
        if (message.definitionFileVersion !== 0)
            writer.tag(10, WireType.Varint).uint32(message.definitionFileVersion);
        /* string definition_file_uri = 11; */
        if (message.definitionFileUri !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.definitionFileUri);
        /* bool image_in_video_mode_supported = 12; */
        if (message.imageInVideoModeSupported !== false)
            writer.tag(12, WireType.Varint).bool(message.imageInVideoModeSupported);
        /* bool video_in_image_mode_supported = 13; */
        if (message.videoInImageModeSupported !== false)
            writer.tag(13, WireType.Varint).bool(message.videoInImageModeSupported);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.Information
 */
export const Information = new Information$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreaming$Type extends MessageType<VideoStreaming> {
    constructor() {
        super("mavsdk.rpc.camera_server.VideoStreaming", [
            { no: 1, name: "has_rtsp_server", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "rtsp_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VideoStreaming>): VideoStreaming {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasRtspServer = false;
        message.rtspUri = "";
        if (value !== undefined)
            reflectionMergePartial<VideoStreaming>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreaming): VideoStreaming {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_rtsp_server */ 1:
                    message.hasRtspServer = reader.bool();
                    break;
                case /* string rtsp_uri */ 2:
                    message.rtspUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreaming, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_rtsp_server = 1; */
        if (message.hasRtspServer !== false)
            writer.tag(1, WireType.Varint).bool(message.hasRtspServer);
        /* string rtsp_uri = 2; */
        if (message.rtspUri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rtspUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.VideoStreaming
 */
export const VideoStreaming = new VideoStreaming$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("mavsdk.rpc.camera_server.Position", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "relative_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.relativeAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float relative_altitude_m */ 4:
                    message.relativeAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float relative_altitude_m = 4; */
        if (message.relativeAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.relativeAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.camera_server.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureInfo$Type extends MessageType<CaptureInfo> {
    constructor() {
        super("mavsdk.rpc.camera_server.CaptureInfo", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "attitude_quaternion", kind: "message", T: () => Quaternion },
            { no: 3, name: "time_utc_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "file_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CaptureInfo>): CaptureInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUtcUs = 0n;
        message.isSuccess = false;
        message.index = 0;
        message.fileUrl = "";
        if (value !== undefined)
            reflectionMergePartial<CaptureInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureInfo): CaptureInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* mavsdk.rpc.camera_server.Quaternion attitude_quaternion */ 2:
                    message.attitudeQuaternion = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.attitudeQuaternion);
                    break;
                case /* uint64 time_utc_us */ 3:
                    message.timeUtcUs = reader.uint64().toBigInt();
                    break;
                case /* bool is_success */ 4:
                    message.isSuccess = reader.bool();
                    break;
                case /* int32 index */ 5:
                    message.index = reader.int32();
                    break;
                case /* string file_url */ 6:
                    message.fileUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.camera_server.Quaternion attitude_quaternion = 2; */
        if (message.attitudeQuaternion)
            Quaternion.internalBinaryWrite(message.attitudeQuaternion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 time_utc_us = 3; */
        if (message.timeUtcUs !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.timeUtcUs);
        /* bool is_success = 4; */
        if (message.isSuccess !== false)
            writer.tag(4, WireType.Varint).bool(message.isSuccess);
        /* int32 index = 5; */
        if (message.index !== 0)
            writer.tag(5, WireType.Varint).int32(message.index);
        /* string file_url = 6; */
        if (message.fileUrl !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fileUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.CaptureInfo
 */
export const CaptureInfo = new CaptureInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraServerResult$Type extends MessageType<CameraServerResult> {
    constructor() {
        super("mavsdk.rpc.camera_server.CameraServerResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraServerResult.Result", CameraServerResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CameraServerResult>): CameraServerResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<CameraServerResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraServerResult): CameraServerResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraServerResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.CameraServerResult
 */
export const CameraServerResult = new CameraServerResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageInformation$Type extends MessageType<StorageInformation> {
    constructor() {
        super("mavsdk.rpc.camera_server.StorageInformation", [
            { no: 1, name: "used_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "available_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "total_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "storage_status", kind: "enum", T: () => ["mavsdk.rpc.camera_server.StorageInformation.StorageStatus", StorageInformation_StorageStatus, "STORAGE_STATUS_"] },
            { no: 5, name: "storage_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "storage_type", kind: "enum", T: () => ["mavsdk.rpc.camera_server.StorageInformation.StorageType", StorageInformation_StorageType, "STORAGE_TYPE_"] },
            { no: 7, name: "read_speed_mib_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "write_speed_mib_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StorageInformation>): StorageInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.usedStorageMib = 0;
        message.availableStorageMib = 0;
        message.totalStorageMib = 0;
        message.storageStatus = 0;
        message.storageId = 0;
        message.storageType = 0;
        message.readSpeedMibS = 0;
        message.writeSpeedMibS = 0;
        if (value !== undefined)
            reflectionMergePartial<StorageInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StorageInformation): StorageInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float used_storage_mib */ 1:
                    message.usedStorageMib = reader.float();
                    break;
                case /* float available_storage_mib */ 2:
                    message.availableStorageMib = reader.float();
                    break;
                case /* float total_storage_mib */ 3:
                    message.totalStorageMib = reader.float();
                    break;
                case /* mavsdk.rpc.camera_server.StorageInformation.StorageStatus storage_status */ 4:
                    message.storageStatus = reader.int32();
                    break;
                case /* uint32 storage_id */ 5:
                    message.storageId = reader.uint32();
                    break;
                case /* mavsdk.rpc.camera_server.StorageInformation.StorageType storage_type */ 6:
                    message.storageType = reader.int32();
                    break;
                case /* float read_speed_mib_s */ 7:
                    message.readSpeedMibS = reader.float();
                    break;
                case /* float write_speed_mib_s */ 8:
                    message.writeSpeedMibS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StorageInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float used_storage_mib = 1; */
        if (message.usedStorageMib !== 0)
            writer.tag(1, WireType.Bit32).float(message.usedStorageMib);
        /* float available_storage_mib = 2; */
        if (message.availableStorageMib !== 0)
            writer.tag(2, WireType.Bit32).float(message.availableStorageMib);
        /* float total_storage_mib = 3; */
        if (message.totalStorageMib !== 0)
            writer.tag(3, WireType.Bit32).float(message.totalStorageMib);
        /* mavsdk.rpc.camera_server.StorageInformation.StorageStatus storage_status = 4; */
        if (message.storageStatus !== 0)
            writer.tag(4, WireType.Varint).int32(message.storageStatus);
        /* uint32 storage_id = 5; */
        if (message.storageId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.storageId);
        /* mavsdk.rpc.camera_server.StorageInformation.StorageType storage_type = 6; */
        if (message.storageType !== 0)
            writer.tag(6, WireType.Varint).int32(message.storageType);
        /* float read_speed_mib_s = 7; */
        if (message.readSpeedMibS !== 0)
            writer.tag(7, WireType.Bit32).float(message.readSpeedMibS);
        /* float write_speed_mib_s = 8; */
        if (message.writeSpeedMibS !== 0)
            writer.tag(8, WireType.Bit32).float(message.writeSpeedMibS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.StorageInformation
 */
export const StorageInformation = new StorageInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureStatus$Type extends MessageType<CaptureStatus> {
    constructor() {
        super("mavsdk.rpc.camera_server.CaptureStatus", [
            { no: 1, name: "image_interval_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "recording_time_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "available_capacity_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "image_status", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CaptureStatus.ImageStatus", CaptureStatus_ImageStatus, "IMAGE_STATUS_"] },
            { no: 5, name: "video_status", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CaptureStatus.VideoStatus", CaptureStatus_VideoStatus, "VIDEO_STATUS_"] },
            { no: 6, name: "image_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CaptureStatus>): CaptureStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imageIntervalS = 0;
        message.recordingTimeS = 0;
        message.availableCapacityMib = 0;
        message.imageStatus = 0;
        message.videoStatus = 0;
        message.imageCount = 0;
        if (value !== undefined)
            reflectionMergePartial<CaptureStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureStatus): CaptureStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float image_interval_s */ 1:
                    message.imageIntervalS = reader.float();
                    break;
                case /* float recording_time_s */ 2:
                    message.recordingTimeS = reader.float();
                    break;
                case /* float available_capacity_mib */ 3:
                    message.availableCapacityMib = reader.float();
                    break;
                case /* mavsdk.rpc.camera_server.CaptureStatus.ImageStatus image_status */ 4:
                    message.imageStatus = reader.int32();
                    break;
                case /* mavsdk.rpc.camera_server.CaptureStatus.VideoStatus video_status */ 5:
                    message.videoStatus = reader.int32();
                    break;
                case /* int32 image_count */ 6:
                    message.imageCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float image_interval_s = 1; */
        if (message.imageIntervalS !== 0)
            writer.tag(1, WireType.Bit32).float(message.imageIntervalS);
        /* float recording_time_s = 2; */
        if (message.recordingTimeS !== 0)
            writer.tag(2, WireType.Bit32).float(message.recordingTimeS);
        /* float available_capacity_mib = 3; */
        if (message.availableCapacityMib !== 0)
            writer.tag(3, WireType.Bit32).float(message.availableCapacityMib);
        /* mavsdk.rpc.camera_server.CaptureStatus.ImageStatus image_status = 4; */
        if (message.imageStatus !== 0)
            writer.tag(4, WireType.Varint).int32(message.imageStatus);
        /* mavsdk.rpc.camera_server.CaptureStatus.VideoStatus video_status = 5; */
        if (message.videoStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.videoStatus);
        /* int32 image_count = 6; */
        if (message.imageCount !== 0)
            writer.tag(6, WireType.Varint).int32(message.imageCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.CaptureStatus
 */
export const CaptureStatus = new CaptureStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingPointStatusRequest$Type extends MessageType<SetTrackingPointStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingPointStatusRequest", [
            { no: 1, name: "tracked_point", kind: "message", T: () => TrackPoint }
        ]);
    }
    create(value?: PartialMessage<SetTrackingPointStatusRequest>): SetTrackingPointStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingPointStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingPointStatusRequest): SetTrackingPointStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.TrackPoint tracked_point */ 1:
                    message.trackedPoint = TrackPoint.internalBinaryRead(reader, reader.uint32(), options, message.trackedPoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTrackingPointStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.TrackPoint tracked_point = 1; */
        if (message.trackedPoint)
            TrackPoint.internalBinaryWrite(message.trackedPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingPointStatusRequest
 */
export const SetTrackingPointStatusRequest = new SetTrackingPointStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingPointStatusResponse$Type extends MessageType<SetTrackingPointStatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingPointStatusResponse", []);
    }
    create(value?: PartialMessage<SetTrackingPointStatusResponse>): SetTrackingPointStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingPointStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingPointStatusResponse): SetTrackingPointStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetTrackingPointStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingPointStatusResponse
 */
export const SetTrackingPointStatusResponse = new SetTrackingPointStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingRectangleStatusRequest$Type extends MessageType<SetTrackingRectangleStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest", [
            { no: 1, name: "tracked_rectangle", kind: "message", T: () => TrackRectangle }
        ]);
    }
    create(value?: PartialMessage<SetTrackingRectangleStatusRequest>): SetTrackingRectangleStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingRectangleStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingRectangleStatusRequest): SetTrackingRectangleStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.TrackRectangle tracked_rectangle */ 1:
                    message.trackedRectangle = TrackRectangle.internalBinaryRead(reader, reader.uint32(), options, message.trackedRectangle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTrackingRectangleStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.TrackRectangle tracked_rectangle = 1; */
        if (message.trackedRectangle)
            TrackRectangle.internalBinaryWrite(message.trackedRectangle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingRectangleStatusRequest
 */
export const SetTrackingRectangleStatusRequest = new SetTrackingRectangleStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingRectangleStatusResponse$Type extends MessageType<SetTrackingRectangleStatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse", []);
    }
    create(value?: PartialMessage<SetTrackingRectangleStatusResponse>): SetTrackingRectangleStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingRectangleStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingRectangleStatusResponse): SetTrackingRectangleStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetTrackingRectangleStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingRectangleStatusResponse
 */
export const SetTrackingRectangleStatusResponse = new SetTrackingRectangleStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingOffStatusRequest$Type extends MessageType<SetTrackingOffStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingOffStatusRequest", []);
    }
    create(value?: PartialMessage<SetTrackingOffStatusRequest>): SetTrackingOffStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingOffStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingOffStatusRequest): SetTrackingOffStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetTrackingOffStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingOffStatusRequest
 */
export const SetTrackingOffStatusRequest = new SetTrackingOffStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTrackingOffStatusResponse$Type extends MessageType<SetTrackingOffStatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.SetTrackingOffStatusResponse", []);
    }
    create(value?: PartialMessage<SetTrackingOffStatusResponse>): SetTrackingOffStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTrackingOffStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTrackingOffStatusResponse): SetTrackingOffStatusResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetTrackingOffStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SetTrackingOffStatusResponse
 */
export const SetTrackingOffStatusResponse = new SetTrackingOffStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTrackingPointCommandRequest$Type extends MessageType<SubscribeTrackingPointCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest", []);
    }
    create(value?: PartialMessage<SubscribeTrackingPointCommandRequest>): SubscribeTrackingPointCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTrackingPointCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTrackingPointCommandRequest): SubscribeTrackingPointCommandRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTrackingPointCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeTrackingPointCommandRequest
 */
export const SubscribeTrackingPointCommandRequest = new SubscribeTrackingPointCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackingPointCommandResponse$Type extends MessageType<TrackingPointCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.TrackingPointCommandResponse", [
            { no: 1, name: "track_point", kind: "message", T: () => TrackPoint }
        ]);
    }
    create(value?: PartialMessage<TrackingPointCommandResponse>): TrackingPointCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackingPointCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackingPointCommandResponse): TrackingPointCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.TrackPoint track_point */ 1:
                    message.trackPoint = TrackPoint.internalBinaryRead(reader, reader.uint32(), options, message.trackPoint);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackingPointCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.TrackPoint track_point = 1; */
        if (message.trackPoint)
            TrackPoint.internalBinaryWrite(message.trackPoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TrackingPointCommandResponse
 */
export const TrackingPointCommandResponse = new TrackingPointCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTrackingRectangleCommandRequest$Type extends MessageType<SubscribeTrackingRectangleCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest", []);
    }
    create(value?: PartialMessage<SubscribeTrackingRectangleCommandRequest>): SubscribeTrackingRectangleCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTrackingRectangleCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTrackingRectangleCommandRequest): SubscribeTrackingRectangleCommandRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTrackingRectangleCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeTrackingRectangleCommandRequest
 */
export const SubscribeTrackingRectangleCommandRequest = new SubscribeTrackingRectangleCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackingRectangleCommandResponse$Type extends MessageType<TrackingRectangleCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.TrackingRectangleCommandResponse", [
            { no: 1, name: "track_rectangle", kind: "message", T: () => TrackRectangle }
        ]);
    }
    create(value?: PartialMessage<TrackingRectangleCommandResponse>): TrackingRectangleCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackingRectangleCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackingRectangleCommandResponse): TrackingRectangleCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.TrackRectangle track_rectangle */ 1:
                    message.trackRectangle = TrackRectangle.internalBinaryRead(reader, reader.uint32(), options, message.trackRectangle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackingRectangleCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.TrackRectangle track_rectangle = 1; */
        if (message.trackRectangle)
            TrackRectangle.internalBinaryWrite(message.trackRectangle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TrackingRectangleCommandResponse
 */
export const TrackingRectangleCommandResponse = new TrackingRectangleCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTrackingOffCommandRequest$Type extends MessageType<SubscribeTrackingOffCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest", []);
    }
    create(value?: PartialMessage<SubscribeTrackingOffCommandRequest>): SubscribeTrackingOffCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTrackingOffCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTrackingOffCommandRequest): SubscribeTrackingOffCommandRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTrackingOffCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.SubscribeTrackingOffCommandRequest
 */
export const SubscribeTrackingOffCommandRequest = new SubscribeTrackingOffCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackingOffCommandResponse$Type extends MessageType<TrackingOffCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.TrackingOffCommandResponse", [
            { no: 1, name: "dummy", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TrackingOffCommandResponse>): TrackingOffCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dummy = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackingOffCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackingOffCommandResponse): TrackingOffCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dummy */ 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackingOffCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dummy = 1; */
        if (message.dummy !== 0)
            writer.tag(1, WireType.Varint).int32(message.dummy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TrackingOffCommandResponse
 */
export const TrackingOffCommandResponse = new TrackingOffCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingPointCommandRequest$Type extends MessageType<RespondTrackingPointCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest", [
            { no: 1, name: "stop_video_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingPointCommandRequest>): RespondTrackingPointCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopVideoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingPointCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingPointCommandRequest): RespondTrackingPointCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback */ 1:
                    message.stopVideoFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingPointCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1; */
        if (message.stopVideoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.stopVideoFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingPointCommandRequest
 */
export const RespondTrackingPointCommandRequest = new RespondTrackingPointCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingPointCommandResponse$Type extends MessageType<RespondTrackingPointCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingPointCommandResponse>): RespondTrackingPointCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingPointCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingPointCommandResponse): RespondTrackingPointCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingPointCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingPointCommandResponse
 */
export const RespondTrackingPointCommandResponse = new RespondTrackingPointCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingRectangleCommandRequest$Type extends MessageType<RespondTrackingRectangleCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest", [
            { no: 1, name: "stop_video_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingRectangleCommandRequest>): RespondTrackingRectangleCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopVideoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingRectangleCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingRectangleCommandRequest): RespondTrackingRectangleCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback */ 1:
                    message.stopVideoFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingRectangleCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1; */
        if (message.stopVideoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.stopVideoFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingRectangleCommandRequest
 */
export const RespondTrackingRectangleCommandRequest = new RespondTrackingRectangleCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingRectangleCommandResponse$Type extends MessageType<RespondTrackingRectangleCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingRectangleCommandResponse>): RespondTrackingRectangleCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingRectangleCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingRectangleCommandResponse): RespondTrackingRectangleCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingRectangleCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingRectangleCommandResponse
 */
export const RespondTrackingRectangleCommandResponse = new RespondTrackingRectangleCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingOffCommandRequest$Type extends MessageType<RespondTrackingOffCommandRequest> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest", [
            { no: 1, name: "stop_video_feedback", kind: "enum", T: () => ["mavsdk.rpc.camera_server.CameraFeedback", CameraFeedback, "CAMERA_FEEDBACK_"] }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingOffCommandRequest>): RespondTrackingOffCommandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stopVideoFeedback = 0;
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingOffCommandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingOffCommandRequest): RespondTrackingOffCommandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback */ 1:
                    message.stopVideoFeedback = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingOffCommandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraFeedback stop_video_feedback = 1; */
        if (message.stopVideoFeedback !== 0)
            writer.tag(1, WireType.Varint).int32(message.stopVideoFeedback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingOffCommandRequest
 */
export const RespondTrackingOffCommandRequest = new RespondTrackingOffCommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RespondTrackingOffCommandResponse$Type extends MessageType<RespondTrackingOffCommandResponse> {
    constructor() {
        super("mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse", [
            { no: 1, name: "camera_server_result", kind: "message", T: () => CameraServerResult }
        ]);
    }
    create(value?: PartialMessage<RespondTrackingOffCommandResponse>): RespondTrackingOffCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RespondTrackingOffCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RespondTrackingOffCommandResponse): RespondTrackingOffCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result */ 1:
                    message.cameraServerResult = CameraServerResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RespondTrackingOffCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera_server.CameraServerResult camera_server_result = 1; */
        if (message.cameraServerResult)
            CameraServerResult.internalBinaryWrite(message.cameraServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.RespondTrackingOffCommandResponse
 */
export const RespondTrackingOffCommandResponse = new RespondTrackingOffCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPoint$Type extends MessageType<TrackPoint> {
    constructor() {
        super("mavsdk.rpc.camera_server.TrackPoint", [
            { no: 1, name: "point_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "point_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "radius", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TrackPoint>): TrackPoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pointX = 0;
        message.pointY = 0;
        message.radius = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPoint): TrackPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float point_x */ 1:
                    message.pointX = reader.float();
                    break;
                case /* float point_y */ 2:
                    message.pointY = reader.float();
                    break;
                case /* float radius */ 3:
                    message.radius = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float point_x = 1; */
        if (message.pointX !== 0)
            writer.tag(1, WireType.Bit32).float(message.pointX);
        /* float point_y = 2; */
        if (message.pointY !== 0)
            writer.tag(2, WireType.Bit32).float(message.pointY);
        /* float radius = 3; */
        if (message.radius !== 0)
            writer.tag(3, WireType.Bit32).float(message.radius);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TrackPoint
 */
export const TrackPoint = new TrackPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackRectangle$Type extends MessageType<TrackRectangle> {
    constructor() {
        super("mavsdk.rpc.camera_server.TrackRectangle", [
            { no: 1, name: "top_left_corner_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "top_left_corner_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bottom_right_corner_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bottom_right_corner_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TrackRectangle>): TrackRectangle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.topLeftCornerX = 0;
        message.topLeftCornerY = 0;
        message.bottomRightCornerX = 0;
        message.bottomRightCornerY = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackRectangle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackRectangle): TrackRectangle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float top_left_corner_x */ 1:
                    message.topLeftCornerX = reader.float();
                    break;
                case /* float top_left_corner_y */ 2:
                    message.topLeftCornerY = reader.float();
                    break;
                case /* float bottom_right_corner_x */ 3:
                    message.bottomRightCornerX = reader.float();
                    break;
                case /* float bottom_right_corner_y */ 4:
                    message.bottomRightCornerY = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackRectangle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float top_left_corner_x = 1; */
        if (message.topLeftCornerX !== 0)
            writer.tag(1, WireType.Bit32).float(message.topLeftCornerX);
        /* float top_left_corner_y = 2; */
        if (message.topLeftCornerY !== 0)
            writer.tag(2, WireType.Bit32).float(message.topLeftCornerY);
        /* float bottom_right_corner_x = 3; */
        if (message.bottomRightCornerX !== 0)
            writer.tag(3, WireType.Bit32).float(message.bottomRightCornerX);
        /* float bottom_right_corner_y = 4; */
        if (message.bottomRightCornerY !== 0)
            writer.tag(4, WireType.Bit32).float(message.bottomRightCornerY);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera_server.TrackRectangle
 */
export const TrackRectangle = new TrackRectangle$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.camera_server.CameraServerService
 */
export const CameraServerService = new ServiceType("mavsdk.rpc.camera_server.CameraServerService", [
    { name: "SetInformation", options: { "mavsdk.options.async_type": "SYNC" }, I: SetInformationRequest, O: SetInformationResponse },
    { name: "SetVideoStreaming", options: { "mavsdk.options.async_type": "SYNC" }, I: SetVideoStreamingRequest, O: SetVideoStreamingResponse },
    { name: "SetInProgress", options: { "mavsdk.options.async_type": "SYNC" }, I: SetInProgressRequest, O: SetInProgressResponse },
    { name: "SubscribeTakePhoto", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTakePhotoRequest, O: TakePhotoResponse },
    { name: "RespondTakePhoto", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondTakePhotoRequest, O: RespondTakePhotoResponse },
    { name: "SubscribeStartVideo", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeStartVideoRequest, O: StartVideoResponse },
    { name: "RespondStartVideo", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondStartVideoRequest, O: RespondStartVideoResponse },
    { name: "SubscribeStopVideo", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeStopVideoRequest, O: StopVideoResponse },
    { name: "RespondStopVideo", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondStopVideoRequest, O: RespondStopVideoResponse },
    { name: "SubscribeStartVideoStreaming", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeStartVideoStreamingRequest, O: StartVideoStreamingResponse },
    { name: "RespondStartVideoStreaming", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondStartVideoStreamingRequest, O: RespondStartVideoStreamingResponse },
    { name: "SubscribeStopVideoStreaming", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeStopVideoStreamingRequest, O: StopVideoStreamingResponse },
    { name: "RespondStopVideoStreaming", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondStopVideoStreamingRequest, O: RespondStopVideoStreamingResponse },
    { name: "SubscribeSetMode", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeSetModeRequest, O: SetModeResponse },
    { name: "RespondSetMode", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondSetModeRequest, O: RespondSetModeResponse },
    { name: "SubscribeStorageInformation", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeStorageInformationRequest, O: StorageInformationResponse },
    { name: "RespondStorageInformation", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondStorageInformationRequest, O: RespondStorageInformationResponse },
    { name: "SubscribeCaptureStatus", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeCaptureStatusRequest, O: CaptureStatusResponse },
    { name: "RespondCaptureStatus", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondCaptureStatusRequest, O: RespondCaptureStatusResponse },
    { name: "SubscribeFormatStorage", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeFormatStorageRequest, O: FormatStorageResponse },
    { name: "RespondFormatStorage", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondFormatStorageRequest, O: RespondFormatStorageResponse },
    { name: "SubscribeResetSettings", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeResetSettingsRequest, O: ResetSettingsResponse },
    { name: "RespondResetSettings", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondResetSettingsRequest, O: RespondResetSettingsResponse },
    { name: "SubscribeZoomInStart", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeZoomInStartRequest, O: ZoomInStartResponse },
    { name: "RespondZoomInStart", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondZoomInStartRequest, O: RespondZoomInStartResponse },
    { name: "SubscribeZoomOutStart", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeZoomOutStartRequest, O: ZoomOutStartResponse },
    { name: "RespondZoomOutStart", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondZoomOutStartRequest, O: RespondZoomOutStartResponse },
    { name: "SubscribeZoomStop", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeZoomStopRequest, O: ZoomStopResponse },
    { name: "RespondZoomStop", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondZoomStopRequest, O: RespondZoomStopResponse },
    { name: "SubscribeZoomRange", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeZoomRangeRequest, O: ZoomRangeResponse },
    { name: "RespondZoomRange", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondZoomRangeRequest, O: RespondZoomRangeResponse },
    { name: "SetTrackingRectangleStatus", options: { "mavsdk.options.async_type": "SYNC" }, I: SetTrackingRectangleStatusRequest, O: SetTrackingRectangleStatusResponse },
    { name: "SetTrackingOffStatus", options: { "mavsdk.options.async_type": "SYNC" }, I: SetTrackingOffStatusRequest, O: SetTrackingOffStatusResponse },
    { name: "SubscribeTrackingPointCommand", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTrackingPointCommandRequest, O: TrackingPointCommandResponse },
    { name: "SubscribeTrackingRectangleCommand", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTrackingRectangleCommandRequest, O: TrackingRectangleCommandResponse },
    { name: "SubscribeTrackingOffCommand", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTrackingOffCommandRequest, O: TrackingOffCommandResponse },
    { name: "RespondTrackingPointCommand", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondTrackingPointCommandRequest, O: RespondTrackingPointCommandResponse },
    { name: "RespondTrackingRectangleCommand", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondTrackingRectangleCommandRequest, O: RespondTrackingRectangleCommandResponse },
    { name: "RespondTrackingOffCommand", options: { "mavsdk.options.async_type": "SYNC" }, I: RespondTrackingOffCommandRequest, O: RespondTrackingOffCommandResponse }
]);
