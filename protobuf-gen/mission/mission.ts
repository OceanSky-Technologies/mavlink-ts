/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "mission/mission.proto" (package "mavsdk.rpc.mission", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.mission.UploadMissionRequest
 */
export interface UploadMissionRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionPlan mission_plan = 1;
     */
    missionPlan?: MissionPlan; // The mission plan
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.UploadMissionResponse
 */
export interface UploadMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SubscribeUploadMissionWithProgressRequest
 */
export interface SubscribeUploadMissionWithProgressRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionPlan mission_plan = 1;
     */
    missionPlan?: MissionPlan; // The mission plan
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.UploadMissionWithProgressResponse
 */
export interface UploadMissionWithProgressResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.ProgressData progress_data = 2;
     */
    progressData?: ProgressData; // The progress data
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.CancelMissionUploadRequest
 */
export interface CancelMissionUploadRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.CancelMissionUploadResponse
 */
export interface CancelMissionUploadResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.DownloadMissionRequest
 */
export interface DownloadMissionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.DownloadMissionResponse
 */
export interface DownloadMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionPlan mission_plan = 2;
     */
    missionPlan?: MissionPlan; // The mission plan
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SubscribeDownloadMissionWithProgressRequest
 */
export interface SubscribeDownloadMissionWithProgressRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.DownloadMissionWithProgressResponse
 */
export interface DownloadMissionWithProgressResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.ProgressDataOrMission progress_data = 2;
     */
    progressData?: ProgressDataOrMission; // The progress data, or the mission plan (when the download is finished)
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.CancelMissionDownloadRequest
 */
export interface CancelMissionDownloadRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.CancelMissionDownloadResponse
 */
export interface CancelMissionDownloadResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.StartMissionRequest
 */
export interface StartMissionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.StartMissionResponse
 */
export interface StartMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.PauseMissionRequest
 */
export interface PauseMissionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.PauseMissionResponse
 */
export interface PauseMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.ClearMissionRequest
 */
export interface ClearMissionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.ClearMissionResponse
 */
export interface ClearMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SetCurrentMissionItemRequest
 */
export interface SetCurrentMissionItemRequest {
    /**
     * @generated from protobuf field: int32 index = 1;
     */
    index: number; // Index of the mission item to be set as the next one (0-based)
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SetCurrentMissionItemResponse
 */
export interface SetCurrentMissionItemResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.IsMissionFinishedRequest
 */
export interface IsMissionFinishedRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.IsMissionFinishedResponse
 */
export interface IsMissionFinishedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
    /**
     * @generated from protobuf field: bool is_finished = 2;
     */
    isFinished: boolean; // True if the mission is finished and the last mission item has been reached
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SubscribeMissionProgressRequest
 */
export interface SubscribeMissionProgressRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.MissionProgressResponse
 */
export interface MissionProgressResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionProgress mission_progress = 1;
     */
    missionProgress?: MissionProgress; // Mission progress
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.GetReturnToLaunchAfterMissionRequest
 */
export interface GetReturnToLaunchAfterMissionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.GetReturnToLaunchAfterMissionResponse
 */
export interface GetReturnToLaunchAfterMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
    /**
     * @generated from protobuf field: bool enable = 2;
     */
    enable: boolean; // If true, trigger an RTL at the end of the mission
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SetReturnToLaunchAfterMissionRequest
 */
export interface SetReturnToLaunchAfterMissionRequest {
    /**
     * @generated from protobuf field: bool enable = 1;
     */
    enable: boolean; // If true, trigger an RTL at the end of the mission
}
/**
 * @generated from protobuf message mavsdk.rpc.mission.SetReturnToLaunchAfterMissionResponse
 */
export interface SetReturnToLaunchAfterMissionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult mission_result = 1;
     */
    missionResult?: MissionResult;
}
/**
 *
 * Type representing a mission item.
 *
 * A MissionItem can contain a position and/or actions.
 * Mission items are building blocks to assemble a mission,
 * which can be sent to (or received from) a system.
 * They cannot be used independently.
 *
 * @generated from protobuf message mavsdk.rpc.mission.MissionItem
 */
export interface MissionItem {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to +180)
    /**
     * @generated from protobuf field: float relative_altitude_m = 3;
     */
    relativeAltitudeM: number; // Altitude relative to takeoff altitude in metres
    /**
     * @generated from protobuf field: float speed_m_s = 4;
     */
    speedMS: number; // Speed to use after this mission item (in metres/second)
    /**
     * @generated from protobuf field: bool is_fly_through = 5;
     */
    isFlyThrough: boolean; // True will make the drone fly through without stopping, while false will make the drone stop on the waypoint
    /**
     * @generated from protobuf field: float gimbal_pitch_deg = 6;
     */
    gimbalPitchDeg: number; // Gimbal pitch (in degrees)
    /**
     * @generated from protobuf field: float gimbal_yaw_deg = 7;
     */
    gimbalYawDeg: number; // Gimbal yaw (in degrees)
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionItem.CameraAction camera_action = 8;
     */
    cameraAction: MissionItem_CameraAction; // Camera action to trigger at this mission item
    /**
     * @generated from protobuf field: float loiter_time_s = 9;
     */
    loiterTimeS: number; // Loiter time (in seconds)
    /**
     * @generated from protobuf field: double camera_photo_interval_s = 10;
     */
    cameraPhotoIntervalS: number; // Camera photo interval to use after this mission item (in seconds)
    /**
     * @generated from protobuf field: float acceptance_radius_m = 11;
     */
    acceptanceRadiusM: number; // Radius for completing a mission item (in metres)
    /**
     * @generated from protobuf field: float yaw_deg = 12;
     */
    yawDeg: number; // Absolute yaw angle (in degrees)
    /**
     * @generated from protobuf field: float camera_photo_distance_m = 13;
     */
    cameraPhotoDistanceM: number; // Camera photo distance to use after this mission item (in meters)
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionItem.VehicleAction vehicle_action = 14;
     */
    vehicleAction: MissionItem_VehicleAction; // Vehicle action to trigger at this mission item.
}
/**
 * Possible camera actions at a mission item.
 *
 * @generated from protobuf enum mavsdk.rpc.mission.MissionItem.CameraAction
 */
export enum MissionItem_CameraAction {
    /**
     * No action
     *
     * @generated from protobuf enum value: CAMERA_ACTION_NONE = 0;
     */
    NONE = 0,
    /**
     * Take a single photo
     *
     * @generated from protobuf enum value: CAMERA_ACTION_TAKE_PHOTO = 1;
     */
    TAKE_PHOTO = 1,
    /**
     * Start capturing photos at regular intervals
     *
     * @generated from protobuf enum value: CAMERA_ACTION_START_PHOTO_INTERVAL = 2;
     */
    START_PHOTO_INTERVAL = 2,
    /**
     * Stop capturing photos at regular intervals
     *
     * @generated from protobuf enum value: CAMERA_ACTION_STOP_PHOTO_INTERVAL = 3;
     */
    STOP_PHOTO_INTERVAL = 3,
    /**
     * Start capturing video
     *
     * @generated from protobuf enum value: CAMERA_ACTION_START_VIDEO = 4;
     */
    START_VIDEO = 4,
    /**
     * Stop capturing video
     *
     * @generated from protobuf enum value: CAMERA_ACTION_STOP_VIDEO = 5;
     */
    STOP_VIDEO = 5,
    /**
     * Start capturing photos at regular distance
     *
     * @generated from protobuf enum value: CAMERA_ACTION_START_PHOTO_DISTANCE = 6;
     */
    START_PHOTO_DISTANCE = 6,
    /**
     * Stop capturing photos at regular distance
     *
     * @generated from protobuf enum value: CAMERA_ACTION_STOP_PHOTO_DISTANCE = 7;
     */
    STOP_PHOTO_DISTANCE = 7
}
/**
 * Possible vehicle actions at a mission item
 *
 * @generated from protobuf enum mavsdk.rpc.mission.MissionItem.VehicleAction
 */
export enum MissionItem_VehicleAction {
    /**
     * No action
     *
     * @generated from protobuf enum value: VEHICLE_ACTION_NONE = 0;
     */
    NONE = 0,
    /**
     * Vehicle will takeoff and go to defined waypoint
     *
     * @generated from protobuf enum value: VEHICLE_ACTION_TAKEOFF = 1;
     */
    TAKEOFF = 1,
    /**
     * When a waypoint is reached vehicle will land at current position
     *
     * @generated from protobuf enum value: VEHICLE_ACTION_LAND = 2;
     */
    LAND = 2,
    /**
     * When a waypoint is reached vehicle will transition to fixed-wing mode
     *
     * @generated from protobuf enum value: VEHICLE_ACTION_TRANSITION_TO_FW = 3;
     */
    TRANSITION_TO_FW = 3,
    /**
     * When a waypoint is reached vehicle will transition to multi-copter mode
     *
     * @generated from protobuf enum value: VEHICLE_ACTION_TRANSITION_TO_MC = 4;
     */
    TRANSITION_TO_MC = 4
}
/**
 * Mission plan type
 *
 * @generated from protobuf message mavsdk.rpc.mission.MissionPlan
 */
export interface MissionPlan {
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.mission.MissionItem mission_items = 1;
     */
    missionItems: MissionItem[]; // The mission items
}
/**
 * Mission progress type.
 *
 * @generated from protobuf message mavsdk.rpc.mission.MissionProgress
 */
export interface MissionProgress {
    /**
     * @generated from protobuf field: int32 current = 1;
     */
    current: number; // Current mission item index (0-based), if equal to total, the mission is finished
    /**
     * @generated from protobuf field: int32 total = 2;
     */
    total: number; // Total number of mission items
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.mission.MissionResult
 */
export interface MissionResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionResult.Result result = 1;
     */
    result: MissionResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for action requests.
 *
 * @generated from protobuf enum mavsdk.rpc.mission.MissionResult.Result
 */
export enum MissionResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request succeeded
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Error
     *
     * @generated from protobuf enum value: RESULT_ERROR = 2;
     */
    ERROR = 2,
    /**
     * Too many mission items in the mission
     *
     * @generated from protobuf enum value: RESULT_TOO_MANY_MISSION_ITEMS = 3;
     */
    TOO_MANY_MISSION_ITEMS = 3,
    /**
     * Vehicle is busy
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 5;
     */
    TIMEOUT = 5,
    /**
     * Invalid argument
     *
     * @generated from protobuf enum value: RESULT_INVALID_ARGUMENT = 6;
     */
    INVALID_ARGUMENT = 6,
    /**
     * Mission downloaded from the system is not supported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 7;
     */
    UNSUPPORTED = 7,
    /**
     * No mission available on the system
     *
     * @generated from protobuf enum value: RESULT_NO_MISSION_AVAILABLE = 8;
     */
    NO_MISSION_AVAILABLE = 8,
    /**
     * Unsupported mission command
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED_MISSION_CMD = 11;
     */
    UNSUPPORTED_MISSION_CMD = 11,
    /**
     * Mission transfer (upload or download) has been cancelled
     *
     * @generated from protobuf enum value: RESULT_TRANSFER_CANCELLED = 12;
     */
    TRANSFER_CANCELLED = 12,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 13;
     */
    NO_SYSTEM = 13,
    /**
     * Intermediate message showing progress
     *
     * @generated from protobuf enum value: RESULT_NEXT = 14;
     */
    NEXT = 14,
    /**
     * Request denied
     *
     * @generated from protobuf enum value: RESULT_DENIED = 15;
     */
    DENIED = 15,
    /**
     * There was a protocol error
     *
     * @generated from protobuf enum value: RESULT_PROTOCOL_ERROR = 16;
     */
    PROTOCOL_ERROR = 16,
    /**
     * The system does not support the MISSION_INT protocol
     *
     * @generated from protobuf enum value: RESULT_INT_MESSAGES_NOT_SUPPORTED = 17;
     */
    INT_MESSAGES_NOT_SUPPORTED = 17
}
/**
 * Progress data coming from mission upload.
 *
 * @generated from protobuf message mavsdk.rpc.mission.ProgressData
 */
export interface ProgressData {
    /**
     * @generated from protobuf field: float progress = 1;
     */
    progress: number; // Progress (0..1.0)
}
/**
 * Progress data coming from mission download, or the mission itself (if the transfer succeeds).
 *
 * @generated from protobuf message mavsdk.rpc.mission.ProgressDataOrMission
 */
export interface ProgressDataOrMission {
    /**
     * @generated from protobuf field: bool has_progress = 1;
     */
    hasProgress: boolean; // Whether this ProgressData contains a 'progress' status or not
    /**
     * @generated from protobuf field: float progress = 2;
     */
    progress: number; // Progress (0..1.0)
    /**
     * @generated from protobuf field: bool has_mission = 3;
     */
    hasMission: boolean; // Whether this ProgressData contains a 'mission_plan' or not
    /**
     * @generated from protobuf field: mavsdk.rpc.mission.MissionPlan mission_plan = 4;
     */
    missionPlan?: MissionPlan; // Mission plan
}
// @generated message type with reflection information, may provide speed optimized methods
class UploadMissionRequest$Type extends MessageType<UploadMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.UploadMissionRequest", [
            { no: 1, name: "mission_plan", kind: "message", T: () => MissionPlan }
        ]);
    }
    create(value?: PartialMessage<UploadMissionRequest>): UploadMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadMissionRequest): UploadMissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionPlan mission_plan */ 1:
                    message.missionPlan = MissionPlan.internalBinaryRead(reader, reader.uint32(), options, message.missionPlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionPlan mission_plan = 1; */
        if (message.missionPlan)
            MissionPlan.internalBinaryWrite(message.missionPlan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.UploadMissionRequest
 */
export const UploadMissionRequest = new UploadMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadMissionResponse$Type extends MessageType<UploadMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.UploadMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<UploadMissionResponse>): UploadMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadMissionResponse): UploadMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.UploadMissionResponse
 */
export const UploadMissionResponse = new UploadMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeUploadMissionWithProgressRequest$Type extends MessageType<SubscribeUploadMissionWithProgressRequest> {
    constructor() {
        super("mavsdk.rpc.mission.SubscribeUploadMissionWithProgressRequest", [
            { no: 1, name: "mission_plan", kind: "message", T: () => MissionPlan }
        ]);
    }
    create(value?: PartialMessage<SubscribeUploadMissionWithProgressRequest>): SubscribeUploadMissionWithProgressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeUploadMissionWithProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeUploadMissionWithProgressRequest): SubscribeUploadMissionWithProgressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionPlan mission_plan */ 1:
                    message.missionPlan = MissionPlan.internalBinaryRead(reader, reader.uint32(), options, message.missionPlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeUploadMissionWithProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionPlan mission_plan = 1; */
        if (message.missionPlan)
            MissionPlan.internalBinaryWrite(message.missionPlan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SubscribeUploadMissionWithProgressRequest
 */
export const SubscribeUploadMissionWithProgressRequest = new SubscribeUploadMissionWithProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadMissionWithProgressResponse$Type extends MessageType<UploadMissionWithProgressResponse> {
    constructor() {
        super("mavsdk.rpc.mission.UploadMissionWithProgressResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult },
            { no: 2, name: "progress_data", kind: "message", T: () => ProgressData }
        ]);
    }
    create(value?: PartialMessage<UploadMissionWithProgressResponse>): UploadMissionWithProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadMissionWithProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadMissionWithProgressResponse): UploadMissionWithProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                case /* mavsdk.rpc.mission.ProgressData progress_data */ 2:
                    message.progressData = ProgressData.internalBinaryRead(reader, reader.uint32(), options, message.progressData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadMissionWithProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mission.ProgressData progress_data = 2; */
        if (message.progressData)
            ProgressData.internalBinaryWrite(message.progressData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.UploadMissionWithProgressResponse
 */
export const UploadMissionWithProgressResponse = new UploadMissionWithProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelMissionUploadRequest$Type extends MessageType<CancelMissionUploadRequest> {
    constructor() {
        super("mavsdk.rpc.mission.CancelMissionUploadRequest", []);
    }
    create(value?: PartialMessage<CancelMissionUploadRequest>): CancelMissionUploadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelMissionUploadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelMissionUploadRequest): CancelMissionUploadRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelMissionUploadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.CancelMissionUploadRequest
 */
export const CancelMissionUploadRequest = new CancelMissionUploadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelMissionUploadResponse$Type extends MessageType<CancelMissionUploadResponse> {
    constructor() {
        super("mavsdk.rpc.mission.CancelMissionUploadResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<CancelMissionUploadResponse>): CancelMissionUploadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelMissionUploadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelMissionUploadResponse): CancelMissionUploadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelMissionUploadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.CancelMissionUploadResponse
 */
export const CancelMissionUploadResponse = new CancelMissionUploadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadMissionRequest$Type extends MessageType<DownloadMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.DownloadMissionRequest", []);
    }
    create(value?: PartialMessage<DownloadMissionRequest>): DownloadMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DownloadMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadMissionRequest): DownloadMissionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DownloadMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.DownloadMissionRequest
 */
export const DownloadMissionRequest = new DownloadMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadMissionResponse$Type extends MessageType<DownloadMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.DownloadMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult },
            { no: 2, name: "mission_plan", kind: "message", T: () => MissionPlan }
        ]);
    }
    create(value?: PartialMessage<DownloadMissionResponse>): DownloadMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DownloadMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadMissionResponse): DownloadMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                case /* mavsdk.rpc.mission.MissionPlan mission_plan */ 2:
                    message.missionPlan = MissionPlan.internalBinaryRead(reader, reader.uint32(), options, message.missionPlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mission.MissionPlan mission_plan = 2; */
        if (message.missionPlan)
            MissionPlan.internalBinaryWrite(message.missionPlan, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.DownloadMissionResponse
 */
export const DownloadMissionResponse = new DownloadMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeDownloadMissionWithProgressRequest$Type extends MessageType<SubscribeDownloadMissionWithProgressRequest> {
    constructor() {
        super("mavsdk.rpc.mission.SubscribeDownloadMissionWithProgressRequest", []);
    }
    create(value?: PartialMessage<SubscribeDownloadMissionWithProgressRequest>): SubscribeDownloadMissionWithProgressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeDownloadMissionWithProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeDownloadMissionWithProgressRequest): SubscribeDownloadMissionWithProgressRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeDownloadMissionWithProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SubscribeDownloadMissionWithProgressRequest
 */
export const SubscribeDownloadMissionWithProgressRequest = new SubscribeDownloadMissionWithProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadMissionWithProgressResponse$Type extends MessageType<DownloadMissionWithProgressResponse> {
    constructor() {
        super("mavsdk.rpc.mission.DownloadMissionWithProgressResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult },
            { no: 2, name: "progress_data", kind: "message", T: () => ProgressDataOrMission }
        ]);
    }
    create(value?: PartialMessage<DownloadMissionWithProgressResponse>): DownloadMissionWithProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DownloadMissionWithProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadMissionWithProgressResponse): DownloadMissionWithProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                case /* mavsdk.rpc.mission.ProgressDataOrMission progress_data */ 2:
                    message.progressData = ProgressDataOrMission.internalBinaryRead(reader, reader.uint32(), options, message.progressData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadMissionWithProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mission.ProgressDataOrMission progress_data = 2; */
        if (message.progressData)
            ProgressDataOrMission.internalBinaryWrite(message.progressData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.DownloadMissionWithProgressResponse
 */
export const DownloadMissionWithProgressResponse = new DownloadMissionWithProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelMissionDownloadRequest$Type extends MessageType<CancelMissionDownloadRequest> {
    constructor() {
        super("mavsdk.rpc.mission.CancelMissionDownloadRequest", []);
    }
    create(value?: PartialMessage<CancelMissionDownloadRequest>): CancelMissionDownloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelMissionDownloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelMissionDownloadRequest): CancelMissionDownloadRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CancelMissionDownloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.CancelMissionDownloadRequest
 */
export const CancelMissionDownloadRequest = new CancelMissionDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CancelMissionDownloadResponse$Type extends MessageType<CancelMissionDownloadResponse> {
    constructor() {
        super("mavsdk.rpc.mission.CancelMissionDownloadResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<CancelMissionDownloadResponse>): CancelMissionDownloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CancelMissionDownloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CancelMissionDownloadResponse): CancelMissionDownloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CancelMissionDownloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.CancelMissionDownloadResponse
 */
export const CancelMissionDownloadResponse = new CancelMissionDownloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartMissionRequest$Type extends MessageType<StartMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.StartMissionRequest", []);
    }
    create(value?: PartialMessage<StartMissionRequest>): StartMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartMissionRequest): StartMissionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StartMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.StartMissionRequest
 */
export const StartMissionRequest = new StartMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartMissionResponse$Type extends MessageType<StartMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.StartMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<StartMissionResponse>): StartMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartMissionResponse): StartMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.StartMissionResponse
 */
export const StartMissionResponse = new StartMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseMissionRequest$Type extends MessageType<PauseMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.PauseMissionRequest", []);
    }
    create(value?: PartialMessage<PauseMissionRequest>): PauseMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PauseMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseMissionRequest): PauseMissionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PauseMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.PauseMissionRequest
 */
export const PauseMissionRequest = new PauseMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PauseMissionResponse$Type extends MessageType<PauseMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.PauseMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<PauseMissionResponse>): PauseMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PauseMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PauseMissionResponse): PauseMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PauseMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.PauseMissionResponse
 */
export const PauseMissionResponse = new PauseMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClearMissionRequest$Type extends MessageType<ClearMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.ClearMissionRequest", []);
    }
    create(value?: PartialMessage<ClearMissionRequest>): ClearMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClearMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClearMissionRequest): ClearMissionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ClearMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.ClearMissionRequest
 */
export const ClearMissionRequest = new ClearMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClearMissionResponse$Type extends MessageType<ClearMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.ClearMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<ClearMissionResponse>): ClearMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClearMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClearMissionResponse): ClearMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClearMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.ClearMissionResponse
 */
export const ClearMissionResponse = new ClearMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCurrentMissionItemRequest$Type extends MessageType<SetCurrentMissionItemRequest> {
    constructor() {
        super("mavsdk.rpc.mission.SetCurrentMissionItemRequest", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetCurrentMissionItemRequest>): SetCurrentMissionItemRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        if (value !== undefined)
            reflectionMergePartial<SetCurrentMissionItemRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCurrentMissionItemRequest): SetCurrentMissionItemRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCurrentMissionItemRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SetCurrentMissionItemRequest
 */
export const SetCurrentMissionItemRequest = new SetCurrentMissionItemRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCurrentMissionItemResponse$Type extends MessageType<SetCurrentMissionItemResponse> {
    constructor() {
        super("mavsdk.rpc.mission.SetCurrentMissionItemResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<SetCurrentMissionItemResponse>): SetCurrentMissionItemResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetCurrentMissionItemResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCurrentMissionItemResponse): SetCurrentMissionItemResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCurrentMissionItemResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SetCurrentMissionItemResponse
 */
export const SetCurrentMissionItemResponse = new SetCurrentMissionItemResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsMissionFinishedRequest$Type extends MessageType<IsMissionFinishedRequest> {
    constructor() {
        super("mavsdk.rpc.mission.IsMissionFinishedRequest", []);
    }
    create(value?: PartialMessage<IsMissionFinishedRequest>): IsMissionFinishedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IsMissionFinishedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsMissionFinishedRequest): IsMissionFinishedRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: IsMissionFinishedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.IsMissionFinishedRequest
 */
export const IsMissionFinishedRequest = new IsMissionFinishedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsMissionFinishedResponse$Type extends MessageType<IsMissionFinishedResponse> {
    constructor() {
        super("mavsdk.rpc.mission.IsMissionFinishedResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult },
            { no: 2, name: "is_finished", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IsMissionFinishedResponse>): IsMissionFinishedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isFinished = false;
        if (value !== undefined)
            reflectionMergePartial<IsMissionFinishedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsMissionFinishedResponse): IsMissionFinishedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                case /* bool is_finished */ 2:
                    message.isFinished = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsMissionFinishedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_finished = 2; */
        if (message.isFinished !== false)
            writer.tag(2, WireType.Varint).bool(message.isFinished);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.IsMissionFinishedResponse
 */
export const IsMissionFinishedResponse = new IsMissionFinishedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeMissionProgressRequest$Type extends MessageType<SubscribeMissionProgressRequest> {
    constructor() {
        super("mavsdk.rpc.mission.SubscribeMissionProgressRequest", []);
    }
    create(value?: PartialMessage<SubscribeMissionProgressRequest>): SubscribeMissionProgressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeMissionProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeMissionProgressRequest): SubscribeMissionProgressRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeMissionProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SubscribeMissionProgressRequest
 */
export const SubscribeMissionProgressRequest = new SubscribeMissionProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionProgressResponse$Type extends MessageType<MissionProgressResponse> {
    constructor() {
        super("mavsdk.rpc.mission.MissionProgressResponse", [
            { no: 1, name: "mission_progress", kind: "message", T: () => MissionProgress }
        ]);
    }
    create(value?: PartialMessage<MissionProgressResponse>): MissionProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MissionProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionProgressResponse): MissionProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionProgress mission_progress */ 1:
                    message.missionProgress = MissionProgress.internalBinaryRead(reader, reader.uint32(), options, message.missionProgress);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionProgress mission_progress = 1; */
        if (message.missionProgress)
            MissionProgress.internalBinaryWrite(message.missionProgress, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.MissionProgressResponse
 */
export const MissionProgressResponse = new MissionProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReturnToLaunchAfterMissionRequest$Type extends MessageType<GetReturnToLaunchAfterMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.GetReturnToLaunchAfterMissionRequest", []);
    }
    create(value?: PartialMessage<GetReturnToLaunchAfterMissionRequest>): GetReturnToLaunchAfterMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetReturnToLaunchAfterMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReturnToLaunchAfterMissionRequest): GetReturnToLaunchAfterMissionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetReturnToLaunchAfterMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.GetReturnToLaunchAfterMissionRequest
 */
export const GetReturnToLaunchAfterMissionRequest = new GetReturnToLaunchAfterMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetReturnToLaunchAfterMissionResponse$Type extends MessageType<GetReturnToLaunchAfterMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.GetReturnToLaunchAfterMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult },
            { no: 2, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetReturnToLaunchAfterMissionResponse>): GetReturnToLaunchAfterMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enable = false;
        if (value !== undefined)
            reflectionMergePartial<GetReturnToLaunchAfterMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetReturnToLaunchAfterMissionResponse): GetReturnToLaunchAfterMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                case /* bool enable */ 2:
                    message.enable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetReturnToLaunchAfterMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enable = 2; */
        if (message.enable !== false)
            writer.tag(2, WireType.Varint).bool(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.GetReturnToLaunchAfterMissionResponse
 */
export const GetReturnToLaunchAfterMissionResponse = new GetReturnToLaunchAfterMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReturnToLaunchAfterMissionRequest$Type extends MessageType<SetReturnToLaunchAfterMissionRequest> {
    constructor() {
        super("mavsdk.rpc.mission.SetReturnToLaunchAfterMissionRequest", [
            { no: 1, name: "enable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetReturnToLaunchAfterMissionRequest>): SetReturnToLaunchAfterMissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enable = false;
        if (value !== undefined)
            reflectionMergePartial<SetReturnToLaunchAfterMissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReturnToLaunchAfterMissionRequest): SetReturnToLaunchAfterMissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enable */ 1:
                    message.enable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReturnToLaunchAfterMissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enable = 1; */
        if (message.enable !== false)
            writer.tag(1, WireType.Varint).bool(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SetReturnToLaunchAfterMissionRequest
 */
export const SetReturnToLaunchAfterMissionRequest = new SetReturnToLaunchAfterMissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetReturnToLaunchAfterMissionResponse$Type extends MessageType<SetReturnToLaunchAfterMissionResponse> {
    constructor() {
        super("mavsdk.rpc.mission.SetReturnToLaunchAfterMissionResponse", [
            { no: 1, name: "mission_result", kind: "message", T: () => MissionResult }
        ]);
    }
    create(value?: PartialMessage<SetReturnToLaunchAfterMissionResponse>): SetReturnToLaunchAfterMissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetReturnToLaunchAfterMissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetReturnToLaunchAfterMissionResponse): SetReturnToLaunchAfterMissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult mission_result */ 1:
                    message.missionResult = MissionResult.internalBinaryRead(reader, reader.uint32(), options, message.missionResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetReturnToLaunchAfterMissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult mission_result = 1; */
        if (message.missionResult)
            MissionResult.internalBinaryWrite(message.missionResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.SetReturnToLaunchAfterMissionResponse
 */
export const SetReturnToLaunchAfterMissionResponse = new SetReturnToLaunchAfterMissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionItem$Type extends MessageType<MissionItem> {
    constructor() {
        super("mavsdk.rpc.mission.MissionItem", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN", "mavsdk.options.epsilon": 1e-7 } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN", "mavsdk.options.epsilon": 1e-7 } },
            { no: 3, name: "relative_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "speed_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "is_fly_through", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 6, name: "gimbal_pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN", "mavsdk.options.epsilon": 0.0001 } },
            { no: 7, name: "gimbal_yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN", "mavsdk.options.epsilon": 0.0001 } },
            { no: 8, name: "camera_action", kind: "enum", T: () => ["mavsdk.rpc.mission.MissionItem.CameraAction", MissionItem_CameraAction, "CAMERA_ACTION_"] },
            { no: 9, name: "loiter_time_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 10, name: "camera_photo_interval_s", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "1.0" } },
            { no: 11, name: "acceptance_radius_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 12, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 13, name: "camera_photo_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NAN" } },
            { no: 14, name: "vehicle_action", kind: "enum", T: () => ["mavsdk.rpc.mission.MissionItem.VehicleAction", MissionItem_VehicleAction, "VEHICLE_ACTION_"] }
        ]);
    }
    create(value?: PartialMessage<MissionItem>): MissionItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.relativeAltitudeM = 0;
        message.speedMS = 0;
        message.isFlyThrough = false;
        message.gimbalPitchDeg = 0;
        message.gimbalYawDeg = 0;
        message.cameraAction = 0;
        message.loiterTimeS = 0;
        message.cameraPhotoIntervalS = 0;
        message.acceptanceRadiusM = 0;
        message.yawDeg = 0;
        message.cameraPhotoDistanceM = 0;
        message.vehicleAction = 0;
        if (value !== undefined)
            reflectionMergePartial<MissionItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionItem): MissionItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float relative_altitude_m */ 3:
                    message.relativeAltitudeM = reader.float();
                    break;
                case /* float speed_m_s */ 4:
                    message.speedMS = reader.float();
                    break;
                case /* bool is_fly_through */ 5:
                    message.isFlyThrough = reader.bool();
                    break;
                case /* float gimbal_pitch_deg */ 6:
                    message.gimbalPitchDeg = reader.float();
                    break;
                case /* float gimbal_yaw_deg */ 7:
                    message.gimbalYawDeg = reader.float();
                    break;
                case /* mavsdk.rpc.mission.MissionItem.CameraAction camera_action */ 8:
                    message.cameraAction = reader.int32();
                    break;
                case /* float loiter_time_s */ 9:
                    message.loiterTimeS = reader.float();
                    break;
                case /* double camera_photo_interval_s */ 10:
                    message.cameraPhotoIntervalS = reader.double();
                    break;
                case /* float acceptance_radius_m */ 11:
                    message.acceptanceRadiusM = reader.float();
                    break;
                case /* float yaw_deg */ 12:
                    message.yawDeg = reader.float();
                    break;
                case /* float camera_photo_distance_m */ 13:
                    message.cameraPhotoDistanceM = reader.float();
                    break;
                case /* mavsdk.rpc.mission.MissionItem.VehicleAction vehicle_action */ 14:
                    message.vehicleAction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float relative_altitude_m = 3; */
        if (message.relativeAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.relativeAltitudeM);
        /* float speed_m_s = 4; */
        if (message.speedMS !== 0)
            writer.tag(4, WireType.Bit32).float(message.speedMS);
        /* bool is_fly_through = 5; */
        if (message.isFlyThrough !== false)
            writer.tag(5, WireType.Varint).bool(message.isFlyThrough);
        /* float gimbal_pitch_deg = 6; */
        if (message.gimbalPitchDeg !== 0)
            writer.tag(6, WireType.Bit32).float(message.gimbalPitchDeg);
        /* float gimbal_yaw_deg = 7; */
        if (message.gimbalYawDeg !== 0)
            writer.tag(7, WireType.Bit32).float(message.gimbalYawDeg);
        /* mavsdk.rpc.mission.MissionItem.CameraAction camera_action = 8; */
        if (message.cameraAction !== 0)
            writer.tag(8, WireType.Varint).int32(message.cameraAction);
        /* float loiter_time_s = 9; */
        if (message.loiterTimeS !== 0)
            writer.tag(9, WireType.Bit32).float(message.loiterTimeS);
        /* double camera_photo_interval_s = 10; */
        if (message.cameraPhotoIntervalS !== 0)
            writer.tag(10, WireType.Bit64).double(message.cameraPhotoIntervalS);
        /* float acceptance_radius_m = 11; */
        if (message.acceptanceRadiusM !== 0)
            writer.tag(11, WireType.Bit32).float(message.acceptanceRadiusM);
        /* float yaw_deg = 12; */
        if (message.yawDeg !== 0)
            writer.tag(12, WireType.Bit32).float(message.yawDeg);
        /* float camera_photo_distance_m = 13; */
        if (message.cameraPhotoDistanceM !== 0)
            writer.tag(13, WireType.Bit32).float(message.cameraPhotoDistanceM);
        /* mavsdk.rpc.mission.MissionItem.VehicleAction vehicle_action = 14; */
        if (message.vehicleAction !== 0)
            writer.tag(14, WireType.Varint).int32(message.vehicleAction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.MissionItem
 */
export const MissionItem = new MissionItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionPlan$Type extends MessageType<MissionPlan> {
    constructor() {
        super("mavsdk.rpc.mission.MissionPlan", [
            { no: 1, name: "mission_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MissionItem }
        ]);
    }
    create(value?: PartialMessage<MissionPlan>): MissionPlan {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.missionItems = [];
        if (value !== undefined)
            reflectionMergePartial<MissionPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionPlan): MissionPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mavsdk.rpc.mission.MissionItem mission_items */ 1:
                    message.missionItems.push(MissionItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mavsdk.rpc.mission.MissionItem mission_items = 1; */
        for (let i = 0; i < message.missionItems.length; i++)
            MissionItem.internalBinaryWrite(message.missionItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.MissionPlan
 */
export const MissionPlan = new MissionPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionProgress$Type extends MessageType<MissionProgress> {
    constructor() {
        super("mavsdk.rpc.mission.MissionProgress", [
            { no: 1, name: "current", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "total", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MissionProgress>): MissionProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.current = 0;
        message.total = 0;
        if (value !== undefined)
            reflectionMergePartial<MissionProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionProgress): MissionProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 current */ 1:
                    message.current = reader.int32();
                    break;
                case /* int32 total */ 2:
                    message.total = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 current = 1; */
        if (message.current !== 0)
            writer.tag(1, WireType.Varint).int32(message.current);
        /* int32 total = 2; */
        if (message.total !== 0)
            writer.tag(2, WireType.Varint).int32(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.MissionProgress
 */
export const MissionProgress = new MissionProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MissionResult$Type extends MessageType<MissionResult> {
    constructor() {
        super("mavsdk.rpc.mission.MissionResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.mission.MissionResult.Result", MissionResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MissionResult>): MissionResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<MissionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MissionResult): MissionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mission.MissionResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MissionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mission.MissionResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.MissionResult
 */
export const MissionResult = new MissionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgressData$Type extends MessageType<ProgressData> {
    constructor() {
        super("mavsdk.rpc.mission.ProgressData", [
            { no: 1, name: "progress", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<ProgressData>): ProgressData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.progress = 0;
        if (value !== undefined)
            reflectionMergePartial<ProgressData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgressData): ProgressData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float progress */ 1:
                    message.progress = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgressData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float progress = 1; */
        if (message.progress !== 0)
            writer.tag(1, WireType.Bit32).float(message.progress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.ProgressData
 */
export const ProgressData = new ProgressData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgressDataOrMission$Type extends MessageType<ProgressDataOrMission> {
    constructor() {
        super("mavsdk.rpc.mission.ProgressDataOrMission", [
            { no: 1, name: "has_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 2, name: "progress", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "has_mission", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "mission_plan", kind: "message", T: () => MissionPlan }
        ]);
    }
    create(value?: PartialMessage<ProgressDataOrMission>): ProgressDataOrMission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hasProgress = false;
        message.progress = 0;
        message.hasMission = false;
        if (value !== undefined)
            reflectionMergePartial<ProgressDataOrMission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgressDataOrMission): ProgressDataOrMission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool has_progress */ 1:
                    message.hasProgress = reader.bool();
                    break;
                case /* float progress */ 2:
                    message.progress = reader.float();
                    break;
                case /* bool has_mission */ 3:
                    message.hasMission = reader.bool();
                    break;
                case /* mavsdk.rpc.mission.MissionPlan mission_plan */ 4:
                    message.missionPlan = MissionPlan.internalBinaryRead(reader, reader.uint32(), options, message.missionPlan);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgressDataOrMission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool has_progress = 1; */
        if (message.hasProgress !== false)
            writer.tag(1, WireType.Varint).bool(message.hasProgress);
        /* float progress = 2; */
        if (message.progress !== 0)
            writer.tag(2, WireType.Bit32).float(message.progress);
        /* bool has_mission = 3; */
        if (message.hasMission !== false)
            writer.tag(3, WireType.Varint).bool(message.hasMission);
        /* mavsdk.rpc.mission.MissionPlan mission_plan = 4; */
        if (message.missionPlan)
            MissionPlan.internalBinaryWrite(message.missionPlan, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mission.ProgressDataOrMission
 */
export const ProgressDataOrMission = new ProgressDataOrMission$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.mission.MissionService
 */
export const MissionService = new ServiceType("mavsdk.rpc.mission.MissionService", [
    { name: "UploadMission", options: {}, I: UploadMissionRequest, O: UploadMissionResponse },
    { name: "SubscribeUploadMissionWithProgress", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC", "mavsdk.options.is_finite": true }, I: SubscribeUploadMissionWithProgressRequest, O: UploadMissionWithProgressResponse },
    { name: "CancelMissionUpload", options: { "mavsdk.options.async_type": "SYNC" }, I: CancelMissionUploadRequest, O: CancelMissionUploadResponse },
    { name: "DownloadMission", options: {}, I: DownloadMissionRequest, O: DownloadMissionResponse },
    { name: "SubscribeDownloadMissionWithProgress", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC", "mavsdk.options.is_finite": true }, I: SubscribeDownloadMissionWithProgressRequest, O: DownloadMissionWithProgressResponse },
    { name: "CancelMissionDownload", options: { "mavsdk.options.async_type": "SYNC" }, I: CancelMissionDownloadRequest, O: CancelMissionDownloadResponse },
    { name: "StartMission", options: {}, I: StartMissionRequest, O: StartMissionResponse },
    { name: "PauseMission", options: {}, I: PauseMissionRequest, O: PauseMissionResponse },
    { name: "ClearMission", options: {}, I: ClearMissionRequest, O: ClearMissionResponse },
    { name: "SetCurrentMissionItem", options: {}, I: SetCurrentMissionItemRequest, O: SetCurrentMissionItemResponse },
    { name: "IsMissionFinished", options: { "mavsdk.options.async_type": "SYNC" }, I: IsMissionFinishedRequest, O: IsMissionFinishedResponse },
    { name: "SubscribeMissionProgress", serverStreaming: true, options: {}, I: SubscribeMissionProgressRequest, O: MissionProgressResponse },
    { name: "GetReturnToLaunchAfterMission", options: { "mavsdk.options.async_type": "SYNC" }, I: GetReturnToLaunchAfterMissionRequest, O: GetReturnToLaunchAfterMissionResponse },
    { name: "SetReturnToLaunchAfterMission", options: { "mavsdk.options.async_type": "SYNC" }, I: SetReturnToLaunchAfterMissionRequest, O: SetReturnToLaunchAfterMissionResponse }
]);
