/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "mocap/mocap.proto" (package "mavsdk.rpc.mocap", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetVisionPositionEstimateRequest
 */
export interface SetVisionPositionEstimateRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.VisionPositionEstimate vision_position_estimate = 1;
     */
    visionPositionEstimate?: VisionPositionEstimate; // The vision position estimate
}
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetVisionPositionEstimateResponse
 */
export interface SetVisionPositionEstimateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.MocapResult mocap_result = 1;
     */
    mocapResult?: MocapResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetAttitudePositionMocapRequest
 */
export interface SetAttitudePositionMocapRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.AttitudePositionMocap attitude_position_mocap = 1;
     */
    attitudePositionMocap?: AttitudePositionMocap; // The attitude and position data
}
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetAttitudePositionMocapResponse
 */
export interface SetAttitudePositionMocapResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.MocapResult mocap_result = 1;
     */
    mocapResult?: MocapResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetOdometryRequest
 */
export interface SetOdometryRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Odometry odometry = 1;
     */
    odometry?: Odometry; // The odometry data
}
/**
 * @generated from protobuf message mavsdk.rpc.mocap.SetOdometryResponse
 */
export interface SetOdometryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.MocapResult mocap_result = 1;
     */
    mocapResult?: MocapResult;
}
/**
 * Body position type
 *
 * @generated from protobuf message mavsdk.rpc.mocap.PositionBody
 */
export interface PositionBody {
    /**
     * @generated from protobuf field: float x_m = 1;
     */
    xM: number; // X position in metres.
    /**
     * @generated from protobuf field: float y_m = 2;
     */
    yM: number; // Y position in metres.
    /**
     * @generated from protobuf field: float z_m = 3;
     */
    zM: number; // Z position in metres.
}
/**
 * Body angle type
 *
 * @generated from protobuf message mavsdk.rpc.mocap.AngleBody
 */
export interface AngleBody {
    /**
     * @generated from protobuf field: float roll_rad = 1;
     */
    rollRad: number; // Roll angle in radians.
    /**
     * @generated from protobuf field: float pitch_rad = 2;
     */
    pitchRad: number; // Pitch angle in radians.
    /**
     * @generated from protobuf field: float yaw_rad = 3;
     */
    yawRad: number; // Yaw angle in radians.
}
/**
 * Speed type, represented in the Body (X Y Z) frame and in metres/second.
 *
 * @generated from protobuf message mavsdk.rpc.mocap.SpeedBody
 */
export interface SpeedBody {
    /**
     * @generated from protobuf field: float x_m_s = 1;
     */
    xMS: number; // Velocity in X in metres/second.
    /**
     * @generated from protobuf field: float y_m_s = 2;
     */
    yMS: number; // Velocity in Y in metres/second.
    /**
     * @generated from protobuf field: float z_m_s = 3;
     */
    zMS: number; // Velocity in Z in metres/second.
}
/**
 * Angular velocity type
 *
 * @generated from protobuf message mavsdk.rpc.mocap.AngularVelocityBody
 */
export interface AngularVelocityBody {
    /**
     * @generated from protobuf field: float roll_rad_s = 1;
     */
    rollRadS: number; // Roll angular velocity in radians/second.
    /**
     * @generated from protobuf field: float pitch_rad_s = 2;
     */
    pitchRadS: number; // Pitch angular velocity in radians/second.
    /**
     * @generated from protobuf field: float yaw_rad_s = 3;
     */
    yawRadS: number; // Yaw angular velocity in radians/second.
}
/**
 * Covariance type.
 * Row-major representation of a 6x6 cross-covariance matrix upper
 * right triangle.
 * Needs to be 21 entries or 1 entry with NaN if unknown.
 *
 * @generated from protobuf message mavsdk.rpc.mocap.Covariance
 */
export interface Covariance {
    /**
     * @generated from protobuf field: repeated float covariance_matrix = 1;
     */
    covarianceMatrix: number[]; // The covariance matrix
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.mocap.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
}
/**
 * Global position/attitude estimate from a vision source.
 *
 * @generated from protobuf message mavsdk.rpc.mocap.VisionPositionEstimate
 */
export interface VisionPositionEstimate {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // PositionBody frame timestamp UNIX Epoch time (0 to use Backend timestamp)
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.PositionBody position_body = 2;
     */
    positionBody?: PositionBody; // Global position (m)
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.AngleBody angle_body = 3;
     */
    angleBody?: AngleBody; // Body angle (rad).
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Covariance pose_covariance = 4;
     */
    poseCovariance?: Covariance; // Pose cross-covariance matrix.
}
/**
 * Motion capture attitude and position
 *
 * @generated from protobuf message mavsdk.rpc.mocap.AttitudePositionMocap
 */
export interface AttitudePositionMocap {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // PositionBody frame timestamp UNIX Epoch time (0 to use Backend timestamp)
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Quaternion q = 2;
     */
    q?: Quaternion; // Attitude quaternion (w, x, y, z order, zero-rotation is 1, 0, 0, 0)
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.PositionBody position_body = 3;
     */
    positionBody?: PositionBody; // Body Position (NED)
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Covariance pose_covariance = 4;
     */
    poseCovariance?: Covariance; // Pose cross-covariance matrix.
}
/**
 * Odometry message to communicate odometry information with an external interface.
 *
 * @generated from protobuf message mavsdk.rpc.mocap.Odometry
 */
export interface Odometry {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // Timestamp (0 to use Backend timestamp).
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Odometry.MavFrame frame_id = 2;
     */
    frameId: Odometry_MavFrame; // Coordinate frame of reference for the pose data.
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.PositionBody position_body = 3;
     */
    positionBody?: PositionBody; // Body Position.
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Quaternion q = 4;
     */
    q?: Quaternion; // Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation).
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.SpeedBody speed_body = 5;
     */
    speedBody?: SpeedBody; // Linear speed (m/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.AngularVelocityBody angular_velocity_body = 6;
     */
    angularVelocityBody?: AngularVelocityBody; // Angular speed (rad/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Covariance pose_covariance = 7;
     */
    poseCovariance?: Covariance; // Pose cross-covariance matrix.
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.Covariance velocity_covariance = 8;
     */
    velocityCovariance?: Covariance; // Velocity cross-covariance matrix.
}
/**
 * Mavlink frame id
 *
 * @generated from protobuf enum mavsdk.rpc.mocap.Odometry.MavFrame
 */
export enum Odometry_MavFrame {
    /**
     * MAVLink number: 14. Odometry local coordinate frame of data given by a motion capture system, Z-down (x: north, y: east, z: down).
     *
     * @generated from protobuf enum value: MAV_FRAME_MOCAP_NED = 0;
     */
    MOCAP_NED = 0,
    /**
     * MAVLink number: 20. Forward, Right, Down coordinate frame. This is a local frame with Z-down and arbitrary F/R alignment (i.e. not aligned with NED/earth frame). Replacement for MAV_FRAME_MOCAP_NED, MAV_FRAME_VISION_NED, MAV_FRAME_ESTIM_NED.
     *
     * @generated from protobuf enum value: MAV_FRAME_LOCAL_FRD = 1;
     */
    LOCAL_FRD = 1
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.mocap.MocapResult
 */
export interface MocapResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.mocap.MocapResult.Result result = 1;
     */
    result: MocapResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for mocap requests
 *
 * @generated from protobuf enum mavsdk.rpc.mocap.MocapResult.Result
 */
export enum MocapResult_Result {
    /**
     * Unknown error
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request succeeded
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system is connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Connection error
     *
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 3;
     */
    CONNECTION_ERROR = 3,
    /**
     * Invalid request data
     *
     * @generated from protobuf enum value: RESULT_INVALID_REQUEST_DATA = 4;
     */
    INVALID_REQUEST_DATA = 4,
    /**
     * Function unsupported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 5;
     */
    UNSUPPORTED = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class SetVisionPositionEstimateRequest$Type extends MessageType<SetVisionPositionEstimateRequest> {
    constructor() {
        super("mavsdk.rpc.mocap.SetVisionPositionEstimateRequest", [
            { no: 1, name: "vision_position_estimate", kind: "message", T: () => VisionPositionEstimate }
        ]);
    }
    create(value?: PartialMessage<SetVisionPositionEstimateRequest>): SetVisionPositionEstimateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetVisionPositionEstimateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetVisionPositionEstimateRequest): SetVisionPositionEstimateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.VisionPositionEstimate vision_position_estimate */ 1:
                    message.visionPositionEstimate = VisionPositionEstimate.internalBinaryRead(reader, reader.uint32(), options, message.visionPositionEstimate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetVisionPositionEstimateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.VisionPositionEstimate vision_position_estimate = 1; */
        if (message.visionPositionEstimate)
            VisionPositionEstimate.internalBinaryWrite(message.visionPositionEstimate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetVisionPositionEstimateRequest
 */
export const SetVisionPositionEstimateRequest = new SetVisionPositionEstimateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetVisionPositionEstimateResponse$Type extends MessageType<SetVisionPositionEstimateResponse> {
    constructor() {
        super("mavsdk.rpc.mocap.SetVisionPositionEstimateResponse", [
            { no: 1, name: "mocap_result", kind: "message", T: () => MocapResult }
        ]);
    }
    create(value?: PartialMessage<SetVisionPositionEstimateResponse>): SetVisionPositionEstimateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetVisionPositionEstimateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetVisionPositionEstimateResponse): SetVisionPositionEstimateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.MocapResult mocap_result */ 1:
                    message.mocapResult = MocapResult.internalBinaryRead(reader, reader.uint32(), options, message.mocapResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetVisionPositionEstimateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.MocapResult mocap_result = 1; */
        if (message.mocapResult)
            MocapResult.internalBinaryWrite(message.mocapResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetVisionPositionEstimateResponse
 */
export const SetVisionPositionEstimateResponse = new SetVisionPositionEstimateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAttitudePositionMocapRequest$Type extends MessageType<SetAttitudePositionMocapRequest> {
    constructor() {
        super("mavsdk.rpc.mocap.SetAttitudePositionMocapRequest", [
            { no: 1, name: "attitude_position_mocap", kind: "message", T: () => AttitudePositionMocap }
        ]);
    }
    create(value?: PartialMessage<SetAttitudePositionMocapRequest>): SetAttitudePositionMocapRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAttitudePositionMocapRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAttitudePositionMocapRequest): SetAttitudePositionMocapRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.AttitudePositionMocap attitude_position_mocap */ 1:
                    message.attitudePositionMocap = AttitudePositionMocap.internalBinaryRead(reader, reader.uint32(), options, message.attitudePositionMocap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAttitudePositionMocapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.AttitudePositionMocap attitude_position_mocap = 1; */
        if (message.attitudePositionMocap)
            AttitudePositionMocap.internalBinaryWrite(message.attitudePositionMocap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetAttitudePositionMocapRequest
 */
export const SetAttitudePositionMocapRequest = new SetAttitudePositionMocapRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAttitudePositionMocapResponse$Type extends MessageType<SetAttitudePositionMocapResponse> {
    constructor() {
        super("mavsdk.rpc.mocap.SetAttitudePositionMocapResponse", [
            { no: 1, name: "mocap_result", kind: "message", T: () => MocapResult }
        ]);
    }
    create(value?: PartialMessage<SetAttitudePositionMocapResponse>): SetAttitudePositionMocapResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAttitudePositionMocapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAttitudePositionMocapResponse): SetAttitudePositionMocapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.MocapResult mocap_result */ 1:
                    message.mocapResult = MocapResult.internalBinaryRead(reader, reader.uint32(), options, message.mocapResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAttitudePositionMocapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.MocapResult mocap_result = 1; */
        if (message.mocapResult)
            MocapResult.internalBinaryWrite(message.mocapResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetAttitudePositionMocapResponse
 */
export const SetAttitudePositionMocapResponse = new SetAttitudePositionMocapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOdometryRequest$Type extends MessageType<SetOdometryRequest> {
    constructor() {
        super("mavsdk.rpc.mocap.SetOdometryRequest", [
            { no: 1, name: "odometry", kind: "message", T: () => Odometry }
        ]);
    }
    create(value?: PartialMessage<SetOdometryRequest>): SetOdometryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetOdometryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOdometryRequest): SetOdometryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.Odometry odometry */ 1:
                    message.odometry = Odometry.internalBinaryRead(reader, reader.uint32(), options, message.odometry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOdometryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.Odometry odometry = 1; */
        if (message.odometry)
            Odometry.internalBinaryWrite(message.odometry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetOdometryRequest
 */
export const SetOdometryRequest = new SetOdometryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetOdometryResponse$Type extends MessageType<SetOdometryResponse> {
    constructor() {
        super("mavsdk.rpc.mocap.SetOdometryResponse", [
            { no: 1, name: "mocap_result", kind: "message", T: () => MocapResult }
        ]);
    }
    create(value?: PartialMessage<SetOdometryResponse>): SetOdometryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetOdometryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetOdometryResponse): SetOdometryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.MocapResult mocap_result */ 1:
                    message.mocapResult = MocapResult.internalBinaryRead(reader, reader.uint32(), options, message.mocapResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetOdometryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.MocapResult mocap_result = 1; */
        if (message.mocapResult)
            MocapResult.internalBinaryWrite(message.mocapResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SetOdometryResponse
 */
export const SetOdometryResponse = new SetOdometryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionBody$Type extends MessageType<PositionBody> {
    constructor() {
        super("mavsdk.rpc.mocap.PositionBody", [
            { no: 1, name: "x_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionBody>): PositionBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xM = 0;
        message.yM = 0;
        message.zM = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionBody): PositionBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m */ 1:
                    message.xM = reader.float();
                    break;
                case /* float y_m */ 2:
                    message.yM = reader.float();
                    break;
                case /* float z_m */ 3:
                    message.zM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m = 1; */
        if (message.xM !== 0)
            writer.tag(1, WireType.Bit32).float(message.xM);
        /* float y_m = 2; */
        if (message.yM !== 0)
            writer.tag(2, WireType.Bit32).float(message.yM);
        /* float z_m = 3; */
        if (message.zM !== 0)
            writer.tag(3, WireType.Bit32).float(message.zM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.PositionBody
 */
export const PositionBody = new PositionBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngleBody$Type extends MessageType<AngleBody> {
    constructor() {
        super("mavsdk.rpc.mocap.AngleBody", [
            { no: 1, name: "roll_rad", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "pitch_rad", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "yaw_rad", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AngleBody>): AngleBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollRad = 0;
        message.pitchRad = 0;
        message.yawRad = 0;
        if (value !== undefined)
            reflectionMergePartial<AngleBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngleBody): AngleBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_rad */ 1:
                    message.rollRad = reader.float();
                    break;
                case /* float pitch_rad */ 2:
                    message.pitchRad = reader.float();
                    break;
                case /* float yaw_rad */ 3:
                    message.yawRad = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngleBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_rad = 1; */
        if (message.rollRad !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollRad);
        /* float pitch_rad = 2; */
        if (message.pitchRad !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchRad);
        /* float yaw_rad = 3; */
        if (message.yawRad !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawRad);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.AngleBody
 */
export const AngleBody = new AngleBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpeedBody$Type extends MessageType<SpeedBody> {
    constructor() {
        super("mavsdk.rpc.mocap.SpeedBody", [
            { no: 1, name: "x_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SpeedBody>): SpeedBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xMS = 0;
        message.yMS = 0;
        message.zMS = 0;
        if (value !== undefined)
            reflectionMergePartial<SpeedBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpeedBody): SpeedBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m_s */ 1:
                    message.xMS = reader.float();
                    break;
                case /* float y_m_s */ 2:
                    message.yMS = reader.float();
                    break;
                case /* float z_m_s */ 3:
                    message.zMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpeedBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m_s = 1; */
        if (message.xMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.xMS);
        /* float y_m_s = 2; */
        if (message.yMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.yMS);
        /* float z_m_s = 3; */
        if (message.zMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.zMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.SpeedBody
 */
export const SpeedBody = new SpeedBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityBody$Type extends MessageType<AngularVelocityBody> {
    constructor() {
        super("mavsdk.rpc.mocap.AngularVelocityBody", [
            { no: 1, name: "roll_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "pitch_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "yaw_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityBody>): AngularVelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollRadS = 0;
        message.pitchRadS = 0;
        message.yawRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityBody): AngularVelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_rad_s */ 1:
                    message.rollRadS = reader.float();
                    break;
                case /* float pitch_rad_s */ 2:
                    message.pitchRadS = reader.float();
                    break;
                case /* float yaw_rad_s */ 3:
                    message.yawRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_rad_s = 1; */
        if (message.rollRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollRadS);
        /* float pitch_rad_s = 2; */
        if (message.pitchRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchRadS);
        /* float yaw_rad_s = 3; */
        if (message.yawRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.AngularVelocityBody
 */
export const AngularVelocityBody = new AngularVelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Covariance$Type extends MessageType<Covariance> {
    constructor() {
        super("mavsdk.rpc.mocap.Covariance", [
            { no: 1, name: "covariance_matrix", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Covariance>): Covariance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.covarianceMatrix = [];
        if (value !== undefined)
            reflectionMergePartial<Covariance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Covariance): Covariance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float covariance_matrix */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.covarianceMatrix.push(reader.float());
                    else
                        message.covarianceMatrix.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Covariance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float covariance_matrix = 1; */
        if (message.covarianceMatrix.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.covarianceMatrix.length; i++)
                writer.float(message.covarianceMatrix[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.Covariance
 */
export const Covariance = new Covariance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.mocap.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VisionPositionEstimate$Type extends MessageType<VisionPositionEstimate> {
    constructor() {
        super("mavsdk.rpc.mocap.VisionPositionEstimate", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "position_body", kind: "message", T: () => PositionBody },
            { no: 3, name: "angle_body", kind: "message", T: () => AngleBody },
            { no: 4, name: "pose_covariance", kind: "message", T: () => Covariance }
        ]);
    }
    create(value?: PartialMessage<VisionPositionEstimate>): VisionPositionEstimate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        if (value !== undefined)
            reflectionMergePartial<VisionPositionEstimate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VisionPositionEstimate): VisionPositionEstimate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* mavsdk.rpc.mocap.PositionBody position_body */ 2:
                    message.positionBody = PositionBody.internalBinaryRead(reader, reader.uint32(), options, message.positionBody);
                    break;
                case /* mavsdk.rpc.mocap.AngleBody angle_body */ 3:
                    message.angleBody = AngleBody.internalBinaryRead(reader, reader.uint32(), options, message.angleBody);
                    break;
                case /* mavsdk.rpc.mocap.Covariance pose_covariance */ 4:
                    message.poseCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.poseCovariance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VisionPositionEstimate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* mavsdk.rpc.mocap.PositionBody position_body = 2; */
        if (message.positionBody)
            PositionBody.internalBinaryWrite(message.positionBody, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.AngleBody angle_body = 3; */
        if (message.angleBody)
            AngleBody.internalBinaryWrite(message.angleBody, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.Covariance pose_covariance = 4; */
        if (message.poseCovariance)
            Covariance.internalBinaryWrite(message.poseCovariance, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.VisionPositionEstimate
 */
export const VisionPositionEstimate = new VisionPositionEstimate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttitudePositionMocap$Type extends MessageType<AttitudePositionMocap> {
    constructor() {
        super("mavsdk.rpc.mocap.AttitudePositionMocap", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "q", kind: "message", T: () => Quaternion },
            { no: 3, name: "position_body", kind: "message", T: () => PositionBody },
            { no: 4, name: "pose_covariance", kind: "message", T: () => Covariance }
        ]);
    }
    create(value?: PartialMessage<AttitudePositionMocap>): AttitudePositionMocap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        if (value !== undefined)
            reflectionMergePartial<AttitudePositionMocap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttitudePositionMocap): AttitudePositionMocap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* mavsdk.rpc.mocap.Quaternion q */ 2:
                    message.q = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.q);
                    break;
                case /* mavsdk.rpc.mocap.PositionBody position_body */ 3:
                    message.positionBody = PositionBody.internalBinaryRead(reader, reader.uint32(), options, message.positionBody);
                    break;
                case /* mavsdk.rpc.mocap.Covariance pose_covariance */ 4:
                    message.poseCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.poseCovariance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttitudePositionMocap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* mavsdk.rpc.mocap.Quaternion q = 2; */
        if (message.q)
            Quaternion.internalBinaryWrite(message.q, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.PositionBody position_body = 3; */
        if (message.positionBody)
            PositionBody.internalBinaryWrite(message.positionBody, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.Covariance pose_covariance = 4; */
        if (message.poseCovariance)
            Covariance.internalBinaryWrite(message.poseCovariance, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.AttitudePositionMocap
 */
export const AttitudePositionMocap = new AttitudePositionMocap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Odometry$Type extends MessageType<Odometry> {
    constructor() {
        super("mavsdk.rpc.mocap.Odometry", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "frame_id", kind: "enum", T: () => ["mavsdk.rpc.mocap.Odometry.MavFrame", Odometry_MavFrame, "MAV_FRAME_"] },
            { no: 3, name: "position_body", kind: "message", T: () => PositionBody },
            { no: 4, name: "q", kind: "message", T: () => Quaternion },
            { no: 5, name: "speed_body", kind: "message", T: () => SpeedBody },
            { no: 6, name: "angular_velocity_body", kind: "message", T: () => AngularVelocityBody },
            { no: 7, name: "pose_covariance", kind: "message", T: () => Covariance },
            { no: 8, name: "velocity_covariance", kind: "message", T: () => Covariance }
        ]);
    }
    create(value?: PartialMessage<Odometry>): Odometry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        message.frameId = 0;
        if (value !== undefined)
            reflectionMergePartial<Odometry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Odometry): Odometry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* mavsdk.rpc.mocap.Odometry.MavFrame frame_id */ 2:
                    message.frameId = reader.int32();
                    break;
                case /* mavsdk.rpc.mocap.PositionBody position_body */ 3:
                    message.positionBody = PositionBody.internalBinaryRead(reader, reader.uint32(), options, message.positionBody);
                    break;
                case /* mavsdk.rpc.mocap.Quaternion q */ 4:
                    message.q = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.q);
                    break;
                case /* mavsdk.rpc.mocap.SpeedBody speed_body */ 5:
                    message.speedBody = SpeedBody.internalBinaryRead(reader, reader.uint32(), options, message.speedBody);
                    break;
                case /* mavsdk.rpc.mocap.AngularVelocityBody angular_velocity_body */ 6:
                    message.angularVelocityBody = AngularVelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocityBody);
                    break;
                case /* mavsdk.rpc.mocap.Covariance pose_covariance */ 7:
                    message.poseCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.poseCovariance);
                    break;
                case /* mavsdk.rpc.mocap.Covariance velocity_covariance */ 8:
                    message.velocityCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.velocityCovariance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Odometry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* mavsdk.rpc.mocap.Odometry.MavFrame frame_id = 2; */
        if (message.frameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.frameId);
        /* mavsdk.rpc.mocap.PositionBody position_body = 3; */
        if (message.positionBody)
            PositionBody.internalBinaryWrite(message.positionBody, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.Quaternion q = 4; */
        if (message.q)
            Quaternion.internalBinaryWrite(message.q, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.SpeedBody speed_body = 5; */
        if (message.speedBody)
            SpeedBody.internalBinaryWrite(message.speedBody, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.AngularVelocityBody angular_velocity_body = 6; */
        if (message.angularVelocityBody)
            AngularVelocityBody.internalBinaryWrite(message.angularVelocityBody, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.Covariance pose_covariance = 7; */
        if (message.poseCovariance)
            Covariance.internalBinaryWrite(message.poseCovariance, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.mocap.Covariance velocity_covariance = 8; */
        if (message.velocityCovariance)
            Covariance.internalBinaryWrite(message.velocityCovariance, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.Odometry
 */
export const Odometry = new Odometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MocapResult$Type extends MessageType<MocapResult> {
    constructor() {
        super("mavsdk.rpc.mocap.MocapResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.mocap.MocapResult.Result", MocapResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MocapResult>): MocapResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<MocapResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MocapResult): MocapResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.mocap.MocapResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MocapResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.mocap.MocapResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.mocap.MocapResult
 */
export const MocapResult = new MocapResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.mocap.MocapService
 */
export const MocapService = new ServiceType("mavsdk.rpc.mocap.MocapService", [
    { name: "SetVisionPositionEstimate", options: { "mavsdk.options.async_type": "SYNC" }, I: SetVisionPositionEstimateRequest, O: SetVisionPositionEstimateResponse },
    { name: "SetAttitudePositionMocap", options: { "mavsdk.options.async_type": "SYNC" }, I: SetAttitudePositionMocapRequest, O: SetAttitudePositionMocapResponse },
    { name: "SetOdometry", options: { "mavsdk.options.async_type": "SYNC" }, I: SetOdometryRequest, O: SetOdometryResponse }
]);
