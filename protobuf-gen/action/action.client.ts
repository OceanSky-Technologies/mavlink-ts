/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "action/action.proto" (package "mavsdk.rpc.action", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ActionService } from "./action";
import type { SetCurrentSpeedResponse } from "./action";
import type { SetCurrentSpeedRequest } from "./action";
import type { SetReturnToLaunchAltitudeResponse } from "./action";
import type { SetReturnToLaunchAltitudeRequest } from "./action";
import type { GetReturnToLaunchAltitudeResponse } from "./action";
import type { GetReturnToLaunchAltitudeRequest } from "./action";
import type { SetMaximumSpeedResponse } from "./action";
import type { SetMaximumSpeedRequest } from "./action";
import type { GetMaximumSpeedResponse } from "./action";
import type { GetMaximumSpeedRequest } from "./action";
import type { SetTakeoffAltitudeResponse } from "./action";
import type { SetTakeoffAltitudeRequest } from "./action";
import type { GetTakeoffAltitudeResponse } from "./action";
import type { GetTakeoffAltitudeRequest } from "./action";
import type { TransitionToMulticopterResponse } from "./action";
import type { TransitionToMulticopterRequest } from "./action";
import type { TransitionToFixedwingResponse } from "./action";
import type { TransitionToFixedwingRequest } from "./action";
import type { SetActuatorResponse } from "./action";
import type { SetActuatorRequest } from "./action";
import type { HoldResponse } from "./action";
import type { HoldRequest } from "./action";
import type { DoOrbitResponse } from "./action";
import type { DoOrbitRequest } from "./action";
import type { GotoLocationResponse } from "./action";
import type { GotoLocationRequest } from "./action";
import type { ReturnToLaunchResponse } from "./action";
import type { ReturnToLaunchRequest } from "./action";
import type { KillResponse } from "./action";
import type { KillRequest } from "./action";
import type { TerminateResponse } from "./action";
import type { TerminateRequest } from "./action";
import type { ShutdownResponse } from "./action";
import type { ShutdownRequest } from "./action";
import type { RebootResponse } from "./action";
import type { RebootRequest } from "./action";
import type { LandResponse } from "./action";
import type { LandRequest } from "./action";
import type { TakeoffResponse } from "./action";
import type { TakeoffRequest } from "./action";
import type { DisarmResponse } from "./action";
import type { DisarmRequest } from "./action";
import type { ArmForceResponse } from "./action";
import type { ArmForceRequest } from "./action";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ArmResponse } from "./action";
import type { ArmRequest } from "./action";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Enable simple actions such as arming, taking off, and landing.
 *
 * @generated from protobuf service mavsdk.rpc.action.ActionService
 */
export interface IActionServiceClient {
    /**
     *
     * Send command to arm the drone.
     *
     * Arming a drone normally causes motors to spin at idle.
     * Before arming take all safety precautions and stand clear of the drone!
     *
     * @generated from protobuf rpc: Arm(mavsdk.rpc.action.ArmRequest) returns (mavsdk.rpc.action.ArmResponse);
     */
    arm(input: ArmRequest, options?: RpcOptions): UnaryCall<ArmRequest, ArmResponse>;
    /**
     *
     * Send command to force-arm the drone without any checks.
     *
     * Attention: this is not to be used for normal flying but only bench tests!
     *
     * Arming a drone normally causes motors to spin at idle.
     * Before arming take all safety precautions and stand clear of the drone!
     *
     * @generated from protobuf rpc: ArmForce(mavsdk.rpc.action.ArmForceRequest) returns (mavsdk.rpc.action.ArmForceResponse);
     */
    armForce(input: ArmForceRequest, options?: RpcOptions): UnaryCall<ArmForceRequest, ArmForceResponse>;
    /**
     *
     * Send command to disarm the drone.
     *
     * This will disarm a drone that considers itself landed. If flying, the drone should
     * reject the disarm command. Disarming means that all motors will stop.
     *
     * @generated from protobuf rpc: Disarm(mavsdk.rpc.action.DisarmRequest) returns (mavsdk.rpc.action.DisarmResponse);
     */
    disarm(input: DisarmRequest, options?: RpcOptions): UnaryCall<DisarmRequest, DisarmResponse>;
    /**
     *
     * Send command to take off and hover.
     *
     * This switches the drone into position control mode and commands
     * it to take off and hover at the takeoff altitude.
     *
     * Note that the vehicle must be armed before it can take off.
     *
     * @generated from protobuf rpc: Takeoff(mavsdk.rpc.action.TakeoffRequest) returns (mavsdk.rpc.action.TakeoffResponse);
     */
    takeoff(input: TakeoffRequest, options?: RpcOptions): UnaryCall<TakeoffRequest, TakeoffResponse>;
    /**
     *
     * Send command to land at the current position.
     *
     * This switches the drone to 'Land' flight mode.
     *
     * @generated from protobuf rpc: Land(mavsdk.rpc.action.LandRequest) returns (mavsdk.rpc.action.LandResponse);
     */
    land(input: LandRequest, options?: RpcOptions): UnaryCall<LandRequest, LandResponse>;
    /**
     *
     * Send command to reboot the drone components.
     *
     * This will reboot the autopilot, companion computer, camera and gimbal.
     *
     * @generated from protobuf rpc: Reboot(mavsdk.rpc.action.RebootRequest) returns (mavsdk.rpc.action.RebootResponse);
     */
    reboot(input: RebootRequest, options?: RpcOptions): UnaryCall<RebootRequest, RebootResponse>;
    /**
     *
     * Send command to shut down the drone components.
     *
     * This will shut down the autopilot, onboard computer, camera and gimbal.
     * This command should only be used when the autopilot is disarmed and autopilots commonly
     * reject it if they are not already ready to shut down.
     *
     * @generated from protobuf rpc: Shutdown(mavsdk.rpc.action.ShutdownRequest) returns (mavsdk.rpc.action.ShutdownResponse);
     */
    shutdown(input: ShutdownRequest, options?: RpcOptions): UnaryCall<ShutdownRequest, ShutdownResponse>;
    /**
     *
     * Send command to terminate the drone.
     *
     * This will run the terminate routine as configured on the drone (e.g. disarm and open the parachute).
     *
     * @generated from protobuf rpc: Terminate(mavsdk.rpc.action.TerminateRequest) returns (mavsdk.rpc.action.TerminateResponse);
     */
    terminate(input: TerminateRequest, options?: RpcOptions): UnaryCall<TerminateRequest, TerminateResponse>;
    /**
     *
     * Send command to kill the drone.
     *
     * This will disarm a drone irrespective of whether it is landed or flying.
     * Note that the drone will fall out of the sky if this command is used while flying.
     *
     * @generated from protobuf rpc: Kill(mavsdk.rpc.action.KillRequest) returns (mavsdk.rpc.action.KillResponse);
     */
    kill(input: KillRequest, options?: RpcOptions): UnaryCall<KillRequest, KillResponse>;
    /**
     *
     * Send command to return to the launch (takeoff) position and land.
     *
     * This switches the drone into [Return mode](https://docs.px4.io/master/en/flight_modes/return.html) which
     * generally means it will rise up to a certain altitude to clear any obstacles before heading
     * back to the launch (takeoff) position and land there.
     *
     * @generated from protobuf rpc: ReturnToLaunch(mavsdk.rpc.action.ReturnToLaunchRequest) returns (mavsdk.rpc.action.ReturnToLaunchResponse);
     */
    returnToLaunch(input: ReturnToLaunchRequest, options?: RpcOptions): UnaryCall<ReturnToLaunchRequest, ReturnToLaunchResponse>;
    /**
     *
     * Send command to move the vehicle to a specific global position.
     *
     * The latitude and longitude are given in degrees (WGS84 frame) and the altitude
     * in meters AMSL (above mean sea level).
     *
     * The yaw angle is in degrees (frame is NED, 0 is North, positive is clockwise).
     *
     * @generated from protobuf rpc: GotoLocation(mavsdk.rpc.action.GotoLocationRequest) returns (mavsdk.rpc.action.GotoLocationResponse);
     */
    gotoLocation(input: GotoLocationRequest, options?: RpcOptions): UnaryCall<GotoLocationRequest, GotoLocationResponse>;
    /**
     *
     * Send command do orbit to the drone.
     *
     * This will run the orbit routine with the given parameters.
     *
     * @generated from protobuf rpc: DoOrbit(mavsdk.rpc.action.DoOrbitRequest) returns (mavsdk.rpc.action.DoOrbitResponse);
     */
    doOrbit(input: DoOrbitRequest, options?: RpcOptions): UnaryCall<DoOrbitRequest, DoOrbitResponse>;
    /**
     *
     * Send command to hold position (a.k.a. "Loiter").
     *
     * Sends a command to drone to change to Hold flight mode, causing the
     * vehicle to stop and maintain its current GPS position and altitude.
     *
     * Note: this command is specific to the PX4 Autopilot flight stack as
     * it implies a change to a PX4-specific mode.
     *
     * @generated from protobuf rpc: Hold(mavsdk.rpc.action.HoldRequest) returns (mavsdk.rpc.action.HoldResponse);
     */
    hold(input: HoldRequest, options?: RpcOptions): UnaryCall<HoldRequest, HoldResponse>;
    /**
     *
     * Send command to set the value of an actuator.
     *
     * Note that the index of the actuator starts at 1 and that the value goes from -1 to 1.
     *
     * @generated from protobuf rpc: SetActuator(mavsdk.rpc.action.SetActuatorRequest) returns (mavsdk.rpc.action.SetActuatorResponse);
     */
    setActuator(input: SetActuatorRequest, options?: RpcOptions): UnaryCall<SetActuatorRequest, SetActuatorResponse>;
    /**
     *
     * Send command to transition the drone to fixedwing.
     *
     * The associated action will only be executed for VTOL vehicles (on other vehicle types the
     * command will fail). The command will succeed if called when the vehicle
     * is already in fixedwing mode.
     *
     * @generated from protobuf rpc: TransitionToFixedwing(mavsdk.rpc.action.TransitionToFixedwingRequest) returns (mavsdk.rpc.action.TransitionToFixedwingResponse);
     */
    transitionToFixedwing(input: TransitionToFixedwingRequest, options?: RpcOptions): UnaryCall<TransitionToFixedwingRequest, TransitionToFixedwingResponse>;
    /**
     *
     * Send command to transition the drone to multicopter.
     *
     * The associated action will only be executed for VTOL vehicles (on other vehicle types the
     * command will fail). The command will succeed if called when the vehicle
     * is already in multicopter mode.
     *
     * @generated from protobuf rpc: TransitionToMulticopter(mavsdk.rpc.action.TransitionToMulticopterRequest) returns (mavsdk.rpc.action.TransitionToMulticopterResponse);
     */
    transitionToMulticopter(input: TransitionToMulticopterRequest, options?: RpcOptions): UnaryCall<TransitionToMulticopterRequest, TransitionToMulticopterResponse>;
    /**
     *
     * Get the takeoff altitude (in meters above ground).
     *
     * @generated from protobuf rpc: GetTakeoffAltitude(mavsdk.rpc.action.GetTakeoffAltitudeRequest) returns (mavsdk.rpc.action.GetTakeoffAltitudeResponse);
     */
    getTakeoffAltitude(input: GetTakeoffAltitudeRequest, options?: RpcOptions): UnaryCall<GetTakeoffAltitudeRequest, GetTakeoffAltitudeResponse>;
    /**
     *
     * Set takeoff altitude (in meters above ground).
     *
     * @generated from protobuf rpc: SetTakeoffAltitude(mavsdk.rpc.action.SetTakeoffAltitudeRequest) returns (mavsdk.rpc.action.SetTakeoffAltitudeResponse);
     */
    setTakeoffAltitude(input: SetTakeoffAltitudeRequest, options?: RpcOptions): UnaryCall<SetTakeoffAltitudeRequest, SetTakeoffAltitudeResponse>;
    /**
     *
     * Get the vehicle maximum speed (in metres/second).
     *
     * @generated from protobuf rpc: GetMaximumSpeed(mavsdk.rpc.action.GetMaximumSpeedRequest) returns (mavsdk.rpc.action.GetMaximumSpeedResponse);
     */
    getMaximumSpeed(input: GetMaximumSpeedRequest, options?: RpcOptions): UnaryCall<GetMaximumSpeedRequest, GetMaximumSpeedResponse>;
    /**
     *
     * Set vehicle maximum speed (in metres/second).
     *
     * @generated from protobuf rpc: SetMaximumSpeed(mavsdk.rpc.action.SetMaximumSpeedRequest) returns (mavsdk.rpc.action.SetMaximumSpeedResponse);
     */
    setMaximumSpeed(input: SetMaximumSpeedRequest, options?: RpcOptions): UnaryCall<SetMaximumSpeedRequest, SetMaximumSpeedResponse>;
    /**
     *
     * Get the return to launch minimum return altitude (in meters).
     *
     * @generated from protobuf rpc: GetReturnToLaunchAltitude(mavsdk.rpc.action.GetReturnToLaunchAltitudeRequest) returns (mavsdk.rpc.action.GetReturnToLaunchAltitudeResponse);
     */
    getReturnToLaunchAltitude(input: GetReturnToLaunchAltitudeRequest, options?: RpcOptions): UnaryCall<GetReturnToLaunchAltitudeRequest, GetReturnToLaunchAltitudeResponse>;
    /**
     *
     * Set the return to launch minimum return altitude (in meters).
     *
     * @generated from protobuf rpc: SetReturnToLaunchAltitude(mavsdk.rpc.action.SetReturnToLaunchAltitudeRequest) returns (mavsdk.rpc.action.SetReturnToLaunchAltitudeResponse);
     */
    setReturnToLaunchAltitude(input: SetReturnToLaunchAltitudeRequest, options?: RpcOptions): UnaryCall<SetReturnToLaunchAltitudeRequest, SetReturnToLaunchAltitudeResponse>;
    /**
     *
     * Set current speed.
     *
     * This will set the speed during a mission, reposition, and similar.
     * It is ephemeral, so not stored on the drone and does not survive a reboot.
     *
     * @generated from protobuf rpc: SetCurrentSpeed(mavsdk.rpc.action.SetCurrentSpeedRequest) returns (mavsdk.rpc.action.SetCurrentSpeedResponse);
     */
    setCurrentSpeed(input: SetCurrentSpeedRequest, options?: RpcOptions): UnaryCall<SetCurrentSpeedRequest, SetCurrentSpeedResponse>;
}
/**
 * Enable simple actions such as arming, taking off, and landing.
 *
 * @generated from protobuf service mavsdk.rpc.action.ActionService
 */
export class ActionServiceClient implements IActionServiceClient, ServiceInfo {
    typeName = ActionService.typeName;
    methods = ActionService.methods;
    options = ActionService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     *
     * Send command to arm the drone.
     *
     * Arming a drone normally causes motors to spin at idle.
     * Before arming take all safety precautions and stand clear of the drone!
     *
     * @generated from protobuf rpc: Arm(mavsdk.rpc.action.ArmRequest) returns (mavsdk.rpc.action.ArmResponse);
     */
    arm(input: ArmRequest, options?: RpcOptions): UnaryCall<ArmRequest, ArmResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ArmRequest, ArmResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to force-arm the drone without any checks.
     *
     * Attention: this is not to be used for normal flying but only bench tests!
     *
     * Arming a drone normally causes motors to spin at idle.
     * Before arming take all safety precautions and stand clear of the drone!
     *
     * @generated from protobuf rpc: ArmForce(mavsdk.rpc.action.ArmForceRequest) returns (mavsdk.rpc.action.ArmForceResponse);
     */
    armForce(input: ArmForceRequest, options?: RpcOptions): UnaryCall<ArmForceRequest, ArmForceResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<ArmForceRequest, ArmForceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to disarm the drone.
     *
     * This will disarm a drone that considers itself landed. If flying, the drone should
     * reject the disarm command. Disarming means that all motors will stop.
     *
     * @generated from protobuf rpc: Disarm(mavsdk.rpc.action.DisarmRequest) returns (mavsdk.rpc.action.DisarmResponse);
     */
    disarm(input: DisarmRequest, options?: RpcOptions): UnaryCall<DisarmRequest, DisarmResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<DisarmRequest, DisarmResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to take off and hover.
     *
     * This switches the drone into position control mode and commands
     * it to take off and hover at the takeoff altitude.
     *
     * Note that the vehicle must be armed before it can take off.
     *
     * @generated from protobuf rpc: Takeoff(mavsdk.rpc.action.TakeoffRequest) returns (mavsdk.rpc.action.TakeoffResponse);
     */
    takeoff(input: TakeoffRequest, options?: RpcOptions): UnaryCall<TakeoffRequest, TakeoffResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<TakeoffRequest, TakeoffResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to land at the current position.
     *
     * This switches the drone to 'Land' flight mode.
     *
     * @generated from protobuf rpc: Land(mavsdk.rpc.action.LandRequest) returns (mavsdk.rpc.action.LandResponse);
     */
    land(input: LandRequest, options?: RpcOptions): UnaryCall<LandRequest, LandResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<LandRequest, LandResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to reboot the drone components.
     *
     * This will reboot the autopilot, companion computer, camera and gimbal.
     *
     * @generated from protobuf rpc: Reboot(mavsdk.rpc.action.RebootRequest) returns (mavsdk.rpc.action.RebootResponse);
     */
    reboot(input: RebootRequest, options?: RpcOptions): UnaryCall<RebootRequest, RebootResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<RebootRequest, RebootResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to shut down the drone components.
     *
     * This will shut down the autopilot, onboard computer, camera and gimbal.
     * This command should only be used when the autopilot is disarmed and autopilots commonly
     * reject it if they are not already ready to shut down.
     *
     * @generated from protobuf rpc: Shutdown(mavsdk.rpc.action.ShutdownRequest) returns (mavsdk.rpc.action.ShutdownResponse);
     */
    shutdown(input: ShutdownRequest, options?: RpcOptions): UnaryCall<ShutdownRequest, ShutdownResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<ShutdownRequest, ShutdownResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to terminate the drone.
     *
     * This will run the terminate routine as configured on the drone (e.g. disarm and open the parachute).
     *
     * @generated from protobuf rpc: Terminate(mavsdk.rpc.action.TerminateRequest) returns (mavsdk.rpc.action.TerminateResponse);
     */
    terminate(input: TerminateRequest, options?: RpcOptions): UnaryCall<TerminateRequest, TerminateResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<TerminateRequest, TerminateResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to kill the drone.
     *
     * This will disarm a drone irrespective of whether it is landed or flying.
     * Note that the drone will fall out of the sky if this command is used while flying.
     *
     * @generated from protobuf rpc: Kill(mavsdk.rpc.action.KillRequest) returns (mavsdk.rpc.action.KillResponse);
     */
    kill(input: KillRequest, options?: RpcOptions): UnaryCall<KillRequest, KillResponse> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<KillRequest, KillResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to return to the launch (takeoff) position and land.
     *
     * This switches the drone into [Return mode](https://docs.px4.io/master/en/flight_modes/return.html) which
     * generally means it will rise up to a certain altitude to clear any obstacles before heading
     * back to the launch (takeoff) position and land there.
     *
     * @generated from protobuf rpc: ReturnToLaunch(mavsdk.rpc.action.ReturnToLaunchRequest) returns (mavsdk.rpc.action.ReturnToLaunchResponse);
     */
    returnToLaunch(input: ReturnToLaunchRequest, options?: RpcOptions): UnaryCall<ReturnToLaunchRequest, ReturnToLaunchResponse> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<ReturnToLaunchRequest, ReturnToLaunchResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to move the vehicle to a specific global position.
     *
     * The latitude and longitude are given in degrees (WGS84 frame) and the altitude
     * in meters AMSL (above mean sea level).
     *
     * The yaw angle is in degrees (frame is NED, 0 is North, positive is clockwise).
     *
     * @generated from protobuf rpc: GotoLocation(mavsdk.rpc.action.GotoLocationRequest) returns (mavsdk.rpc.action.GotoLocationResponse);
     */
    gotoLocation(input: GotoLocationRequest, options?: RpcOptions): UnaryCall<GotoLocationRequest, GotoLocationResponse> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<GotoLocationRequest, GotoLocationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command do orbit to the drone.
     *
     * This will run the orbit routine with the given parameters.
     *
     * @generated from protobuf rpc: DoOrbit(mavsdk.rpc.action.DoOrbitRequest) returns (mavsdk.rpc.action.DoOrbitResponse);
     */
    doOrbit(input: DoOrbitRequest, options?: RpcOptions): UnaryCall<DoOrbitRequest, DoOrbitResponse> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<DoOrbitRequest, DoOrbitResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to hold position (a.k.a. "Loiter").
     *
     * Sends a command to drone to change to Hold flight mode, causing the
     * vehicle to stop and maintain its current GPS position and altitude.
     *
     * Note: this command is specific to the PX4 Autopilot flight stack as
     * it implies a change to a PX4-specific mode.
     *
     * @generated from protobuf rpc: Hold(mavsdk.rpc.action.HoldRequest) returns (mavsdk.rpc.action.HoldResponse);
     */
    hold(input: HoldRequest, options?: RpcOptions): UnaryCall<HoldRequest, HoldResponse> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<HoldRequest, HoldResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to set the value of an actuator.
     *
     * Note that the index of the actuator starts at 1 and that the value goes from -1 to 1.
     *
     * @generated from protobuf rpc: SetActuator(mavsdk.rpc.action.SetActuatorRequest) returns (mavsdk.rpc.action.SetActuatorResponse);
     */
    setActuator(input: SetActuatorRequest, options?: RpcOptions): UnaryCall<SetActuatorRequest, SetActuatorResponse> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetActuatorRequest, SetActuatorResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to transition the drone to fixedwing.
     *
     * The associated action will only be executed for VTOL vehicles (on other vehicle types the
     * command will fail). The command will succeed if called when the vehicle
     * is already in fixedwing mode.
     *
     * @generated from protobuf rpc: TransitionToFixedwing(mavsdk.rpc.action.TransitionToFixedwingRequest) returns (mavsdk.rpc.action.TransitionToFixedwingResponse);
     */
    transitionToFixedwing(input: TransitionToFixedwingRequest, options?: RpcOptions): UnaryCall<TransitionToFixedwingRequest, TransitionToFixedwingResponse> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransitionToFixedwingRequest, TransitionToFixedwingResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Send command to transition the drone to multicopter.
     *
     * The associated action will only be executed for VTOL vehicles (on other vehicle types the
     * command will fail). The command will succeed if called when the vehicle
     * is already in multicopter mode.
     *
     * @generated from protobuf rpc: TransitionToMulticopter(mavsdk.rpc.action.TransitionToMulticopterRequest) returns (mavsdk.rpc.action.TransitionToMulticopterResponse);
     */
    transitionToMulticopter(input: TransitionToMulticopterRequest, options?: RpcOptions): UnaryCall<TransitionToMulticopterRequest, TransitionToMulticopterResponse> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransitionToMulticopterRequest, TransitionToMulticopterResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Get the takeoff altitude (in meters above ground).
     *
     * @generated from protobuf rpc: GetTakeoffAltitude(mavsdk.rpc.action.GetTakeoffAltitudeRequest) returns (mavsdk.rpc.action.GetTakeoffAltitudeResponse);
     */
    getTakeoffAltitude(input: GetTakeoffAltitudeRequest, options?: RpcOptions): UnaryCall<GetTakeoffAltitudeRequest, GetTakeoffAltitudeResponse> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetTakeoffAltitudeRequest, GetTakeoffAltitudeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Set takeoff altitude (in meters above ground).
     *
     * @generated from protobuf rpc: SetTakeoffAltitude(mavsdk.rpc.action.SetTakeoffAltitudeRequest) returns (mavsdk.rpc.action.SetTakeoffAltitudeResponse);
     */
    setTakeoffAltitude(input: SetTakeoffAltitudeRequest, options?: RpcOptions): UnaryCall<SetTakeoffAltitudeRequest, SetTakeoffAltitudeResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetTakeoffAltitudeRequest, SetTakeoffAltitudeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Get the vehicle maximum speed (in metres/second).
     *
     * @generated from protobuf rpc: GetMaximumSpeed(mavsdk.rpc.action.GetMaximumSpeedRequest) returns (mavsdk.rpc.action.GetMaximumSpeedResponse);
     */
    getMaximumSpeed(input: GetMaximumSpeedRequest, options?: RpcOptions): UnaryCall<GetMaximumSpeedRequest, GetMaximumSpeedResponse> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetMaximumSpeedRequest, GetMaximumSpeedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Set vehicle maximum speed (in metres/second).
     *
     * @generated from protobuf rpc: SetMaximumSpeed(mavsdk.rpc.action.SetMaximumSpeedRequest) returns (mavsdk.rpc.action.SetMaximumSpeedResponse);
     */
    setMaximumSpeed(input: SetMaximumSpeedRequest, options?: RpcOptions): UnaryCall<SetMaximumSpeedRequest, SetMaximumSpeedResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetMaximumSpeedRequest, SetMaximumSpeedResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Get the return to launch minimum return altitude (in meters).
     *
     * @generated from protobuf rpc: GetReturnToLaunchAltitude(mavsdk.rpc.action.GetReturnToLaunchAltitudeRequest) returns (mavsdk.rpc.action.GetReturnToLaunchAltitudeResponse);
     */
    getReturnToLaunchAltitude(input: GetReturnToLaunchAltitudeRequest, options?: RpcOptions): UnaryCall<GetReturnToLaunchAltitudeRequest, GetReturnToLaunchAltitudeResponse> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetReturnToLaunchAltitudeRequest, GetReturnToLaunchAltitudeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Set the return to launch minimum return altitude (in meters).
     *
     * @generated from protobuf rpc: SetReturnToLaunchAltitude(mavsdk.rpc.action.SetReturnToLaunchAltitudeRequest) returns (mavsdk.rpc.action.SetReturnToLaunchAltitudeResponse);
     */
    setReturnToLaunchAltitude(input: SetReturnToLaunchAltitudeRequest, options?: RpcOptions): UnaryCall<SetReturnToLaunchAltitudeRequest, SetReturnToLaunchAltitudeResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetReturnToLaunchAltitudeRequest, SetReturnToLaunchAltitudeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     *
     * Set current speed.
     *
     * This will set the speed during a mission, reposition, and similar.
     * It is ephemeral, so not stored on the drone and does not survive a reboot.
     *
     * @generated from protobuf rpc: SetCurrentSpeed(mavsdk.rpc.action.SetCurrentSpeedRequest) returns (mavsdk.rpc.action.SetCurrentSpeedResponse);
     */
    setCurrentSpeed(input: SetCurrentSpeedRequest, options?: RpcOptions): UnaryCall<SetCurrentSpeedRequest, SetCurrentSpeedResponse> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<SetCurrentSpeedRequest, SetCurrentSpeedResponse>("unary", this._transport, method, opt, input);
    }
}
