/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "events/events.proto" (package "mavsdk.rpc.events", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.events.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: uint32 compid = 1;
     */
    compid: number; // The source component ID of the event
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string; // Short, single-line message
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string; // Detailed description (optional, might be multiple lines)
    /**
     * @generated from protobuf field: mavsdk.rpc.events.LogLevel log_level = 4;
     */
    logLevel: LogLevel;
    /**
     * @generated from protobuf field: string event_namespace = 5;
     */
    eventNamespace: string; // Namespace, e.g. "px4"
    /**
     * @generated from protobuf field: string event_name = 6;
     */
    eventName: string; // Event name (unique within the namespace)
}
/**
 * @generated from protobuf message mavsdk.rpc.events.HealthAndArmingCheckProblem
 */
export interface HealthAndArmingCheckProblem {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string; // Short, single-line message
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string; // Detailed description (optional, might be multiple lines)
    /**
     * @generated from protobuf field: mavsdk.rpc.events.LogLevel log_level = 3;
     */
    logLevel: LogLevel;
    /**
     * @generated from protobuf field: string health_component = 4;
     */
    healthComponent: string; // Associated health component, e.g. "gps"
}
/**
 * Arming checks for a specific mode
 *
 * @generated from protobuf message mavsdk.rpc.events.HealthAndArmingCheckMode
 */
export interface HealthAndArmingCheckMode {
    /**
     * @generated from protobuf field: string mode_name = 1;
     */
    modeName: string; // Mode name, e.g. "Position"
    /**
     * @generated from protobuf field: bool can_arm_or_run = 2;
     */
    canArmOrRun: boolean; // If disarmed: indicates if arming is possible. If armed: indicates if the mode can be selected
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3;
     */
    problems: HealthAndArmingCheckProblem[]; // List of reported problems for the mode
}
/**
 * @generated from protobuf message mavsdk.rpc.events.HealthComponentReport
 */
export interface HealthComponentReport {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string; // Unique component name, e.g. "gps"
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string; // Human readable label of the component, e.g. "GPS" or "Accelerometer"
    /**
     * @generated from protobuf field: bool is_present = 3;
     */
    isPresent: boolean; // If the component is present
    /**
     * @generated from protobuf field: bool has_error = 4;
     */
    hasError: boolean; // If the component has errors
    /**
     * @generated from protobuf field: bool has_warning = 5;
     */
    hasWarning: boolean; // If the component has warnings
}
/**
 * @generated from protobuf message mavsdk.rpc.events.HealthAndArmingCheckReport
 */
export interface HealthAndArmingCheckReport {
    /**
     * @generated from protobuf field: mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1;
     */
    currentModeIntention?: HealthAndArmingCheckMode; // Report for currently intended mode
    // TODO: we can add reports for different modes here too (e.g. Takeoff or Mission)

    /**
     * @generated from protobuf field: repeated mavsdk.rpc.events.HealthComponentReport health_components = 2;
     */
    healthComponents: HealthComponentReport[]; // Health components list (e.g. for "gps")
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3;
     */
    allProblems: HealthAndArmingCheckProblem[]; // Complete list of problems
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.events.EventsResult
 */
export interface EventsResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.events.EventsResult.Result result = 1;
     */
    result: EventsResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * @generated from protobuf enum mavsdk.rpc.events.EventsResult.Result
 */
export enum EventsResult_Result {
    /**
     * @generated from protobuf enum value: RESULT_SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: RESULT_NOT_AVAILABLE = 1;
     */
    NOT_AVAILABLE = 1,
    /**
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 2;
     */
    CONNECTION_ERROR = 2,
    /**
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 3;
     */
    UNSUPPORTED = 3,
    /**
     * @generated from protobuf enum value: RESULT_DENIED = 4;
     */
    DENIED = 4,
    /**
     * @generated from protobuf enum value: RESULT_FAILED = 5;
     */
    FAILED = 5,
    /**
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 7;
     */
    NO_SYSTEM = 7
}
/**
 * @generated from protobuf message mavsdk.rpc.events.SubscribeEventsRequest
 */
export interface SubscribeEventsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.events.EventsResponse
 */
export interface EventsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.events.Event event = 1;
     */
    event?: Event;
}
/**
 * @generated from protobuf message mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest
 */
export interface SubscribeHealthAndArmingChecksRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.events.HealthAndArmingChecksResponse
 */
export interface HealthAndArmingChecksResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.events.HealthAndArmingCheckReport report = 1;
     */
    report?: HealthAndArmingCheckReport;
}
/**
 * @generated from protobuf message mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest
 */
export interface GetHealthAndArmingChecksReportRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse
 */
export interface GetHealthAndArmingChecksReportResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.events.EventsResult events_result = 1;
     */
    eventsResult?: EventsResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.events.HealthAndArmingCheckReport report = 2;
     */
    report?: HealthAndArmingCheckReport;
}
/**
 * @generated from protobuf enum mavsdk.rpc.events.LogLevel
 */
export enum LogLevel {
    /**
     * @generated from protobuf enum value: LOG_LEVEL_EMERGENCY = 0;
     */
    EMERGENCY = 0,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_ALERT = 1;
     */
    ALERT = 1,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_CRITICAL = 2;
     */
    CRITICAL = 2,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_ERROR = 3;
     */
    ERROR = 3,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_WARNING = 4;
     */
    WARNING = 4,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_NOTICE = 5;
     */
    NOTICE = 5,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_INFO = 6;
     */
    INFO = 6,
    /**
     * @generated from protobuf enum value: LOG_LEVEL_DEBUG = 7;
     */
    DEBUG = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("mavsdk.rpc.events.Event", [
            { no: 1, name: "compid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "log_level", kind: "enum", T: () => ["mavsdk.rpc.events.LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 5, name: "event_namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "event_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compid = 0;
        message.message = "";
        message.description = "";
        message.logLevel = 0;
        message.eventNamespace = "";
        message.eventName = "";
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 compid */ 1:
                    message.compid = reader.uint32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* mavsdk.rpc.events.LogLevel log_level */ 4:
                    message.logLevel = reader.int32();
                    break;
                case /* string event_namespace */ 5:
                    message.eventNamespace = reader.string();
                    break;
                case /* string event_name */ 6:
                    message.eventName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 compid = 1; */
        if (message.compid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.compid);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* mavsdk.rpc.events.LogLevel log_level = 4; */
        if (message.logLevel !== 0)
            writer.tag(4, WireType.Varint).int32(message.logLevel);
        /* string event_namespace = 5; */
        if (message.eventNamespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.eventNamespace);
        /* string event_name = 6; */
        if (message.eventName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.eventName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthAndArmingCheckProblem$Type extends MessageType<HealthAndArmingCheckProblem> {
    constructor() {
        super("mavsdk.rpc.events.HealthAndArmingCheckProblem", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "log_level", kind: "enum", T: () => ["mavsdk.rpc.events.LogLevel", LogLevel, "LOG_LEVEL_"] },
            { no: 4, name: "health_component", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HealthAndArmingCheckProblem>): HealthAndArmingCheckProblem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        message.description = "";
        message.logLevel = 0;
        message.healthComponent = "";
        if (value !== undefined)
            reflectionMergePartial<HealthAndArmingCheckProblem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthAndArmingCheckProblem): HealthAndArmingCheckProblem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* mavsdk.rpc.events.LogLevel log_level */ 3:
                    message.logLevel = reader.int32();
                    break;
                case /* string health_component */ 4:
                    message.healthComponent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthAndArmingCheckProblem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* mavsdk.rpc.events.LogLevel log_level = 3; */
        if (message.logLevel !== 0)
            writer.tag(3, WireType.Varint).int32(message.logLevel);
        /* string health_component = 4; */
        if (message.healthComponent !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.healthComponent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.HealthAndArmingCheckProblem
 */
export const HealthAndArmingCheckProblem = new HealthAndArmingCheckProblem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthAndArmingCheckMode$Type extends MessageType<HealthAndArmingCheckMode> {
    constructor() {
        super("mavsdk.rpc.events.HealthAndArmingCheckMode", [
            { no: 1, name: "mode_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "can_arm_or_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "problems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthAndArmingCheckProblem }
        ]);
    }
    create(value?: PartialMessage<HealthAndArmingCheckMode>): HealthAndArmingCheckMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.modeName = "";
        message.canArmOrRun = false;
        message.problems = [];
        if (value !== undefined)
            reflectionMergePartial<HealthAndArmingCheckMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthAndArmingCheckMode): HealthAndArmingCheckMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mode_name */ 1:
                    message.modeName = reader.string();
                    break;
                case /* bool can_arm_or_run */ 2:
                    message.canArmOrRun = reader.bool();
                    break;
                case /* repeated mavsdk.rpc.events.HealthAndArmingCheckProblem problems */ 3:
                    message.problems.push(HealthAndArmingCheckProblem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthAndArmingCheckMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mode_name = 1; */
        if (message.modeName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.modeName);
        /* bool can_arm_or_run = 2; */
        if (message.canArmOrRun !== false)
            writer.tag(2, WireType.Varint).bool(message.canArmOrRun);
        /* repeated mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3; */
        for (let i = 0; i < message.problems.length; i++)
            HealthAndArmingCheckProblem.internalBinaryWrite(message.problems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.HealthAndArmingCheckMode
 */
export const HealthAndArmingCheckMode = new HealthAndArmingCheckMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthComponentReport$Type extends MessageType<HealthComponentReport> {
    constructor() {
        super("mavsdk.rpc.events.HealthComponentReport", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_present", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "has_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "has_warning", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HealthComponentReport>): HealthComponentReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.label = "";
        message.isPresent = false;
        message.hasError = false;
        message.hasWarning = false;
        if (value !== undefined)
            reflectionMergePartial<HealthComponentReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthComponentReport): HealthComponentReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                case /* bool is_present */ 3:
                    message.isPresent = reader.bool();
                    break;
                case /* bool has_error */ 4:
                    message.hasError = reader.bool();
                    break;
                case /* bool has_warning */ 5:
                    message.hasWarning = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthComponentReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        /* bool is_present = 3; */
        if (message.isPresent !== false)
            writer.tag(3, WireType.Varint).bool(message.isPresent);
        /* bool has_error = 4; */
        if (message.hasError !== false)
            writer.tag(4, WireType.Varint).bool(message.hasError);
        /* bool has_warning = 5; */
        if (message.hasWarning !== false)
            writer.tag(5, WireType.Varint).bool(message.hasWarning);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.HealthComponentReport
 */
export const HealthComponentReport = new HealthComponentReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthAndArmingCheckReport$Type extends MessageType<HealthAndArmingCheckReport> {
    constructor() {
        super("mavsdk.rpc.events.HealthAndArmingCheckReport", [
            { no: 1, name: "current_mode_intention", kind: "message", T: () => HealthAndArmingCheckMode },
            { no: 2, name: "health_components", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthComponentReport },
            { no: 3, name: "all_problems", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthAndArmingCheckProblem }
        ]);
    }
    create(value?: PartialMessage<HealthAndArmingCheckReport>): HealthAndArmingCheckReport {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthComponents = [];
        message.allProblems = [];
        if (value !== undefined)
            reflectionMergePartial<HealthAndArmingCheckReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthAndArmingCheckReport): HealthAndArmingCheckReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention */ 1:
                    message.currentModeIntention = HealthAndArmingCheckMode.internalBinaryRead(reader, reader.uint32(), options, message.currentModeIntention);
                    break;
                case /* repeated mavsdk.rpc.events.HealthComponentReport health_components */ 2:
                    message.healthComponents.push(HealthComponentReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems */ 3:
                    message.allProblems.push(HealthAndArmingCheckProblem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthAndArmingCheckReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1; */
        if (message.currentModeIntention)
            HealthAndArmingCheckMode.internalBinaryWrite(message.currentModeIntention, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated mavsdk.rpc.events.HealthComponentReport health_components = 2; */
        for (let i = 0; i < message.healthComponents.length; i++)
            HealthComponentReport.internalBinaryWrite(message.healthComponents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3; */
        for (let i = 0; i < message.allProblems.length; i++)
            HealthAndArmingCheckProblem.internalBinaryWrite(message.allProblems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.HealthAndArmingCheckReport
 */
export const HealthAndArmingCheckReport = new HealthAndArmingCheckReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventsResult$Type extends MessageType<EventsResult> {
    constructor() {
        super("mavsdk.rpc.events.EventsResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.events.EventsResult.Result", EventsResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventsResult>): EventsResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<EventsResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventsResult): EventsResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.events.EventsResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventsResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.events.EventsResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.EventsResult
 */
export const EventsResult = new EventsResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor() {
        super("mavsdk.rpc.events.SubscribeEventsRequest", []);
    }
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.SubscribeEventsRequest
 */
export const SubscribeEventsRequest = new SubscribeEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventsResponse$Type extends MessageType<EventsResponse> {
    constructor() {
        super("mavsdk.rpc.events.EventsResponse", [
            { no: 1, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<EventsResponse>): EventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventsResponse): EventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.events.Event event */ 1:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.events.Event event = 1; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.EventsResponse
 */
export const EventsResponse = new EventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHealthAndArmingChecksRequest$Type extends MessageType<SubscribeHealthAndArmingChecksRequest> {
    constructor() {
        super("mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest", []);
    }
    create(value?: PartialMessage<SubscribeHealthAndArmingChecksRequest>): SubscribeHealthAndArmingChecksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeHealthAndArmingChecksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHealthAndArmingChecksRequest): SubscribeHealthAndArmingChecksRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHealthAndArmingChecksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest
 */
export const SubscribeHealthAndArmingChecksRequest = new SubscribeHealthAndArmingChecksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthAndArmingChecksResponse$Type extends MessageType<HealthAndArmingChecksResponse> {
    constructor() {
        super("mavsdk.rpc.events.HealthAndArmingChecksResponse", [
            { no: 1, name: "report", kind: "message", T: () => HealthAndArmingCheckReport }
        ]);
    }
    create(value?: PartialMessage<HealthAndArmingChecksResponse>): HealthAndArmingChecksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthAndArmingChecksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthAndArmingChecksResponse): HealthAndArmingChecksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.events.HealthAndArmingCheckReport report */ 1:
                    message.report = HealthAndArmingCheckReport.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthAndArmingChecksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.events.HealthAndArmingCheckReport report = 1; */
        if (message.report)
            HealthAndArmingCheckReport.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.HealthAndArmingChecksResponse
 */
export const HealthAndArmingChecksResponse = new HealthAndArmingChecksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHealthAndArmingChecksReportRequest$Type extends MessageType<GetHealthAndArmingChecksReportRequest> {
    constructor() {
        super("mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest", []);
    }
    create(value?: PartialMessage<GetHealthAndArmingChecksReportRequest>): GetHealthAndArmingChecksReportRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHealthAndArmingChecksReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHealthAndArmingChecksReportRequest): GetHealthAndArmingChecksReportRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetHealthAndArmingChecksReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest
 */
export const GetHealthAndArmingChecksReportRequest = new GetHealthAndArmingChecksReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetHealthAndArmingChecksReportResponse$Type extends MessageType<GetHealthAndArmingChecksReportResponse> {
    constructor() {
        super("mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse", [
            { no: 1, name: "events_result", kind: "message", T: () => EventsResult },
            { no: 2, name: "report", kind: "message", T: () => HealthAndArmingCheckReport }
        ]);
    }
    create(value?: PartialMessage<GetHealthAndArmingChecksReportResponse>): GetHealthAndArmingChecksReportResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetHealthAndArmingChecksReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetHealthAndArmingChecksReportResponse): GetHealthAndArmingChecksReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.events.EventsResult events_result */ 1:
                    message.eventsResult = EventsResult.internalBinaryRead(reader, reader.uint32(), options, message.eventsResult);
                    break;
                case /* mavsdk.rpc.events.HealthAndArmingCheckReport report */ 2:
                    message.report = HealthAndArmingCheckReport.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetHealthAndArmingChecksReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.events.EventsResult events_result = 1; */
        if (message.eventsResult)
            EventsResult.internalBinaryWrite(message.eventsResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.events.HealthAndArmingCheckReport report = 2; */
        if (message.report)
            HealthAndArmingCheckReport.internalBinaryWrite(message.report, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse
 */
export const GetHealthAndArmingChecksReportResponse = new GetHealthAndArmingChecksReportResponse$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.events.EventsService
 */
export const EventsService = new ServiceType("mavsdk.rpc.events.EventsService", [
    { name: "SubscribeEvents", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeEventsRequest, O: EventsResponse },
    { name: "SubscribeHealthAndArmingChecks", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeHealthAndArmingChecksRequest, O: HealthAndArmingChecksResponse },
    { name: "GetHealthAndArmingChecksReport", options: { "mavsdk.options.async_type": "SYNC" }, I: GetHealthAndArmingChecksReportRequest, O: GetHealthAndArmingChecksReportResponse }
]);
