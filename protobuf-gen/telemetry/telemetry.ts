/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "telemetry/telemetry.proto" (package "mavsdk.rpc.telemetry", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribePositionRequest
 */
export interface SubscribePositionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.PositionResponse
 */
export interface PositionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Position position = 1;
     */
    position?: Position; // The next position
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeHomeRequest
 */
export interface SubscribeHomeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.HomeResponse
 */
export interface HomeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Position home = 1;
     */
    home?: Position; // The next home position
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeInAirRequest
 */
export interface SubscribeInAirRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.InAirResponse
 */
export interface InAirResponse {
    /**
     * @generated from protobuf field: bool is_in_air = 1;
     */
    isInAir: boolean; // The next 'in-air' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeLandedStateRequest
 */
export interface SubscribeLandedStateRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.LandedStateResponse
 */
export interface LandedStateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.LandedState landed_state = 1;
     */
    landedState: LandedState; // The next 'landed' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeArmedRequest
 */
export interface SubscribeArmedRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ArmedResponse
 */
export interface ArmedResponse {
    /**
     * @generated from protobuf field: bool is_armed = 1;
     */
    isArmed: boolean; // The next 'armed' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeVtolStateRequest
 */
export interface SubscribeVtolStateRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.VtolStateResponse
 */
export interface VtolStateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.VtolState vtol_state = 1;
     */
    vtolState: VtolState; // The next 'vtol' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeQuaternionRequest
 */
export interface SubscribeAttitudeQuaternionRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.AttitudeQuaternionResponse
 */
export interface AttitudeQuaternionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Quaternion attitude_quaternion = 1;
     */
    attitudeQuaternion?: Quaternion; // The next attitude (quaternion)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeEulerRequest
 */
export interface SubscribeAttitudeEulerRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.AttitudeEulerResponse
 */
export interface AttitudeEulerResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.EulerAngle attitude_euler = 1;
     */
    attitudeEuler?: EulerAngle; // The next attitude (Euler)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeAngularVelocityBodyRequest
 */
export interface SubscribeAttitudeAngularVelocityBodyRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.AttitudeAngularVelocityBodyResponse
 */
export interface AttitudeAngularVelocityBodyResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.AngularVelocityBody attitude_angular_velocity_body = 1;
     */
    attitudeAngularVelocityBody?: AngularVelocityBody; // The next angular velocity (rad/s)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeVelocityNedRequest
 */
export interface SubscribeVelocityNedRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.VelocityNedResponse
 */
export interface VelocityNedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.VelocityNed velocity_ned = 1;
     */
    velocityNed?: VelocityNed; // The next velocity (NED)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeGpsInfoRequest
 */
export interface SubscribeGpsInfoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.GpsInfoResponse
 */
export interface GpsInfoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.GpsInfo gps_info = 1;
     */
    gpsInfo?: GpsInfo; // The next 'GPS info' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeRawGpsRequest
 */
export interface SubscribeRawGpsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.RawGpsResponse
 */
export interface RawGpsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.RawGps raw_gps = 1;
     */
    rawGps?: RawGps; // The next 'Raw GPS' state. Warning: this is an advanced feature, use `Position` updates to get the location of the drone!
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeBatteryRequest
 */
export interface SubscribeBatteryRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.BatteryResponse
 */
export interface BatteryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Battery battery = 1;
     */
    battery?: Battery; // The next 'battery' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeFlightModeRequest
 */
export interface SubscribeFlightModeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.FlightModeResponse
 */
export interface FlightModeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.FlightMode flight_mode = 1;
     */
    flightMode: FlightMode; // The next flight mode
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeHealthRequest
 */
export interface SubscribeHealthRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.HealthResponse
 */
export interface HealthResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Health health = 1;
     */
    health?: Health; // The next 'health' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeRcStatusRequest
 */
export interface SubscribeRcStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.RcStatusResponse
 */
export interface RcStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.RcStatus rc_status = 1;
     */
    rcStatus?: RcStatus; // The next RC status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeStatusTextRequest
 */
export interface SubscribeStatusTextRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.StatusTextResponse
 */
export interface StatusTextResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.StatusText status_text = 1;
     */
    statusText?: StatusText; // The next 'status text'
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeActuatorControlTargetRequest
 */
export interface SubscribeActuatorControlTargetRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ActuatorControlTargetResponse
 */
export interface ActuatorControlTargetResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.ActuatorControlTarget actuator_control_target = 1;
     */
    actuatorControlTarget?: ActuatorControlTarget; // The next actuator control target
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeActuatorOutputStatusRequest
 */
export interface SubscribeActuatorOutputStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ActuatorOutputStatusResponse
 */
export interface ActuatorOutputStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.ActuatorOutputStatus actuator_output_status = 1;
     */
    actuatorOutputStatus?: ActuatorOutputStatus; // The next actuator output status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeOdometryRequest
 */
export interface SubscribeOdometryRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.OdometryResponse
 */
export interface OdometryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Odometry odometry = 1;
     */
    odometry?: Odometry; // The next odometry status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribePositionVelocityNedRequest
 */
export interface SubscribePositionVelocityNedRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.PositionVelocityNedResponse
 */
export interface PositionVelocityNedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.PositionVelocityNed position_velocity_ned = 1;
     */
    positionVelocityNed?: PositionVelocityNed; // The next position and velocity status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeGroundTruthRequest
 */
export interface SubscribeGroundTruthRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.GroundTruthResponse
 */
export interface GroundTruthResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.GroundTruth ground_truth = 1;
     */
    groundTruth?: GroundTruth; // Ground truth position information available in simulation
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeFixedwingMetricsRequest
 */
export interface SubscribeFixedwingMetricsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.FixedwingMetricsResponse
 */
export interface FixedwingMetricsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.FixedwingMetrics fixedwing_metrics = 1;
     */
    fixedwingMetrics?: FixedwingMetrics; // The next fixedwing metrics
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeImuRequest
 */
export interface SubscribeImuRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ImuResponse
 */
export interface ImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Imu imu = 1;
     */
    imu?: Imu; // The next IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeScaledImuRequest
 */
export interface SubscribeScaledImuRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ScaledImuResponse
 */
export interface ScaledImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Imu imu = 1;
     */
    imu?: Imu; // The next scaled IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeRawImuRequest
 */
export interface SubscribeRawImuRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.RawImuResponse
 */
export interface RawImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Imu imu = 1;
     */
    imu?: Imu; // The next raw IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeHealthAllOkRequest
 */
export interface SubscribeHealthAllOkRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.HealthAllOkResponse
 */
export interface HealthAllOkResponse {
    /**
     * @generated from protobuf field: bool is_health_all_ok = 1;
     */
    isHealthAllOk: boolean; // The next 'health all ok' status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeUnixEpochTimeRequest
 */
export interface SubscribeUnixEpochTimeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.UnixEpochTimeResponse
 */
export interface UnixEpochTimeResponse {
    /**
     * @generated from protobuf field: uint64 time_us = 1;
     */
    timeUs: bigint; // The next 'unix epoch time' status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeDistanceSensorRequest
 */
export interface SubscribeDistanceSensorRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.DistanceSensorResponse
 */
export interface DistanceSensorResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.DistanceSensor distance_sensor = 1;
     */
    distanceSensor?: DistanceSensor; // The next Distance Sensor status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeScaledPressureRequest
 */
export interface SubscribeScaledPressureRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.ScaledPressureResponse
 */
export interface ScaledPressureResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.ScaledPressure scaled_pressure = 1;
     */
    scaledPressure?: ScaledPressure; // The next Scaled Pressure status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeHeadingRequest
 */
export interface SubscribeHeadingRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.HeadingResponse
 */
export interface HeadingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Heading heading_deg = 1;
     */
    headingDeg?: Heading; // The next heading (yaw) in degrees
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SubscribeAltitudeRequest
 */
export interface SubscribeAltitudeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.AltitudeResponse
 */
export interface AltitudeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Altitude altitude = 1;
     */
    altitude?: Altitude; // The next altitude
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRatePositionRequest
 */
export interface SetRatePositionRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRatePositionResponse
 */
export interface SetRatePositionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateHomeRequest
 */
export interface SetRateHomeRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateHomeResponse
 */
export interface SetRateHomeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateInAirRequest
 */
export interface SetRateInAirRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateInAirResponse
 */
export interface SetRateInAirResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateLandedStateRequest
 */
export interface SetRateLandedStateRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateLandedStateResponse
 */
export interface SetRateLandedStateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateVtolStateRequest
 */
export interface SetRateVtolStateRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateVtolStateResponse
 */
export interface SetRateVtolStateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeEulerRequest
 */
export interface SetRateAttitudeEulerRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeEulerResponse
 */
export interface SetRateAttitudeEulerResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeQuaternionRequest
 */
export interface SetRateAttitudeQuaternionRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeQuaternionResponse
 */
export interface SetRateAttitudeQuaternionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyRequest
 */
export interface SetRateAttitudeAngularVelocityBodyRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyResponse
 */
export interface SetRateAttitudeAngularVelocityBodyResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateVelocityNedRequest
 */
export interface SetRateVelocityNedRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateVelocityNedResponse
 */
export interface SetRateVelocityNedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateGpsInfoRequest
 */
export interface SetRateGpsInfoRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateGpsInfoResponse
 */
export interface SetRateGpsInfoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateRawGpsRequest
 */
export interface SetRateRawGpsRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateBatteryRequest
 */
export interface SetRateBatteryRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateBatteryResponse
 */
export interface SetRateBatteryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateRcStatusRequest
 */
export interface SetRateRcStatusRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateRcStatusResponse
 */
export interface SetRateRcStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateActuatorControlTargetRequest
 */
export interface SetRateActuatorControlTargetRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateActuatorControlTargetResponse
 */
export interface SetRateActuatorControlTargetResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateActuatorOutputStatusRequest
 */
export interface SetRateActuatorOutputStatusRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateActuatorOutputStatusResponse
 */
export interface SetRateActuatorOutputStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateOdometryRequest
 */
export interface SetRateOdometryRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateOdometryResponse
 */
export interface SetRateOdometryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRatePositionVelocityNedRequest
 */
export interface SetRatePositionVelocityNedRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRatePositionVelocityNedResponse
 */
export interface SetRatePositionVelocityNedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateGroundTruthRequest
 */
export interface SetRateGroundTruthRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateGroundTruthResponse
 */
export interface SetRateGroundTruthResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateFixedwingMetricsRequest
 */
export interface SetRateFixedwingMetricsRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateFixedwingMetricsResponse
 */
export interface SetRateFixedwingMetricsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateImuRequest
 */
export interface SetRateImuRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateImuResponse
 */
export interface SetRateImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateScaledImuRequest
 */
export interface SetRateScaledImuRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateScaledImuResponse
 */
export interface SetRateScaledImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateRawImuRequest
 */
export interface SetRateRawImuRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateRawImuResponse
 */
export interface SetRateRawImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateUnixEpochTimeRequest
 */
export interface SetRateUnixEpochTimeRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateUnixEpochTimeResponse
 */
export interface SetRateUnixEpochTimeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateDistanceSensorRequest
 */
export interface SetRateDistanceSensorRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateDistanceSensorResponse
 */
export interface SetRateDistanceSensorResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.GetGpsGlobalOriginRequest
 */
export interface GetGpsGlobalOriginRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.GetGpsGlobalOriginResponse
 */
export interface GetGpsGlobalOriginResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.GpsGlobalOrigin gps_global_origin = 2;
     */
    gpsGlobalOrigin?: GpsGlobalOrigin;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAltitudeRequest
 */
export interface SetRateAltitudeRequest {
    /**
     * @generated from protobuf field: double rate_hz = 1;
     */
    rateHz: number; // The requested rate (in Hertz)
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry.SetRateAltitudeResponse
 */
export interface SetRateAltitudeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1;
     */
    telemetryResult?: TelemetryResult;
}
/**
 * Position type in global coordinates.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to +180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float relative_altitude_m = 4;
     */
    relativeAltitudeM: number; // Altitude relative to takeoff altitude in metres
}
/**
 * Heading type used for global position
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Heading
 */
export interface Heading {
    /**
     * @generated from protobuf field: double heading_deg = 1;
     */
    headingDeg: number; // Heading in degrees (range: 0 to +360)
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
    /**
     * @generated from protobuf field: uint64 timestamp_us = 5;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 *
 * Euler angle type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
 *
 * For more info see https://en.wikipedia.org/wiki/Euler_angles
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.EulerAngle
 */
export interface EulerAngle {
    /**
     * @generated from protobuf field: float roll_deg = 1;
     */
    rollDeg: number; // Roll angle in degrees, positive is banking to the right
    /**
     * @generated from protobuf field: float pitch_deg = 2;
     */
    pitchDeg: number; // Pitch angle in degrees, positive is pitching nose up
    /**
     * @generated from protobuf field: float yaw_deg = 3;
     */
    yawDeg: number; // Yaw angle in degrees, positive is clock-wise seen from above
    /**
     * @generated from protobuf field: uint64 timestamp_us = 4;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 * Angular velocity type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.AngularVelocityBody
 */
export interface AngularVelocityBody {
    /**
     * @generated from protobuf field: float roll_rad_s = 1;
     */
    rollRadS: number; // Roll angular velocity
    /**
     * @generated from protobuf field: float pitch_rad_s = 2;
     */
    pitchRadS: number; // Pitch angular velocity
    /**
     * @generated from protobuf field: float yaw_rad_s = 3;
     */
    yawRadS: number; // Yaw angular velocity
}
/**
 * GPS information type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.GpsInfo
 */
export interface GpsInfo {
    /**
     * @generated from protobuf field: int32 num_satellites = 1;
     */
    numSatellites: number; // Number of visible satellites in use
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.FixType fix_type = 2;
     */
    fixType: FixType; // Fix type
}
/**
 *
 * Raw GPS information type.
 *
 * Warning: this is an advanced type! If you want the location of the drone, use
 * the position instead. This message exposes the raw values of the GNSS sensor.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.RawGps
 */
export interface RawGps {
    /**
     * @generated from protobuf field: uint64 timestamp_us = 1;
     */
    timestampUs: bigint; // Timestamp in microseconds (UNIX Epoch time or time since system boot, to be inferred)
    /**
     * @generated from protobuf field: double latitude_deg = 2;
     */
    latitudeDeg: number; // Latitude in degrees (WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: double longitude_deg = 3;
     */
    longitudeDeg: number; // Longitude in degrees (WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 4;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float hdop = 5;
     */
    hdop: number; // GPS HDOP horizontal dilution of position (unitless). If unknown, set to NaN
    /**
     * @generated from protobuf field: float vdop = 6;
     */
    vdop: number; // GPS VDOP vertical dilution of position (unitless). If unknown, set to NaN
    /**
     * @generated from protobuf field: float velocity_m_s = 7;
     */
    velocityMS: number; // Ground velocity in metres per second
    /**
     * @generated from protobuf field: float cog_deg = 8;
     */
    cogDeg: number; // Course over ground (NOT heading, but direction of movement) in degrees. If unknown, set to NaN
    /**
     * @generated from protobuf field: float altitude_ellipsoid_m = 9;
     */
    altitudeEllipsoidM: number; // Altitude in metres (above WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: float horizontal_uncertainty_m = 10;
     */
    horizontalUncertaintyM: number; // Position uncertainty in metres
    /**
     * @generated from protobuf field: float vertical_uncertainty_m = 11;
     */
    verticalUncertaintyM: number; // Altitude uncertainty in metres
    /**
     * @generated from protobuf field: float velocity_uncertainty_m_s = 12;
     */
    velocityUncertaintyMS: number; // Velocity uncertainty in metres per second
    /**
     * @generated from protobuf field: float heading_uncertainty_deg = 13;
     */
    headingUncertaintyDeg: number; // Heading uncertainty in degrees
    /**
     * @generated from protobuf field: float yaw_deg = 14;
     */
    yawDeg: number; // Yaw in earth frame from north.
}
/**
 * Battery type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Battery
 */
export interface Battery {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number; // Battery ID, for systems with multiple batteries
    /**
     * @generated from protobuf field: float temperature_degc = 2;
     */
    temperatureDegc: number; // Temperature of the battery in degrees Celsius. NAN for unknown temperature
    /**
     * @generated from protobuf field: float voltage_v = 3;
     */
    voltageV: number; // Voltage in volts
    /**
     * @generated from protobuf field: float current_battery_a = 4;
     */
    currentBatteryA: number; // Battery current in Amps, NAN if autopilot does not measure the current
    /**
     * @generated from protobuf field: float capacity_consumed_ah = 5;
     */
    capacityConsumedAh: number; // Consumed charge in Amp hours, NAN if autopilot does not provide consumption estimate
    /**
     * @generated from protobuf field: float remaining_percent = 6;
     */
    remainingPercent: number; // Estimated battery remaining (range: 0 to 100)
}
/**
 * Health type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Health
 */
export interface Health {
    /**
     * @generated from protobuf field: bool is_gyrometer_calibration_ok = 1;
     */
    isGyrometerCalibrationOk: boolean; // True if the gyrometer is calibrated
    /**
     * @generated from protobuf field: bool is_accelerometer_calibration_ok = 2;
     */
    isAccelerometerCalibrationOk: boolean; // True if the accelerometer is calibrated
    /**
     * @generated from protobuf field: bool is_magnetometer_calibration_ok = 3;
     */
    isMagnetometerCalibrationOk: boolean; // True if the magnetometer is calibrated
    /**
     * @generated from protobuf field: bool is_local_position_ok = 5;
     */
    isLocalPositionOk: boolean; // True if the local position estimate is good enough to fly in 'position control' mode
    /**
     * @generated from protobuf field: bool is_global_position_ok = 6;
     */
    isGlobalPositionOk: boolean; // True if the global position estimate is good enough to fly in 'position control' mode
    /**
     * @generated from protobuf field: bool is_home_position_ok = 7;
     */
    isHomePositionOk: boolean; // True if the home position has been initialized properly
    /**
     * @generated from protobuf field: bool is_armable = 8;
     */
    isArmable: boolean; // True if system can be armed
}
/**
 * Remote control status type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.RcStatus
 */
export interface RcStatus {
    /**
     * @generated from protobuf field: bool was_available_once = 1;
     */
    wasAvailableOnce: boolean; // True if an RC signal has been available once
    /**
     * @generated from protobuf field: bool is_available = 2;
     */
    isAvailable: boolean; // True if the RC signal is available now
    /**
     * @generated from protobuf field: float signal_strength_percent = 3;
     */
    signalStrengthPercent: number; // Signal strength (range: 0 to 100, NaN if unknown)
}
/**
 * StatusText information type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.StatusText
 */
export interface StatusText {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.StatusTextType type = 1;
     */
    type: StatusTextType; // Message type
    /**
     * @generated from protobuf field: string text = 2;
     */
    text: string; // MAVLink status message
}
/**
 * Actuator control target type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.ActuatorControlTarget
 */
export interface ActuatorControlTarget {
    /**
     * @generated from protobuf field: int32 group = 1;
     */
    group: number; // An actuator control group is e.g. 'attitude' for the core flight controls, or 'gimbal' for a payload.
    /**
     * @generated from protobuf field: repeated float controls = 2;
     */
    controls: number[]; // Controls normed from -1 to 1, where 0 is neutral position.
}
/**
 * Actuator output status type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.ActuatorOutputStatus
 */
export interface ActuatorOutputStatus {
    /**
     * @generated from protobuf field: uint32 active = 1;
     */
    active: number; // Active outputs
    /**
     * @generated from protobuf field: repeated float actuator = 2;
     */
    actuator: number[]; // Servo/motor output values
}
/**
 *
 * Covariance type.
 *
 * Row-major representation of a 6x6 cross-covariance matrix
 * upper right triangle.
 * Set first to NaN if unknown.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Covariance
 */
export interface Covariance {
    /**
     * @generated from protobuf field: repeated float covariance_matrix = 1;
     */
    covarianceMatrix: number[]; // Representation of a covariance matrix.
}
/**
 * Velocity type, represented in the Body (X Y Z) frame and in metres/second.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.VelocityBody
 */
export interface VelocityBody {
    /**
     * @generated from protobuf field: float x_m_s = 1;
     */
    xMS: number; // Velocity in X in metres/second
    /**
     * @generated from protobuf field: float y_m_s = 2;
     */
    yMS: number; // Velocity in Y in metres/second
    /**
     * @generated from protobuf field: float z_m_s = 3;
     */
    zMS: number; // Velocity in Z in metres/second
}
/**
 * Position type, represented in the Body (X Y Z) frame
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.PositionBody
 */
export interface PositionBody {
    /**
     * @generated from protobuf field: float x_m = 1;
     */
    xM: number; // X Position in metres.
    /**
     * @generated from protobuf field: float y_m = 2;
     */
    yM: number; // Y Position in metres.
    /**
     * @generated from protobuf field: float z_m = 3;
     */
    zM: number; // Z Position in metres.
}
/**
 * Odometry message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Odometry
 */
export interface Odometry {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // Timestamp (0 to use Backend timestamp).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Odometry.MavFrame frame_id = 2;
     */
    frameId: Odometry_MavFrame; // Coordinate frame of reference for the pose data.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Odometry.MavFrame child_frame_id = 3;
     */
    childFrameId: Odometry_MavFrame; // Coordinate frame of reference for the velocity in free space (twist) data.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.PositionBody position_body = 4;
     */
    positionBody?: PositionBody; // Position.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Quaternion q = 5;
     */
    q?: Quaternion; // Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.VelocityBody velocity_body = 6;
     */
    velocityBody?: VelocityBody; // Linear velocity (m/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.AngularVelocityBody angular_velocity_body = 7;
     */
    angularVelocityBody?: AngularVelocityBody; // Angular velocity (rad/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Covariance pose_covariance = 8;
     */
    poseCovariance?: Covariance; // Pose cross-covariance matrix.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.Covariance velocity_covariance = 9;
     */
    velocityCovariance?: Covariance; // Velocity cross-covariance matrix.
}
/**
 * Mavlink frame id
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.Odometry.MavFrame
 */
export enum Odometry_MavFrame {
    /**
     * Frame is undefined.
     *
     * @generated from protobuf enum value: MAV_FRAME_UNDEF = 0;
     */
    UNDEF = 0,
    /**
     * Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.
     *
     * @generated from protobuf enum value: MAV_FRAME_BODY_NED = 8;
     */
    BODY_NED = 8,
    /**
     * Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down).
     *
     * @generated from protobuf enum value: MAV_FRAME_VISION_NED = 16;
     */
    VISION_NED = 16,
    /**
     * Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down).
     *
     * @generated from protobuf enum value: MAV_FRAME_ESTIM_NED = 18;
     */
    ESTIM_NED = 18
}
/**
 * DistanceSensor message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.DistanceSensor
 */
export interface DistanceSensor {
    /**
     * @generated from protobuf field: float minimum_distance_m = 1;
     */
    minimumDistanceM: number; // Minimum distance the sensor can measure, NaN if unknown.
    /**
     * @generated from protobuf field: float maximum_distance_m = 2;
     */
    maximumDistanceM: number; // Maximum distance the sensor can measure, NaN if unknown.
    /**
     * @generated from protobuf field: float current_distance_m = 3;
     */
    currentDistanceM: number; // Current distance reading, NaN if unknown.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.EulerAngle orientation = 4;
     */
    orientation?: EulerAngle; // Sensor Orientation reading.
}
/**
 * Scaled Pressure message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.ScaledPressure
 */
export interface ScaledPressure {
    /**
     * @generated from protobuf field: uint64 timestamp_us = 1;
     */
    timestampUs: bigint; // Timestamp (time since system boot)
    /**
     * @generated from protobuf field: float absolute_pressure_hpa = 2;
     */
    absolutePressureHpa: number; // Absolute pressure in hPa
    /**
     * @generated from protobuf field: float differential_pressure_hpa = 3;
     */
    differentialPressureHpa: number; // Differential pressure 1 in hPa
    /**
     * @generated from protobuf field: float temperature_deg = 4;
     */
    temperatureDeg: number; // Absolute pressure temperature (in celsius)
    /**
     * @generated from protobuf field: float differential_pressure_temperature_deg = 5;
     */
    differentialPressureTemperatureDeg: number; // Differential pressure temperature (in celsius, 0 if not available)
}
/**
 * PositionNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.PositionNed
 */
export interface PositionNed {
    /**
     * @generated from protobuf field: float north_m = 1;
     */
    northM: number; // Position along north direction in metres
    /**
     * @generated from protobuf field: float east_m = 2;
     */
    eastM: number; // Position along east direction in metres
    /**
     * @generated from protobuf field: float down_m = 3;
     */
    downM: number; // Position along down direction in metres
}
/**
 * VelocityNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.VelocityNed
 */
export interface VelocityNed {
    /**
     * @generated from protobuf field: float north_m_s = 1;
     */
    northMS: number; // Velocity along north direction in metres per second
    /**
     * @generated from protobuf field: float east_m_s = 2;
     */
    eastMS: number; // Velocity along east direction in metres per second
    /**
     * @generated from protobuf field: float down_m_s = 3;
     */
    downMS: number; // Velocity along down direction in metres per second
}
/**
 * PositionVelocityNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.PositionVelocityNed
 */
export interface PositionVelocityNed {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.PositionNed position = 1;
     */
    position?: PositionNed; // Position (NED)
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.VelocityNed velocity = 2;
     */
    velocity?: VelocityNed; // Velocity (NED)
}
/**
 * GroundTruth message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.GroundTruth
 */
export interface GroundTruth {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to 180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
}
/**
 * FixedwingMetrics message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.FixedwingMetrics
 */
export interface FixedwingMetrics {
    /**
     * @generated from protobuf field: float airspeed_m_s = 1;
     */
    airspeedMS: number; // Current indicated airspeed (IAS) in metres per second
    /**
     * @generated from protobuf field: float throttle_percentage = 2;
     */
    throttlePercentage: number; // Current throttle setting (0 to 100)
    /**
     * @generated from protobuf field: float climb_rate_m_s = 3;
     */
    climbRateMS: number; // Current climb rate in metres per second
}
/**
 * AccelerationFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.AccelerationFrd
 */
export interface AccelerationFrd {
    /**
     * @generated from protobuf field: float forward_m_s2 = 1;
     */
    forwardMS2: number; // Acceleration in forward direction in metres per second^2
    /**
     * @generated from protobuf field: float right_m_s2 = 2;
     */
    rightMS2: number; // Acceleration in right direction in metres per second^2
    /**
     * @generated from protobuf field: float down_m_s2 = 3;
     */
    downMS2: number; // Acceleration in down direction in metres per second^2
}
/**
 * AngularVelocityFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.AngularVelocityFrd
 */
export interface AngularVelocityFrd {
    /**
     * @generated from protobuf field: float forward_rad_s = 1;
     */
    forwardRadS: number; // Angular velocity in forward direction in radians per second
    /**
     * @generated from protobuf field: float right_rad_s = 2;
     */
    rightRadS: number; // Angular velocity in right direction in radians per second
    /**
     * @generated from protobuf field: float down_rad_s = 3;
     */
    downRadS: number; // Angular velocity in Down direction in radians per second
}
/**
 * MagneticFieldFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.MagneticFieldFrd
 */
export interface MagneticFieldFrd {
    /**
     * @generated from protobuf field: float forward_gauss = 1;
     */
    forwardGauss: number; // Magnetic field in forward direction measured in Gauss
    /**
     * @generated from protobuf field: float right_gauss = 2;
     */
    rightGauss: number; // Magnetic field in East direction measured in Gauss
    /**
     * @generated from protobuf field: float down_gauss = 3;
     */
    downGauss: number; // Magnetic field in Down direction measured in Gauss
}
/**
 * Imu message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Imu
 */
export interface Imu {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.AccelerationFrd acceleration_frd = 1;
     */
    accelerationFrd?: AccelerationFrd; // Acceleration
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.AngularVelocityFrd angular_velocity_frd = 2;
     */
    angularVelocityFrd?: AngularVelocityFrd; // Angular velocity
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.MagneticFieldFrd magnetic_field_frd = 3;
     */
    magneticFieldFrd?: MagneticFieldFrd; // Magnetic field
    /**
     * @generated from protobuf field: float temperature_degc = 4;
     */
    temperatureDegc: number; // Temperature
    /**
     * @generated from protobuf field: uint64 timestamp_us = 5;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 * Gps global origin type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.GpsGlobalOrigin
 */
export interface GpsGlobalOrigin {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude of the origin
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude of the origin
    /**
     * @generated from protobuf field: float altitude_m = 3;
     */
    altitudeM: number; // Altitude AMSL (above mean sea level) in metres
}
/**
 * Altitude message type
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.Altitude
 */
export interface Altitude {
    /**
     * @generated from protobuf field: float altitude_monotonic_m = 1;
     */
    altitudeMonotonicM: number; // Altitude in meters is initialized on system boot and monotonic
    /**
     * @generated from protobuf field: float altitude_amsl_m = 2;
     */
    altitudeAmslM: number; //  Altitude AMSL (above mean sea level) in meters
    /**
     * @generated from protobuf field: float altitude_local_m = 3;
     */
    altitudeLocalM: number; // Local altitude in meters
    /**
     * @generated from protobuf field: float altitude_relative_m = 4;
     */
    altitudeRelativeM: number; // Altitude above home position in meters
    /**
     * @generated from protobuf field: float altitude_terrain_m = 5;
     */
    altitudeTerrainM: number; // Altitude above terrain in meters
    /**
     * @generated from protobuf field: float bottom_clearance_m = 6;
     */
    bottomClearanceM: number; // This is not the altitude, but the clear space below the system according to the fused clearance estimate in meters.
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry.TelemetryResult
 */
export interface TelemetryResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry.TelemetryResult.Result result = 1;
     */
    result: TelemetryResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for telemetry requests.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.TelemetryResult.Result
 */
export enum TelemetryResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Success: the telemetry command was accepted by the vehicle
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Connection error
     *
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 3;
     */
    CONNECTION_ERROR = 3,
    /**
     * Vehicle is busy
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Command refused by vehicle
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED = 5;
     */
    COMMAND_DENIED = 5,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * Request not supported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 7;
     */
    UNSUPPORTED = 7
}
/**
 * GPS fix type.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.FixType
 */
export enum FixType {
    /**
     * No GPS connected
     *
     * @generated from protobuf enum value: FIX_TYPE_NO_GPS = 0;
     */
    NO_GPS = 0,
    /**
     * No position information, GPS is connected
     *
     * @generated from protobuf enum value: FIX_TYPE_NO_FIX = 1;
     */
    NO_FIX = 1,
    /**
     * 2D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_2D = 2;
     */
    FIX_2D = 2,
    /**
     * 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_3D = 3;
     */
    FIX_3D = 3,
    /**
     * DGPS/SBAS aided 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_DGPS = 4;
     */
    FIX_DGPS = 4,
    /**
     * RTK float, 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_RTK_FLOAT = 5;
     */
    RTK_FLOAT = 5,
    /**
     * RTK Fixed, 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_RTK_FIXED = 6;
     */
    RTK_FIXED = 6
}
/**
 *
 * Flight modes.
 *
 * For more information about flight modes, check out
 * https://docs.px4.io/master/en/config/flight_mode.html.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.FlightMode
 */
export enum FlightMode {
    /**
     * Mode not known
     *
     * @generated from protobuf enum value: FLIGHT_MODE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Armed and ready to take off
     *
     * @generated from protobuf enum value: FLIGHT_MODE_READY = 1;
     */
    READY = 1,
    /**
     * Taking off
     *
     * @generated from protobuf enum value: FLIGHT_MODE_TAKEOFF = 2;
     */
    TAKEOFF = 2,
    /**
     * Holding (hovering in place (or circling for fixed-wing vehicles)
     *
     * @generated from protobuf enum value: FLIGHT_MODE_HOLD = 3;
     */
    HOLD = 3,
    /**
     * In mission
     *
     * @generated from protobuf enum value: FLIGHT_MODE_MISSION = 4;
     */
    MISSION = 4,
    /**
     * Returning to launch position (then landing)
     *
     * @generated from protobuf enum value: FLIGHT_MODE_RETURN_TO_LAUNCH = 5;
     */
    RETURN_TO_LAUNCH = 5,
    /**
     * Landing
     *
     * @generated from protobuf enum value: FLIGHT_MODE_LAND = 6;
     */
    LAND = 6,
    /**
     * In 'offboard' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_OFFBOARD = 7;
     */
    OFFBOARD = 7,
    /**
     * In 'follow-me' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_FOLLOW_ME = 8;
     */
    FOLLOW_ME = 8,
    /**
     * In 'Manual' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_MANUAL = 9;
     */
    MANUAL = 9,
    /**
     * In 'Altitude Control' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_ALTCTL = 10;
     */
    ALTCTL = 10,
    /**
     * In 'Position Control' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_POSCTL = 11;
     */
    POSCTL = 11,
    /**
     * In 'Acro' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_ACRO = 12;
     */
    ACRO = 12,
    /**
     * In 'Stabilize' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_STABILIZED = 13;
     */
    STABILIZED = 13,
    /**
     * In 'Rattitude' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_RATTITUDE = 14;
     */
    RATTITUDE = 14
}
/**
 * Status types.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.StatusTextType
 */
export enum StatusTextType {
    /**
     * Debug
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_DEBUG = 0;
     */
    DEBUG = 0,
    /**
     * Information
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_INFO = 1;
     */
    INFO = 1,
    /**
     * Notice
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_NOTICE = 2;
     */
    NOTICE = 2,
    /**
     * Warning
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_WARNING = 3;
     */
    WARNING = 3,
    /**
     * Error
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_ERROR = 4;
     */
    ERROR = 4,
    /**
     * Critical
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_CRITICAL = 5;
     */
    CRITICAL = 5,
    /**
     * Alert
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_ALERT = 6;
     */
    ALERT = 6,
    /**
     * Emergency
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_EMERGENCY = 7;
     */
    EMERGENCY = 7
}
/**
 * Landed State enumeration.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.LandedState
 */
export enum LandedState {
    /**
     * Landed state is unknown
     *
     * @generated from protobuf enum value: LANDED_STATE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * The vehicle is on the ground
     *
     * @generated from protobuf enum value: LANDED_STATE_ON_GROUND = 1;
     */
    ON_GROUND = 1,
    /**
     * The vehicle is in the air
     *
     * @generated from protobuf enum value: LANDED_STATE_IN_AIR = 2;
     */
    IN_AIR = 2,
    /**
     * The vehicle is taking off
     *
     * @generated from protobuf enum value: LANDED_STATE_TAKING_OFF = 3;
     */
    TAKING_OFF = 3,
    /**
     * The vehicle is landing
     *
     * @generated from protobuf enum value: LANDED_STATE_LANDING = 4;
     */
    LANDING = 4
}
/**
 * VTOL State enumeration
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry.VtolState
 */
export enum VtolState {
    /**
     * MAV is not configured as VTOL
     *
     * @generated from protobuf enum value: VTOL_STATE_UNDEFINED = 0;
     */
    UNDEFINED = 0,
    /**
     * VTOL is in transition from multicopter to fixed-wing
     *
     * @generated from protobuf enum value: VTOL_STATE_TRANSITION_TO_FW = 1;
     */
    TRANSITION_TO_FW = 1,
    /**
     * VTOL is in transition from fixed-wing to multicopter
     *
     * @generated from protobuf enum value: VTOL_STATE_TRANSITION_TO_MC = 2;
     */
    TRANSITION_TO_MC = 2,
    /**
     * VTOL is in multicopter state
     *
     * @generated from protobuf enum value: VTOL_STATE_MC = 3;
     */
    MC = 3,
    /**
     * VTOL is in fixed-wing state
     *
     * @generated from protobuf enum value: VTOL_STATE_FW = 4;
     */
    FW = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribePositionRequest$Type extends MessageType<SubscribePositionRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribePositionRequest", []);
    }
    create(value?: PartialMessage<SubscribePositionRequest>): SubscribePositionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribePositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribePositionRequest): SubscribePositionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribePositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribePositionRequest
 */
export const SubscribePositionRequest = new SubscribePositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionResponse$Type extends MessageType<PositionResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.PositionResponse", [
            { no: 1, name: "position", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<PositionResponse>): PositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionResponse): PositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.PositionResponse
 */
export const PositionResponse = new PositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHomeRequest$Type extends MessageType<SubscribeHomeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeHomeRequest", []);
    }
    create(value?: PartialMessage<SubscribeHomeRequest>): SubscribeHomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeHomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHomeRequest): SubscribeHomeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeHomeRequest
 */
export const SubscribeHomeRequest = new SubscribeHomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HomeResponse$Type extends MessageType<HomeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.HomeResponse", [
            { no: 1, name: "home", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<HomeResponse>): HomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HomeResponse): HomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Position home */ 1:
                    message.home = Position.internalBinaryRead(reader, reader.uint32(), options, message.home);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Position home = 1; */
        if (message.home)
            Position.internalBinaryWrite(message.home, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.HomeResponse
 */
export const HomeResponse = new HomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeInAirRequest$Type extends MessageType<SubscribeInAirRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeInAirRequest", []);
    }
    create(value?: PartialMessage<SubscribeInAirRequest>): SubscribeInAirRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeInAirRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeInAirRequest): SubscribeInAirRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeInAirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeInAirRequest
 */
export const SubscribeInAirRequest = new SubscribeInAirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InAirResponse$Type extends MessageType<InAirResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.InAirResponse", [
            { no: 1, name: "is_in_air", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InAirResponse>): InAirResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isInAir = false;
        if (value !== undefined)
            reflectionMergePartial<InAirResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InAirResponse): InAirResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_in_air */ 1:
                    message.isInAir = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InAirResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_in_air = 1; */
        if (message.isInAir !== false)
            writer.tag(1, WireType.Varint).bool(message.isInAir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.InAirResponse
 */
export const InAirResponse = new InAirResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLandedStateRequest$Type extends MessageType<SubscribeLandedStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeLandedStateRequest", []);
    }
    create(value?: PartialMessage<SubscribeLandedStateRequest>): SubscribeLandedStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeLandedStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLandedStateRequest): SubscribeLandedStateRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeLandedStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeLandedStateRequest
 */
export const SubscribeLandedStateRequest = new SubscribeLandedStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LandedStateResponse$Type extends MessageType<LandedStateResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.LandedStateResponse", [
            { no: 1, name: "landed_state", kind: "enum", T: () => ["mavsdk.rpc.telemetry.LandedState", LandedState, "LANDED_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<LandedStateResponse>): LandedStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.landedState = 0;
        if (value !== undefined)
            reflectionMergePartial<LandedStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LandedStateResponse): LandedStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.LandedState landed_state */ 1:
                    message.landedState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LandedStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.LandedState landed_state = 1; */
        if (message.landedState !== 0)
            writer.tag(1, WireType.Varint).int32(message.landedState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.LandedStateResponse
 */
export const LandedStateResponse = new LandedStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeArmedRequest$Type extends MessageType<SubscribeArmedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeArmedRequest", []);
    }
    create(value?: PartialMessage<SubscribeArmedRequest>): SubscribeArmedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeArmedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeArmedRequest): SubscribeArmedRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeArmedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeArmedRequest
 */
export const SubscribeArmedRequest = new SubscribeArmedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArmedResponse$Type extends MessageType<ArmedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ArmedResponse", [
            { no: 1, name: "is_armed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ArmedResponse>): ArmedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isArmed = false;
        if (value !== undefined)
            reflectionMergePartial<ArmedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArmedResponse): ArmedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_armed */ 1:
                    message.isArmed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArmedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_armed = 1; */
        if (message.isArmed !== false)
            writer.tag(1, WireType.Varint).bool(message.isArmed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ArmedResponse
 */
export const ArmedResponse = new ArmedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeVtolStateRequest$Type extends MessageType<SubscribeVtolStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeVtolStateRequest", []);
    }
    create(value?: PartialMessage<SubscribeVtolStateRequest>): SubscribeVtolStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeVtolStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeVtolStateRequest): SubscribeVtolStateRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeVtolStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeVtolStateRequest
 */
export const SubscribeVtolStateRequest = new SubscribeVtolStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VtolStateResponse$Type extends MessageType<VtolStateResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.VtolStateResponse", [
            { no: 1, name: "vtol_state", kind: "enum", T: () => ["mavsdk.rpc.telemetry.VtolState", VtolState, "VTOL_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<VtolStateResponse>): VtolStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vtolState = 0;
        if (value !== undefined)
            reflectionMergePartial<VtolStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VtolStateResponse): VtolStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.VtolState vtol_state */ 1:
                    message.vtolState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VtolStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.VtolState vtol_state = 1; */
        if (message.vtolState !== 0)
            writer.tag(1, WireType.Varint).int32(message.vtolState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.VtolStateResponse
 */
export const VtolStateResponse = new VtolStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAttitudeQuaternionRequest$Type extends MessageType<SubscribeAttitudeQuaternionRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeAttitudeQuaternionRequest", []);
    }
    create(value?: PartialMessage<SubscribeAttitudeQuaternionRequest>): SubscribeAttitudeQuaternionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeAttitudeQuaternionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAttitudeQuaternionRequest): SubscribeAttitudeQuaternionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAttitudeQuaternionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeQuaternionRequest
 */
export const SubscribeAttitudeQuaternionRequest = new SubscribeAttitudeQuaternionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttitudeQuaternionResponse$Type extends MessageType<AttitudeQuaternionResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.AttitudeQuaternionResponse", [
            { no: 1, name: "attitude_quaternion", kind: "message", T: () => Quaternion }
        ]);
    }
    create(value?: PartialMessage<AttitudeQuaternionResponse>): AttitudeQuaternionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttitudeQuaternionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttitudeQuaternionResponse): AttitudeQuaternionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Quaternion attitude_quaternion */ 1:
                    message.attitudeQuaternion = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.attitudeQuaternion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttitudeQuaternionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Quaternion attitude_quaternion = 1; */
        if (message.attitudeQuaternion)
            Quaternion.internalBinaryWrite(message.attitudeQuaternion, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AttitudeQuaternionResponse
 */
export const AttitudeQuaternionResponse = new AttitudeQuaternionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAttitudeEulerRequest$Type extends MessageType<SubscribeAttitudeEulerRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeAttitudeEulerRequest", []);
    }
    create(value?: PartialMessage<SubscribeAttitudeEulerRequest>): SubscribeAttitudeEulerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeAttitudeEulerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAttitudeEulerRequest): SubscribeAttitudeEulerRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAttitudeEulerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeEulerRequest
 */
export const SubscribeAttitudeEulerRequest = new SubscribeAttitudeEulerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttitudeEulerResponse$Type extends MessageType<AttitudeEulerResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.AttitudeEulerResponse", [
            { no: 1, name: "attitude_euler", kind: "message", T: () => EulerAngle }
        ]);
    }
    create(value?: PartialMessage<AttitudeEulerResponse>): AttitudeEulerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttitudeEulerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttitudeEulerResponse): AttitudeEulerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.EulerAngle attitude_euler */ 1:
                    message.attitudeEuler = EulerAngle.internalBinaryRead(reader, reader.uint32(), options, message.attitudeEuler);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttitudeEulerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.EulerAngle attitude_euler = 1; */
        if (message.attitudeEuler)
            EulerAngle.internalBinaryWrite(message.attitudeEuler, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AttitudeEulerResponse
 */
export const AttitudeEulerResponse = new AttitudeEulerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAttitudeAngularVelocityBodyRequest$Type extends MessageType<SubscribeAttitudeAngularVelocityBodyRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeAttitudeAngularVelocityBodyRequest", []);
    }
    create(value?: PartialMessage<SubscribeAttitudeAngularVelocityBodyRequest>): SubscribeAttitudeAngularVelocityBodyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeAttitudeAngularVelocityBodyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAttitudeAngularVelocityBodyRequest): SubscribeAttitudeAngularVelocityBodyRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAttitudeAngularVelocityBodyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeAttitudeAngularVelocityBodyRequest
 */
export const SubscribeAttitudeAngularVelocityBodyRequest = new SubscribeAttitudeAngularVelocityBodyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttitudeAngularVelocityBodyResponse$Type extends MessageType<AttitudeAngularVelocityBodyResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.AttitudeAngularVelocityBodyResponse", [
            { no: 1, name: "attitude_angular_velocity_body", kind: "message", T: () => AngularVelocityBody }
        ]);
    }
    create(value?: PartialMessage<AttitudeAngularVelocityBodyResponse>): AttitudeAngularVelocityBodyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttitudeAngularVelocityBodyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttitudeAngularVelocityBodyResponse): AttitudeAngularVelocityBodyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.AngularVelocityBody attitude_angular_velocity_body */ 1:
                    message.attitudeAngularVelocityBody = AngularVelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.attitudeAngularVelocityBody);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttitudeAngularVelocityBodyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.AngularVelocityBody attitude_angular_velocity_body = 1; */
        if (message.attitudeAngularVelocityBody)
            AngularVelocityBody.internalBinaryWrite(message.attitudeAngularVelocityBody, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AttitudeAngularVelocityBodyResponse
 */
export const AttitudeAngularVelocityBodyResponse = new AttitudeAngularVelocityBodyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeVelocityNedRequest$Type extends MessageType<SubscribeVelocityNedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeVelocityNedRequest", []);
    }
    create(value?: PartialMessage<SubscribeVelocityNedRequest>): SubscribeVelocityNedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeVelocityNedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeVelocityNedRequest): SubscribeVelocityNedRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeVelocityNedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeVelocityNedRequest
 */
export const SubscribeVelocityNedRequest = new SubscribeVelocityNedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VelocityNedResponse$Type extends MessageType<VelocityNedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.VelocityNedResponse", [
            { no: 1, name: "velocity_ned", kind: "message", T: () => VelocityNed }
        ]);
    }
    create(value?: PartialMessage<VelocityNedResponse>): VelocityNedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VelocityNedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VelocityNedResponse): VelocityNedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.VelocityNed velocity_ned */ 1:
                    message.velocityNed = VelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.velocityNed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VelocityNedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.VelocityNed velocity_ned = 1; */
        if (message.velocityNed)
            VelocityNed.internalBinaryWrite(message.velocityNed, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.VelocityNedResponse
 */
export const VelocityNedResponse = new VelocityNedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeGpsInfoRequest$Type extends MessageType<SubscribeGpsInfoRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeGpsInfoRequest", []);
    }
    create(value?: PartialMessage<SubscribeGpsInfoRequest>): SubscribeGpsInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeGpsInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeGpsInfoRequest): SubscribeGpsInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeGpsInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeGpsInfoRequest
 */
export const SubscribeGpsInfoRequest = new SubscribeGpsInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpsInfoResponse$Type extends MessageType<GpsInfoResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.GpsInfoResponse", [
            { no: 1, name: "gps_info", kind: "message", T: () => GpsInfo }
        ]);
    }
    create(value?: PartialMessage<GpsInfoResponse>): GpsInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GpsInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpsInfoResponse): GpsInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.GpsInfo gps_info */ 1:
                    message.gpsInfo = GpsInfo.internalBinaryRead(reader, reader.uint32(), options, message.gpsInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpsInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.GpsInfo gps_info = 1; */
        if (message.gpsInfo)
            GpsInfo.internalBinaryWrite(message.gpsInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GpsInfoResponse
 */
export const GpsInfoResponse = new GpsInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRawGpsRequest$Type extends MessageType<SubscribeRawGpsRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeRawGpsRequest", []);
    }
    create(value?: PartialMessage<SubscribeRawGpsRequest>): SubscribeRawGpsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeRawGpsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRawGpsRequest): SubscribeRawGpsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeRawGpsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeRawGpsRequest
 */
export const SubscribeRawGpsRequest = new SubscribeRawGpsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RawGpsResponse$Type extends MessageType<RawGpsResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.RawGpsResponse", [
            { no: 1, name: "raw_gps", kind: "message", T: () => RawGps }
        ]);
    }
    create(value?: PartialMessage<RawGpsResponse>): RawGpsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RawGpsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RawGpsResponse): RawGpsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.RawGps raw_gps */ 1:
                    message.rawGps = RawGps.internalBinaryRead(reader, reader.uint32(), options, message.rawGps);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RawGpsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.RawGps raw_gps = 1; */
        if (message.rawGps)
            RawGps.internalBinaryWrite(message.rawGps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.RawGpsResponse
 */
export const RawGpsResponse = new RawGpsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeBatteryRequest$Type extends MessageType<SubscribeBatteryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeBatteryRequest", []);
    }
    create(value?: PartialMessage<SubscribeBatteryRequest>): SubscribeBatteryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeBatteryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeBatteryRequest): SubscribeBatteryRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeBatteryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeBatteryRequest
 */
export const SubscribeBatteryRequest = new SubscribeBatteryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatteryResponse$Type extends MessageType<BatteryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.BatteryResponse", [
            { no: 1, name: "battery", kind: "message", T: () => Battery }
        ]);
    }
    create(value?: PartialMessage<BatteryResponse>): BatteryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BatteryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatteryResponse): BatteryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Battery battery */ 1:
                    message.battery = Battery.internalBinaryRead(reader, reader.uint32(), options, message.battery);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatteryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Battery battery = 1; */
        if (message.battery)
            Battery.internalBinaryWrite(message.battery, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.BatteryResponse
 */
export const BatteryResponse = new BatteryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFlightModeRequest$Type extends MessageType<SubscribeFlightModeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeFlightModeRequest", []);
    }
    create(value?: PartialMessage<SubscribeFlightModeRequest>): SubscribeFlightModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeFlightModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFlightModeRequest): SubscribeFlightModeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeFlightModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeFlightModeRequest
 */
export const SubscribeFlightModeRequest = new SubscribeFlightModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightModeResponse$Type extends MessageType<FlightModeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.FlightModeResponse", [
            { no: 1, name: "flight_mode", kind: "enum", T: () => ["mavsdk.rpc.telemetry.FlightMode", FlightMode, "FLIGHT_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<FlightModeResponse>): FlightModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flightMode = 0;
        if (value !== undefined)
            reflectionMergePartial<FlightModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightModeResponse): FlightModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.FlightMode flight_mode */ 1:
                    message.flightMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.FlightMode flight_mode = 1; */
        if (message.flightMode !== 0)
            writer.tag(1, WireType.Varint).int32(message.flightMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.FlightModeResponse
 */
export const FlightModeResponse = new FlightModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHealthRequest$Type extends MessageType<SubscribeHealthRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeHealthRequest", []);
    }
    create(value?: PartialMessage<SubscribeHealthRequest>): SubscribeHealthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeHealthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHealthRequest): SubscribeHealthRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHealthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeHealthRequest
 */
export const SubscribeHealthRequest = new SubscribeHealthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthResponse$Type extends MessageType<HealthResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.HealthResponse", [
            { no: 1, name: "health", kind: "message", T: () => Health }
        ]);
    }
    create(value?: PartialMessage<HealthResponse>): HealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthResponse): HealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Health health */ 1:
                    message.health = Health.internalBinaryRead(reader, reader.uint32(), options, message.health);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Health health = 1; */
        if (message.health)
            Health.internalBinaryWrite(message.health, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.HealthResponse
 */
export const HealthResponse = new HealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRcStatusRequest$Type extends MessageType<SubscribeRcStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeRcStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeRcStatusRequest>): SubscribeRcStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeRcStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRcStatusRequest): SubscribeRcStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeRcStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeRcStatusRequest
 */
export const SubscribeRcStatusRequest = new SubscribeRcStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcStatusResponse$Type extends MessageType<RcStatusResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.RcStatusResponse", [
            { no: 1, name: "rc_status", kind: "message", T: () => RcStatus }
        ]);
    }
    create(value?: PartialMessage<RcStatusResponse>): RcStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RcStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcStatusResponse): RcStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.RcStatus rc_status */ 1:
                    message.rcStatus = RcStatus.internalBinaryRead(reader, reader.uint32(), options, message.rcStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RcStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.RcStatus rc_status = 1; */
        if (message.rcStatus)
            RcStatus.internalBinaryWrite(message.rcStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.RcStatusResponse
 */
export const RcStatusResponse = new RcStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatusTextRequest$Type extends MessageType<SubscribeStatusTextRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeStatusTextRequest", []);
    }
    create(value?: PartialMessage<SubscribeStatusTextRequest>): SubscribeStatusTextRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStatusTextRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStatusTextRequest): SubscribeStatusTextRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStatusTextRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeStatusTextRequest
 */
export const SubscribeStatusTextRequest = new SubscribeStatusTextRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusTextResponse$Type extends MessageType<StatusTextResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.StatusTextResponse", [
            { no: 1, name: "status_text", kind: "message", T: () => StatusText }
        ]);
    }
    create(value?: PartialMessage<StatusTextResponse>): StatusTextResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusTextResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusTextResponse): StatusTextResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.StatusText status_text */ 1:
                    message.statusText = StatusText.internalBinaryRead(reader, reader.uint32(), options, message.statusText);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusTextResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.StatusText status_text = 1; */
        if (message.statusText)
            StatusText.internalBinaryWrite(message.statusText, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.StatusTextResponse
 */
export const StatusTextResponse = new StatusTextResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeActuatorControlTargetRequest$Type extends MessageType<SubscribeActuatorControlTargetRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeActuatorControlTargetRequest", []);
    }
    create(value?: PartialMessage<SubscribeActuatorControlTargetRequest>): SubscribeActuatorControlTargetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeActuatorControlTargetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActuatorControlTargetRequest): SubscribeActuatorControlTargetRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeActuatorControlTargetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeActuatorControlTargetRequest
 */
export const SubscribeActuatorControlTargetRequest = new SubscribeActuatorControlTargetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorControlTargetResponse$Type extends MessageType<ActuatorControlTargetResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ActuatorControlTargetResponse", [
            { no: 1, name: "actuator_control_target", kind: "message", T: () => ActuatorControlTarget }
        ]);
    }
    create(value?: PartialMessage<ActuatorControlTargetResponse>): ActuatorControlTargetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ActuatorControlTargetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorControlTargetResponse): ActuatorControlTargetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.ActuatorControlTarget actuator_control_target */ 1:
                    message.actuatorControlTarget = ActuatorControlTarget.internalBinaryRead(reader, reader.uint32(), options, message.actuatorControlTarget);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorControlTargetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.ActuatorControlTarget actuator_control_target = 1; */
        if (message.actuatorControlTarget)
            ActuatorControlTarget.internalBinaryWrite(message.actuatorControlTarget, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ActuatorControlTargetResponse
 */
export const ActuatorControlTargetResponse = new ActuatorControlTargetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeActuatorOutputStatusRequest$Type extends MessageType<SubscribeActuatorOutputStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeActuatorOutputStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeActuatorOutputStatusRequest>): SubscribeActuatorOutputStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeActuatorOutputStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActuatorOutputStatusRequest): SubscribeActuatorOutputStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeActuatorOutputStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeActuatorOutputStatusRequest
 */
export const SubscribeActuatorOutputStatusRequest = new SubscribeActuatorOutputStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorOutputStatusResponse$Type extends MessageType<ActuatorOutputStatusResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ActuatorOutputStatusResponse", [
            { no: 1, name: "actuator_output_status", kind: "message", T: () => ActuatorOutputStatus }
        ]);
    }
    create(value?: PartialMessage<ActuatorOutputStatusResponse>): ActuatorOutputStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ActuatorOutputStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorOutputStatusResponse): ActuatorOutputStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.ActuatorOutputStatus actuator_output_status */ 1:
                    message.actuatorOutputStatus = ActuatorOutputStatus.internalBinaryRead(reader, reader.uint32(), options, message.actuatorOutputStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorOutputStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.ActuatorOutputStatus actuator_output_status = 1; */
        if (message.actuatorOutputStatus)
            ActuatorOutputStatus.internalBinaryWrite(message.actuatorOutputStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ActuatorOutputStatusResponse
 */
export const ActuatorOutputStatusResponse = new ActuatorOutputStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeOdometryRequest$Type extends MessageType<SubscribeOdometryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeOdometryRequest", []);
    }
    create(value?: PartialMessage<SubscribeOdometryRequest>): SubscribeOdometryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeOdometryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeOdometryRequest): SubscribeOdometryRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeOdometryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeOdometryRequest
 */
export const SubscribeOdometryRequest = new SubscribeOdometryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OdometryResponse$Type extends MessageType<OdometryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.OdometryResponse", [
            { no: 1, name: "odometry", kind: "message", T: () => Odometry }
        ]);
    }
    create(value?: PartialMessage<OdometryResponse>): OdometryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OdometryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OdometryResponse): OdometryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Odometry odometry */ 1:
                    message.odometry = Odometry.internalBinaryRead(reader, reader.uint32(), options, message.odometry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OdometryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Odometry odometry = 1; */
        if (message.odometry)
            Odometry.internalBinaryWrite(message.odometry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.OdometryResponse
 */
export const OdometryResponse = new OdometryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribePositionVelocityNedRequest$Type extends MessageType<SubscribePositionVelocityNedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribePositionVelocityNedRequest", []);
    }
    create(value?: PartialMessage<SubscribePositionVelocityNedRequest>): SubscribePositionVelocityNedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribePositionVelocityNedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribePositionVelocityNedRequest): SubscribePositionVelocityNedRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribePositionVelocityNedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribePositionVelocityNedRequest
 */
export const SubscribePositionVelocityNedRequest = new SubscribePositionVelocityNedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionVelocityNedResponse$Type extends MessageType<PositionVelocityNedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.PositionVelocityNedResponse", [
            { no: 1, name: "position_velocity_ned", kind: "message", T: () => PositionVelocityNed }
        ]);
    }
    create(value?: PartialMessage<PositionVelocityNedResponse>): PositionVelocityNedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PositionVelocityNedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionVelocityNedResponse): PositionVelocityNedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.PositionVelocityNed position_velocity_ned */ 1:
                    message.positionVelocityNed = PositionVelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.positionVelocityNed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionVelocityNedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.PositionVelocityNed position_velocity_ned = 1; */
        if (message.positionVelocityNed)
            PositionVelocityNed.internalBinaryWrite(message.positionVelocityNed, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.PositionVelocityNedResponse
 */
export const PositionVelocityNedResponse = new PositionVelocityNedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeGroundTruthRequest$Type extends MessageType<SubscribeGroundTruthRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeGroundTruthRequest", []);
    }
    create(value?: PartialMessage<SubscribeGroundTruthRequest>): SubscribeGroundTruthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeGroundTruthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeGroundTruthRequest): SubscribeGroundTruthRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeGroundTruthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeGroundTruthRequest
 */
export const SubscribeGroundTruthRequest = new SubscribeGroundTruthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroundTruthResponse$Type extends MessageType<GroundTruthResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.GroundTruthResponse", [
            { no: 1, name: "ground_truth", kind: "message", T: () => GroundTruth }
        ]);
    }
    create(value?: PartialMessage<GroundTruthResponse>): GroundTruthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GroundTruthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroundTruthResponse): GroundTruthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.GroundTruth ground_truth */ 1:
                    message.groundTruth = GroundTruth.internalBinaryRead(reader, reader.uint32(), options, message.groundTruth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroundTruthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.GroundTruth ground_truth = 1; */
        if (message.groundTruth)
            GroundTruth.internalBinaryWrite(message.groundTruth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GroundTruthResponse
 */
export const GroundTruthResponse = new GroundTruthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFixedwingMetricsRequest$Type extends MessageType<SubscribeFixedwingMetricsRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeFixedwingMetricsRequest", []);
    }
    create(value?: PartialMessage<SubscribeFixedwingMetricsRequest>): SubscribeFixedwingMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeFixedwingMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFixedwingMetricsRequest): SubscribeFixedwingMetricsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeFixedwingMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeFixedwingMetricsRequest
 */
export const SubscribeFixedwingMetricsRequest = new SubscribeFixedwingMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FixedwingMetricsResponse$Type extends MessageType<FixedwingMetricsResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.FixedwingMetricsResponse", [
            { no: 1, name: "fixedwing_metrics", kind: "message", T: () => FixedwingMetrics }
        ]);
    }
    create(value?: PartialMessage<FixedwingMetricsResponse>): FixedwingMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FixedwingMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedwingMetricsResponse): FixedwingMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.FixedwingMetrics fixedwing_metrics */ 1:
                    message.fixedwingMetrics = FixedwingMetrics.internalBinaryRead(reader, reader.uint32(), options, message.fixedwingMetrics);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FixedwingMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.FixedwingMetrics fixedwing_metrics = 1; */
        if (message.fixedwingMetrics)
            FixedwingMetrics.internalBinaryWrite(message.fixedwingMetrics, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.FixedwingMetricsResponse
 */
export const FixedwingMetricsResponse = new FixedwingMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeImuRequest$Type extends MessageType<SubscribeImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeImuRequest", []);
    }
    create(value?: PartialMessage<SubscribeImuRequest>): SubscribeImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeImuRequest): SubscribeImuRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeImuRequest
 */
export const SubscribeImuRequest = new SubscribeImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImuResponse$Type extends MessageType<ImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ImuResponse", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<ImuResponse>): ImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImuResponse): ImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ImuResponse
 */
export const ImuResponse = new ImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeScaledImuRequest$Type extends MessageType<SubscribeScaledImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeScaledImuRequest", []);
    }
    create(value?: PartialMessage<SubscribeScaledImuRequest>): SubscribeScaledImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeScaledImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeScaledImuRequest): SubscribeScaledImuRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeScaledImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeScaledImuRequest
 */
export const SubscribeScaledImuRequest = new SubscribeScaledImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScaledImuResponse$Type extends MessageType<ScaledImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ScaledImuResponse", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<ScaledImuResponse>): ScaledImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScaledImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScaledImuResponse): ScaledImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScaledImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ScaledImuResponse
 */
export const ScaledImuResponse = new ScaledImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRawImuRequest$Type extends MessageType<SubscribeRawImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeRawImuRequest", []);
    }
    create(value?: PartialMessage<SubscribeRawImuRequest>): SubscribeRawImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeRawImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRawImuRequest): SubscribeRawImuRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeRawImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeRawImuRequest
 */
export const SubscribeRawImuRequest = new SubscribeRawImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RawImuResponse$Type extends MessageType<RawImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.RawImuResponse", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<RawImuResponse>): RawImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RawImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RawImuResponse): RawImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RawImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.RawImuResponse
 */
export const RawImuResponse = new RawImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHealthAllOkRequest$Type extends MessageType<SubscribeHealthAllOkRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeHealthAllOkRequest", []);
    }
    create(value?: PartialMessage<SubscribeHealthAllOkRequest>): SubscribeHealthAllOkRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeHealthAllOkRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHealthAllOkRequest): SubscribeHealthAllOkRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHealthAllOkRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeHealthAllOkRequest
 */
export const SubscribeHealthAllOkRequest = new SubscribeHealthAllOkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthAllOkResponse$Type extends MessageType<HealthAllOkResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.HealthAllOkResponse", [
            { no: 1, name: "is_health_all_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HealthAllOkResponse>): HealthAllOkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isHealthAllOk = false;
        if (value !== undefined)
            reflectionMergePartial<HealthAllOkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthAllOkResponse): HealthAllOkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_health_all_ok */ 1:
                    message.isHealthAllOk = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthAllOkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_health_all_ok = 1; */
        if (message.isHealthAllOk !== false)
            writer.tag(1, WireType.Varint).bool(message.isHealthAllOk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.HealthAllOkResponse
 */
export const HealthAllOkResponse = new HealthAllOkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeUnixEpochTimeRequest$Type extends MessageType<SubscribeUnixEpochTimeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeUnixEpochTimeRequest", []);
    }
    create(value?: PartialMessage<SubscribeUnixEpochTimeRequest>): SubscribeUnixEpochTimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeUnixEpochTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeUnixEpochTimeRequest): SubscribeUnixEpochTimeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeUnixEpochTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeUnixEpochTimeRequest
 */
export const SubscribeUnixEpochTimeRequest = new SubscribeUnixEpochTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnixEpochTimeResponse$Type extends MessageType<UnixEpochTimeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.UnixEpochTimeResponse", [
            { no: 1, name: "time_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UnixEpochTimeResponse>): UnixEpochTimeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<UnixEpochTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnixEpochTimeResponse): UnixEpochTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_us */ 1:
                    message.timeUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnixEpochTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_us = 1; */
        if (message.timeUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.UnixEpochTimeResponse
 */
export const UnixEpochTimeResponse = new UnixEpochTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeDistanceSensorRequest$Type extends MessageType<SubscribeDistanceSensorRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeDistanceSensorRequest", []);
    }
    create(value?: PartialMessage<SubscribeDistanceSensorRequest>): SubscribeDistanceSensorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeDistanceSensorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeDistanceSensorRequest): SubscribeDistanceSensorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeDistanceSensorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeDistanceSensorRequest
 */
export const SubscribeDistanceSensorRequest = new SubscribeDistanceSensorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DistanceSensorResponse$Type extends MessageType<DistanceSensorResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.DistanceSensorResponse", [
            { no: 1, name: "distance_sensor", kind: "message", T: () => DistanceSensor }
        ]);
    }
    create(value?: PartialMessage<DistanceSensorResponse>): DistanceSensorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DistanceSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DistanceSensorResponse): DistanceSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.DistanceSensor distance_sensor */ 1:
                    message.distanceSensor = DistanceSensor.internalBinaryRead(reader, reader.uint32(), options, message.distanceSensor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DistanceSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.DistanceSensor distance_sensor = 1; */
        if (message.distanceSensor)
            DistanceSensor.internalBinaryWrite(message.distanceSensor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.DistanceSensorResponse
 */
export const DistanceSensorResponse = new DistanceSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeScaledPressureRequest$Type extends MessageType<SubscribeScaledPressureRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeScaledPressureRequest", []);
    }
    create(value?: PartialMessage<SubscribeScaledPressureRequest>): SubscribeScaledPressureRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeScaledPressureRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeScaledPressureRequest): SubscribeScaledPressureRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeScaledPressureRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeScaledPressureRequest
 */
export const SubscribeScaledPressureRequest = new SubscribeScaledPressureRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScaledPressureResponse$Type extends MessageType<ScaledPressureResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.ScaledPressureResponse", [
            { no: 1, name: "scaled_pressure", kind: "message", T: () => ScaledPressure }
        ]);
    }
    create(value?: PartialMessage<ScaledPressureResponse>): ScaledPressureResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScaledPressureResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScaledPressureResponse): ScaledPressureResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.ScaledPressure scaled_pressure */ 1:
                    message.scaledPressure = ScaledPressure.internalBinaryRead(reader, reader.uint32(), options, message.scaledPressure);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScaledPressureResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.ScaledPressure scaled_pressure = 1; */
        if (message.scaledPressure)
            ScaledPressure.internalBinaryWrite(message.scaledPressure, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ScaledPressureResponse
 */
export const ScaledPressureResponse = new ScaledPressureResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeHeadingRequest$Type extends MessageType<SubscribeHeadingRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeHeadingRequest", []);
    }
    create(value?: PartialMessage<SubscribeHeadingRequest>): SubscribeHeadingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeHeadingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeHeadingRequest): SubscribeHeadingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeHeadingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeHeadingRequest
 */
export const SubscribeHeadingRequest = new SubscribeHeadingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeadingResponse$Type extends MessageType<HeadingResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.HeadingResponse", [
            { no: 1, name: "heading_deg", kind: "message", T: () => Heading }
        ]);
    }
    create(value?: PartialMessage<HeadingResponse>): HeadingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeadingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeadingResponse): HeadingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Heading heading_deg */ 1:
                    message.headingDeg = Heading.internalBinaryRead(reader, reader.uint32(), options, message.headingDeg);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeadingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Heading heading_deg = 1; */
        if (message.headingDeg)
            Heading.internalBinaryWrite(message.headingDeg, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.HeadingResponse
 */
export const HeadingResponse = new HeadingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAltitudeRequest$Type extends MessageType<SubscribeAltitudeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SubscribeAltitudeRequest", []);
    }
    create(value?: PartialMessage<SubscribeAltitudeRequest>): SubscribeAltitudeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeAltitudeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAltitudeRequest): SubscribeAltitudeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAltitudeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SubscribeAltitudeRequest
 */
export const SubscribeAltitudeRequest = new SubscribeAltitudeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AltitudeResponse$Type extends MessageType<AltitudeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.AltitudeResponse", [
            { no: 1, name: "altitude", kind: "message", T: () => Altitude }
        ]);
    }
    create(value?: PartialMessage<AltitudeResponse>): AltitudeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AltitudeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AltitudeResponse): AltitudeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.Altitude altitude */ 1:
                    message.altitude = Altitude.internalBinaryRead(reader, reader.uint32(), options, message.altitude);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AltitudeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.Altitude altitude = 1; */
        if (message.altitude)
            Altitude.internalBinaryWrite(message.altitude, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AltitudeResponse
 */
export const AltitudeResponse = new AltitudeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRatePositionRequest$Type extends MessageType<SetRatePositionRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRatePositionRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRatePositionRequest>): SetRatePositionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRatePositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRatePositionRequest): SetRatePositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRatePositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRatePositionRequest
 */
export const SetRatePositionRequest = new SetRatePositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRatePositionResponse$Type extends MessageType<SetRatePositionResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRatePositionResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRatePositionResponse>): SetRatePositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRatePositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRatePositionResponse): SetRatePositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRatePositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRatePositionResponse
 */
export const SetRatePositionResponse = new SetRatePositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateHomeRequest$Type extends MessageType<SetRateHomeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateHomeRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateHomeRequest>): SetRateHomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateHomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateHomeRequest): SetRateHomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateHomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateHomeRequest
 */
export const SetRateHomeRequest = new SetRateHomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateHomeResponse$Type extends MessageType<SetRateHomeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateHomeResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateHomeResponse>): SetRateHomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateHomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateHomeResponse): SetRateHomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateHomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateHomeResponse
 */
export const SetRateHomeResponse = new SetRateHomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateInAirRequest$Type extends MessageType<SetRateInAirRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateInAirRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateInAirRequest>): SetRateInAirRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateInAirRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateInAirRequest): SetRateInAirRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateInAirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateInAirRequest
 */
export const SetRateInAirRequest = new SetRateInAirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateInAirResponse$Type extends MessageType<SetRateInAirResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateInAirResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateInAirResponse>): SetRateInAirResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateInAirResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateInAirResponse): SetRateInAirResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateInAirResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateInAirResponse
 */
export const SetRateInAirResponse = new SetRateInAirResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateLandedStateRequest$Type extends MessageType<SetRateLandedStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateLandedStateRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateLandedStateRequest>): SetRateLandedStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateLandedStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateLandedStateRequest): SetRateLandedStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateLandedStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateLandedStateRequest
 */
export const SetRateLandedStateRequest = new SetRateLandedStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateLandedStateResponse$Type extends MessageType<SetRateLandedStateResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateLandedStateResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateLandedStateResponse>): SetRateLandedStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateLandedStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateLandedStateResponse): SetRateLandedStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateLandedStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateLandedStateResponse
 */
export const SetRateLandedStateResponse = new SetRateLandedStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateVtolStateRequest$Type extends MessageType<SetRateVtolStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateVtolStateRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateVtolStateRequest>): SetRateVtolStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateVtolStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateVtolStateRequest): SetRateVtolStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateVtolStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateVtolStateRequest
 */
export const SetRateVtolStateRequest = new SetRateVtolStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateVtolStateResponse$Type extends MessageType<SetRateVtolStateResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateVtolStateResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateVtolStateResponse>): SetRateVtolStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateVtolStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateVtolStateResponse): SetRateVtolStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateVtolStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateVtolStateResponse
 */
export const SetRateVtolStateResponse = new SetRateVtolStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeEulerRequest$Type extends MessageType<SetRateAttitudeEulerRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeEulerRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeEulerRequest>): SetRateAttitudeEulerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeEulerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeEulerRequest): SetRateAttitudeEulerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeEulerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeEulerRequest
 */
export const SetRateAttitudeEulerRequest = new SetRateAttitudeEulerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeEulerResponse$Type extends MessageType<SetRateAttitudeEulerResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeEulerResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeEulerResponse>): SetRateAttitudeEulerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeEulerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeEulerResponse): SetRateAttitudeEulerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeEulerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeEulerResponse
 */
export const SetRateAttitudeEulerResponse = new SetRateAttitudeEulerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeQuaternionRequest$Type extends MessageType<SetRateAttitudeQuaternionRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeQuaternionRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeQuaternionRequest>): SetRateAttitudeQuaternionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeQuaternionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeQuaternionRequest): SetRateAttitudeQuaternionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeQuaternionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeQuaternionRequest
 */
export const SetRateAttitudeQuaternionRequest = new SetRateAttitudeQuaternionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeQuaternionResponse$Type extends MessageType<SetRateAttitudeQuaternionResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeQuaternionResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeQuaternionResponse>): SetRateAttitudeQuaternionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeQuaternionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeQuaternionResponse): SetRateAttitudeQuaternionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeQuaternionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeQuaternionResponse
 */
export const SetRateAttitudeQuaternionResponse = new SetRateAttitudeQuaternionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeAngularVelocityBodyRequest$Type extends MessageType<SetRateAttitudeAngularVelocityBodyRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeAngularVelocityBodyRequest>): SetRateAttitudeAngularVelocityBodyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeAngularVelocityBodyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeAngularVelocityBodyRequest): SetRateAttitudeAngularVelocityBodyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeAngularVelocityBodyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyRequest
 */
export const SetRateAttitudeAngularVelocityBodyRequest = new SetRateAttitudeAngularVelocityBodyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAttitudeAngularVelocityBodyResponse$Type extends MessageType<SetRateAttitudeAngularVelocityBodyResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateAttitudeAngularVelocityBodyResponse>): SetRateAttitudeAngularVelocityBodyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateAttitudeAngularVelocityBodyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAttitudeAngularVelocityBodyResponse): SetRateAttitudeAngularVelocityBodyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAttitudeAngularVelocityBodyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAttitudeAngularVelocityBodyResponse
 */
export const SetRateAttitudeAngularVelocityBodyResponse = new SetRateAttitudeAngularVelocityBodyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateVelocityNedRequest$Type extends MessageType<SetRateVelocityNedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateVelocityNedRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateVelocityNedRequest>): SetRateVelocityNedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateVelocityNedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateVelocityNedRequest): SetRateVelocityNedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateVelocityNedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateVelocityNedRequest
 */
export const SetRateVelocityNedRequest = new SetRateVelocityNedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateVelocityNedResponse$Type extends MessageType<SetRateVelocityNedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateVelocityNedResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateVelocityNedResponse>): SetRateVelocityNedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateVelocityNedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateVelocityNedResponse): SetRateVelocityNedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateVelocityNedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateVelocityNedResponse
 */
export const SetRateVelocityNedResponse = new SetRateVelocityNedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateGpsInfoRequest$Type extends MessageType<SetRateGpsInfoRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateGpsInfoRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateGpsInfoRequest>): SetRateGpsInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateGpsInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateGpsInfoRequest): SetRateGpsInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateGpsInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateGpsInfoRequest
 */
export const SetRateGpsInfoRequest = new SetRateGpsInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateGpsInfoResponse$Type extends MessageType<SetRateGpsInfoResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateGpsInfoResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateGpsInfoResponse>): SetRateGpsInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateGpsInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateGpsInfoResponse): SetRateGpsInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateGpsInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateGpsInfoResponse
 */
export const SetRateGpsInfoResponse = new SetRateGpsInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateRawGpsRequest$Type extends MessageType<SetRateRawGpsRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateRawGpsRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateRawGpsRequest>): SetRateRawGpsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateRawGpsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateRawGpsRequest): SetRateRawGpsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateRawGpsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateRawGpsRequest
 */
export const SetRateRawGpsRequest = new SetRateRawGpsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateBatteryRequest$Type extends MessageType<SetRateBatteryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateBatteryRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateBatteryRequest>): SetRateBatteryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateBatteryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateBatteryRequest): SetRateBatteryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateBatteryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateBatteryRequest
 */
export const SetRateBatteryRequest = new SetRateBatteryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateBatteryResponse$Type extends MessageType<SetRateBatteryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateBatteryResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateBatteryResponse>): SetRateBatteryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateBatteryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateBatteryResponse): SetRateBatteryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateBatteryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateBatteryResponse
 */
export const SetRateBatteryResponse = new SetRateBatteryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateRcStatusRequest$Type extends MessageType<SetRateRcStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateRcStatusRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateRcStatusRequest>): SetRateRcStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateRcStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateRcStatusRequest): SetRateRcStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateRcStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateRcStatusRequest
 */
export const SetRateRcStatusRequest = new SetRateRcStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateRcStatusResponse$Type extends MessageType<SetRateRcStatusResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateRcStatusResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateRcStatusResponse>): SetRateRcStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateRcStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateRcStatusResponse): SetRateRcStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateRcStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateRcStatusResponse
 */
export const SetRateRcStatusResponse = new SetRateRcStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateActuatorControlTargetRequest$Type extends MessageType<SetRateActuatorControlTargetRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateActuatorControlTargetRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateActuatorControlTargetRequest>): SetRateActuatorControlTargetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateActuatorControlTargetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateActuatorControlTargetRequest): SetRateActuatorControlTargetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateActuatorControlTargetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateActuatorControlTargetRequest
 */
export const SetRateActuatorControlTargetRequest = new SetRateActuatorControlTargetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateActuatorControlTargetResponse$Type extends MessageType<SetRateActuatorControlTargetResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateActuatorControlTargetResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateActuatorControlTargetResponse>): SetRateActuatorControlTargetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateActuatorControlTargetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateActuatorControlTargetResponse): SetRateActuatorControlTargetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateActuatorControlTargetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateActuatorControlTargetResponse
 */
export const SetRateActuatorControlTargetResponse = new SetRateActuatorControlTargetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateActuatorOutputStatusRequest$Type extends MessageType<SetRateActuatorOutputStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateActuatorOutputStatusRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateActuatorOutputStatusRequest>): SetRateActuatorOutputStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateActuatorOutputStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateActuatorOutputStatusRequest): SetRateActuatorOutputStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateActuatorOutputStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateActuatorOutputStatusRequest
 */
export const SetRateActuatorOutputStatusRequest = new SetRateActuatorOutputStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateActuatorOutputStatusResponse$Type extends MessageType<SetRateActuatorOutputStatusResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateActuatorOutputStatusResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateActuatorOutputStatusResponse>): SetRateActuatorOutputStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateActuatorOutputStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateActuatorOutputStatusResponse): SetRateActuatorOutputStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateActuatorOutputStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateActuatorOutputStatusResponse
 */
export const SetRateActuatorOutputStatusResponse = new SetRateActuatorOutputStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateOdometryRequest$Type extends MessageType<SetRateOdometryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateOdometryRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateOdometryRequest>): SetRateOdometryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateOdometryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateOdometryRequest): SetRateOdometryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateOdometryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateOdometryRequest
 */
export const SetRateOdometryRequest = new SetRateOdometryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateOdometryResponse$Type extends MessageType<SetRateOdometryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateOdometryResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateOdometryResponse>): SetRateOdometryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateOdometryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateOdometryResponse): SetRateOdometryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateOdometryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateOdometryResponse
 */
export const SetRateOdometryResponse = new SetRateOdometryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRatePositionVelocityNedRequest$Type extends MessageType<SetRatePositionVelocityNedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRatePositionVelocityNedRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRatePositionVelocityNedRequest>): SetRatePositionVelocityNedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRatePositionVelocityNedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRatePositionVelocityNedRequest): SetRatePositionVelocityNedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRatePositionVelocityNedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRatePositionVelocityNedRequest
 */
export const SetRatePositionVelocityNedRequest = new SetRatePositionVelocityNedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRatePositionVelocityNedResponse$Type extends MessageType<SetRatePositionVelocityNedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRatePositionVelocityNedResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRatePositionVelocityNedResponse>): SetRatePositionVelocityNedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRatePositionVelocityNedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRatePositionVelocityNedResponse): SetRatePositionVelocityNedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRatePositionVelocityNedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRatePositionVelocityNedResponse
 */
export const SetRatePositionVelocityNedResponse = new SetRatePositionVelocityNedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateGroundTruthRequest$Type extends MessageType<SetRateGroundTruthRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateGroundTruthRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateGroundTruthRequest>): SetRateGroundTruthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateGroundTruthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateGroundTruthRequest): SetRateGroundTruthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateGroundTruthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateGroundTruthRequest
 */
export const SetRateGroundTruthRequest = new SetRateGroundTruthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateGroundTruthResponse$Type extends MessageType<SetRateGroundTruthResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateGroundTruthResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateGroundTruthResponse>): SetRateGroundTruthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateGroundTruthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateGroundTruthResponse): SetRateGroundTruthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateGroundTruthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateGroundTruthResponse
 */
export const SetRateGroundTruthResponse = new SetRateGroundTruthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateFixedwingMetricsRequest$Type extends MessageType<SetRateFixedwingMetricsRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateFixedwingMetricsRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateFixedwingMetricsRequest>): SetRateFixedwingMetricsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateFixedwingMetricsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateFixedwingMetricsRequest): SetRateFixedwingMetricsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateFixedwingMetricsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateFixedwingMetricsRequest
 */
export const SetRateFixedwingMetricsRequest = new SetRateFixedwingMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateFixedwingMetricsResponse$Type extends MessageType<SetRateFixedwingMetricsResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateFixedwingMetricsResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateFixedwingMetricsResponse>): SetRateFixedwingMetricsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateFixedwingMetricsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateFixedwingMetricsResponse): SetRateFixedwingMetricsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateFixedwingMetricsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateFixedwingMetricsResponse
 */
export const SetRateFixedwingMetricsResponse = new SetRateFixedwingMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateImuRequest$Type extends MessageType<SetRateImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateImuRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateImuRequest>): SetRateImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateImuRequest): SetRateImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateImuRequest
 */
export const SetRateImuRequest = new SetRateImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateImuResponse$Type extends MessageType<SetRateImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateImuResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateImuResponse>): SetRateImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateImuResponse): SetRateImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateImuResponse
 */
export const SetRateImuResponse = new SetRateImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateScaledImuRequest$Type extends MessageType<SetRateScaledImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateScaledImuRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateScaledImuRequest>): SetRateScaledImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateScaledImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateScaledImuRequest): SetRateScaledImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateScaledImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateScaledImuRequest
 */
export const SetRateScaledImuRequest = new SetRateScaledImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateScaledImuResponse$Type extends MessageType<SetRateScaledImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateScaledImuResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateScaledImuResponse>): SetRateScaledImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateScaledImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateScaledImuResponse): SetRateScaledImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateScaledImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateScaledImuResponse
 */
export const SetRateScaledImuResponse = new SetRateScaledImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateRawImuRequest$Type extends MessageType<SetRateRawImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateRawImuRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateRawImuRequest>): SetRateRawImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateRawImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateRawImuRequest): SetRateRawImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateRawImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateRawImuRequest
 */
export const SetRateRawImuRequest = new SetRateRawImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateRawImuResponse$Type extends MessageType<SetRateRawImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateRawImuResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateRawImuResponse>): SetRateRawImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateRawImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateRawImuResponse): SetRateRawImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateRawImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateRawImuResponse
 */
export const SetRateRawImuResponse = new SetRateRawImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateUnixEpochTimeRequest$Type extends MessageType<SetRateUnixEpochTimeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateUnixEpochTimeRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateUnixEpochTimeRequest>): SetRateUnixEpochTimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateUnixEpochTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateUnixEpochTimeRequest): SetRateUnixEpochTimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateUnixEpochTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateUnixEpochTimeRequest
 */
export const SetRateUnixEpochTimeRequest = new SetRateUnixEpochTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateUnixEpochTimeResponse$Type extends MessageType<SetRateUnixEpochTimeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateUnixEpochTimeResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateUnixEpochTimeResponse>): SetRateUnixEpochTimeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateUnixEpochTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateUnixEpochTimeResponse): SetRateUnixEpochTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateUnixEpochTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateUnixEpochTimeResponse
 */
export const SetRateUnixEpochTimeResponse = new SetRateUnixEpochTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateDistanceSensorRequest$Type extends MessageType<SetRateDistanceSensorRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateDistanceSensorRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateDistanceSensorRequest>): SetRateDistanceSensorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateDistanceSensorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateDistanceSensorRequest): SetRateDistanceSensorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateDistanceSensorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateDistanceSensorRequest
 */
export const SetRateDistanceSensorRequest = new SetRateDistanceSensorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateDistanceSensorResponse$Type extends MessageType<SetRateDistanceSensorResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateDistanceSensorResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateDistanceSensorResponse>): SetRateDistanceSensorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateDistanceSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateDistanceSensorResponse): SetRateDistanceSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateDistanceSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateDistanceSensorResponse
 */
export const SetRateDistanceSensorResponse = new SetRateDistanceSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGpsGlobalOriginRequest$Type extends MessageType<GetGpsGlobalOriginRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.GetGpsGlobalOriginRequest", []);
    }
    create(value?: PartialMessage<GetGpsGlobalOriginRequest>): GetGpsGlobalOriginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetGpsGlobalOriginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGpsGlobalOriginRequest): GetGpsGlobalOriginRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetGpsGlobalOriginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GetGpsGlobalOriginRequest
 */
export const GetGpsGlobalOriginRequest = new GetGpsGlobalOriginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetGpsGlobalOriginResponse$Type extends MessageType<GetGpsGlobalOriginResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.GetGpsGlobalOriginResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult },
            { no: 2, name: "gps_global_origin", kind: "message", T: () => GpsGlobalOrigin }
        ]);
    }
    create(value?: PartialMessage<GetGpsGlobalOriginResponse>): GetGpsGlobalOriginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetGpsGlobalOriginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetGpsGlobalOriginResponse): GetGpsGlobalOriginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                case /* mavsdk.rpc.telemetry.GpsGlobalOrigin gps_global_origin */ 2:
                    message.gpsGlobalOrigin = GpsGlobalOrigin.internalBinaryRead(reader, reader.uint32(), options, message.gpsGlobalOrigin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetGpsGlobalOriginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.GpsGlobalOrigin gps_global_origin = 2; */
        if (message.gpsGlobalOrigin)
            GpsGlobalOrigin.internalBinaryWrite(message.gpsGlobalOrigin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GetGpsGlobalOriginResponse
 */
export const GetGpsGlobalOriginResponse = new GetGpsGlobalOriginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAltitudeRequest$Type extends MessageType<SetRateAltitudeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAltitudeRequest", [
            { no: 1, name: "rate_hz", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SetRateAltitudeRequest>): SetRateAltitudeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rateHz = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRateAltitudeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAltitudeRequest): SetRateAltitudeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double rate_hz */ 1:
                    message.rateHz = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAltitudeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double rate_hz = 1; */
        if (message.rateHz !== 0)
            writer.tag(1, WireType.Bit64).double(message.rateHz);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAltitudeRequest
 */
export const SetRateAltitudeRequest = new SetRateAltitudeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRateAltitudeResponse$Type extends MessageType<SetRateAltitudeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry.SetRateAltitudeResponse", [
            { no: 1, name: "telemetry_result", kind: "message", T: () => TelemetryResult }
        ]);
    }
    create(value?: PartialMessage<SetRateAltitudeResponse>): SetRateAltitudeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRateAltitudeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRateAltitudeResponse): SetRateAltitudeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result */ 1:
                    message.telemetryResult = TelemetryResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRateAltitudeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult telemetry_result = 1; */
        if (message.telemetryResult)
            TelemetryResult.internalBinaryWrite(message.telemetryResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.SetRateAltitudeResponse
 */
export const SetRateAltitudeResponse = new SetRateAltitudeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("mavsdk.rpc.telemetry.Position", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "relative_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.relativeAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float relative_altitude_m */ 4:
                    message.relativeAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float relative_altitude_m = 4; */
        if (message.relativeAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.relativeAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Heading$Type extends MessageType<Heading> {
    constructor() {
        super("mavsdk.rpc.telemetry.Heading", [
            { no: 1, name: "heading_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Heading>): Heading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headingDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<Heading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heading): Heading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double heading_deg */ 1:
                    message.headingDeg = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double heading_deg = 1; */
        if (message.headingDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.headingDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Heading
 */
export const Heading = new Heading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.telemetry.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                case /* uint64 timestamp_us */ 5:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        /* uint64 timestamp_us = 5; */
        if (message.timestampUs !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EulerAngle$Type extends MessageType<EulerAngle> {
    constructor() {
        super("mavsdk.rpc.telemetry.EulerAngle", [
            { no: 1, name: "roll_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EulerAngle>): EulerAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollDeg = 0;
        message.pitchDeg = 0;
        message.yawDeg = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<EulerAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EulerAngle): EulerAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_deg */ 1:
                    message.rollDeg = reader.float();
                    break;
                case /* float pitch_deg */ 2:
                    message.pitchDeg = reader.float();
                    break;
                case /* float yaw_deg */ 3:
                    message.yawDeg = reader.float();
                    break;
                case /* uint64 timestamp_us */ 4:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EulerAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_deg = 1; */
        if (message.rollDeg !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollDeg);
        /* float pitch_deg = 2; */
        if (message.pitchDeg !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchDeg);
        /* float yaw_deg = 3; */
        if (message.yawDeg !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawDeg);
        /* uint64 timestamp_us = 4; */
        if (message.timestampUs !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.EulerAngle
 */
export const EulerAngle = new EulerAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityBody$Type extends MessageType<AngularVelocityBody> {
    constructor() {
        super("mavsdk.rpc.telemetry.AngularVelocityBody", [
            { no: 1, name: "roll_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityBody>): AngularVelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollRadS = 0;
        message.pitchRadS = 0;
        message.yawRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityBody): AngularVelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_rad_s */ 1:
                    message.rollRadS = reader.float();
                    break;
                case /* float pitch_rad_s */ 2:
                    message.pitchRadS = reader.float();
                    break;
                case /* float yaw_rad_s */ 3:
                    message.yawRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_rad_s = 1; */
        if (message.rollRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollRadS);
        /* float pitch_rad_s = 2; */
        if (message.pitchRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchRadS);
        /* float yaw_rad_s = 3; */
        if (message.yawRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AngularVelocityBody
 */
export const AngularVelocityBody = new AngularVelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpsInfo$Type extends MessageType<GpsInfo> {
    constructor() {
        super("mavsdk.rpc.telemetry.GpsInfo", [
            { no: 1, name: "num_satellites", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "fix_type", kind: "enum", T: () => ["mavsdk.rpc.telemetry.FixType", FixType, "FIX_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<GpsInfo>): GpsInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numSatellites = 0;
        message.fixType = 0;
        if (value !== undefined)
            reflectionMergePartial<GpsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpsInfo): GpsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 num_satellites */ 1:
                    message.numSatellites = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry.FixType fix_type */ 2:
                    message.fixType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 num_satellites = 1; */
        if (message.numSatellites !== 0)
            writer.tag(1, WireType.Varint).int32(message.numSatellites);
        /* mavsdk.rpc.telemetry.FixType fix_type = 2; */
        if (message.fixType !== 0)
            writer.tag(2, WireType.Varint).int32(message.fixType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GpsInfo
 */
export const GpsInfo = new GpsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RawGps$Type extends MessageType<RawGps> {
    constructor() {
        super("mavsdk.rpc.telemetry.RawGps", [
            { no: 1, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "hdop", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "vdop", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "velocity_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "cog_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "altitude_ellipsoid_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "horizontal_uncertainty_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "vertical_uncertainty_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "velocity_uncertainty_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "heading_uncertainty_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<RawGps>): RawGps {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestampUs = 0n;
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.hdop = 0;
        message.vdop = 0;
        message.velocityMS = 0;
        message.cogDeg = 0;
        message.altitudeEllipsoidM = 0;
        message.horizontalUncertaintyM = 0;
        message.verticalUncertaintyM = 0;
        message.velocityUncertaintyMS = 0;
        message.headingUncertaintyDeg = 0;
        message.yawDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<RawGps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RawGps): RawGps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp_us */ 1:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                case /* double latitude_deg */ 2:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 3:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 4:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float hdop */ 5:
                    message.hdop = reader.float();
                    break;
                case /* float vdop */ 6:
                    message.vdop = reader.float();
                    break;
                case /* float velocity_m_s */ 7:
                    message.velocityMS = reader.float();
                    break;
                case /* float cog_deg */ 8:
                    message.cogDeg = reader.float();
                    break;
                case /* float altitude_ellipsoid_m */ 9:
                    message.altitudeEllipsoidM = reader.float();
                    break;
                case /* float horizontal_uncertainty_m */ 10:
                    message.horizontalUncertaintyM = reader.float();
                    break;
                case /* float vertical_uncertainty_m */ 11:
                    message.verticalUncertaintyM = reader.float();
                    break;
                case /* float velocity_uncertainty_m_s */ 12:
                    message.velocityUncertaintyMS = reader.float();
                    break;
                case /* float heading_uncertainty_deg */ 13:
                    message.headingUncertaintyDeg = reader.float();
                    break;
                case /* float yaw_deg */ 14:
                    message.yawDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RawGps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp_us = 1; */
        if (message.timestampUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestampUs);
        /* double latitude_deg = 2; */
        if (message.latitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 3; */
        if (message.longitudeDeg !== 0)
            writer.tag(3, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 4; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float hdop = 5; */
        if (message.hdop !== 0)
            writer.tag(5, WireType.Bit32).float(message.hdop);
        /* float vdop = 6; */
        if (message.vdop !== 0)
            writer.tag(6, WireType.Bit32).float(message.vdop);
        /* float velocity_m_s = 7; */
        if (message.velocityMS !== 0)
            writer.tag(7, WireType.Bit32).float(message.velocityMS);
        /* float cog_deg = 8; */
        if (message.cogDeg !== 0)
            writer.tag(8, WireType.Bit32).float(message.cogDeg);
        /* float altitude_ellipsoid_m = 9; */
        if (message.altitudeEllipsoidM !== 0)
            writer.tag(9, WireType.Bit32).float(message.altitudeEllipsoidM);
        /* float horizontal_uncertainty_m = 10; */
        if (message.horizontalUncertaintyM !== 0)
            writer.tag(10, WireType.Bit32).float(message.horizontalUncertaintyM);
        /* float vertical_uncertainty_m = 11; */
        if (message.verticalUncertaintyM !== 0)
            writer.tag(11, WireType.Bit32).float(message.verticalUncertaintyM);
        /* float velocity_uncertainty_m_s = 12; */
        if (message.velocityUncertaintyMS !== 0)
            writer.tag(12, WireType.Bit32).float(message.velocityUncertaintyMS);
        /* float heading_uncertainty_deg = 13; */
        if (message.headingUncertaintyDeg !== 0)
            writer.tag(13, WireType.Bit32).float(message.headingUncertaintyDeg);
        /* float yaw_deg = 14; */
        if (message.yawDeg !== 0)
            writer.tag(14, WireType.Bit32).float(message.yawDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.RawGps
 */
export const RawGps = new RawGps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Battery$Type extends MessageType<Battery> {
    constructor() {
        super("mavsdk.rpc.telemetry.Battery", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "temperature_degc", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "voltage_v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "current_battery_a", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "capacity_consumed_ah", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 6, name: "remaining_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Battery>): Battery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.temperatureDegc = 0;
        message.voltageV = 0;
        message.currentBatteryA = 0;
        message.capacityConsumedAh = 0;
        message.remainingPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<Battery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Battery): Battery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* float temperature_degc */ 2:
                    message.temperatureDegc = reader.float();
                    break;
                case /* float voltage_v */ 3:
                    message.voltageV = reader.float();
                    break;
                case /* float current_battery_a */ 4:
                    message.currentBatteryA = reader.float();
                    break;
                case /* float capacity_consumed_ah */ 5:
                    message.capacityConsumedAh = reader.float();
                    break;
                case /* float remaining_percent */ 6:
                    message.remainingPercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Battery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* float temperature_degc = 2; */
        if (message.temperatureDegc !== 0)
            writer.tag(2, WireType.Bit32).float(message.temperatureDegc);
        /* float voltage_v = 3; */
        if (message.voltageV !== 0)
            writer.tag(3, WireType.Bit32).float(message.voltageV);
        /* float current_battery_a = 4; */
        if (message.currentBatteryA !== 0)
            writer.tag(4, WireType.Bit32).float(message.currentBatteryA);
        /* float capacity_consumed_ah = 5; */
        if (message.capacityConsumedAh !== 0)
            writer.tag(5, WireType.Bit32).float(message.capacityConsumedAh);
        /* float remaining_percent = 6; */
        if (message.remainingPercent !== 0)
            writer.tag(6, WireType.Bit32).float(message.remainingPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Battery
 */
export const Battery = new Battery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Health$Type extends MessageType<Health> {
    constructor() {
        super("mavsdk.rpc.telemetry.Health", [
            { no: 1, name: "is_gyrometer_calibration_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 2, name: "is_accelerometer_calibration_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 3, name: "is_magnetometer_calibration_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 5, name: "is_local_position_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 6, name: "is_global_position_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 7, name: "is_home_position_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 8, name: "is_armable", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } }
        ]);
    }
    create(value?: PartialMessage<Health>): Health {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isGyrometerCalibrationOk = false;
        message.isAccelerometerCalibrationOk = false;
        message.isMagnetometerCalibrationOk = false;
        message.isLocalPositionOk = false;
        message.isGlobalPositionOk = false;
        message.isHomePositionOk = false;
        message.isArmable = false;
        if (value !== undefined)
            reflectionMergePartial<Health>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Health): Health {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_gyrometer_calibration_ok */ 1:
                    message.isGyrometerCalibrationOk = reader.bool();
                    break;
                case /* bool is_accelerometer_calibration_ok */ 2:
                    message.isAccelerometerCalibrationOk = reader.bool();
                    break;
                case /* bool is_magnetometer_calibration_ok */ 3:
                    message.isMagnetometerCalibrationOk = reader.bool();
                    break;
                case /* bool is_local_position_ok */ 5:
                    message.isLocalPositionOk = reader.bool();
                    break;
                case /* bool is_global_position_ok */ 6:
                    message.isGlobalPositionOk = reader.bool();
                    break;
                case /* bool is_home_position_ok */ 7:
                    message.isHomePositionOk = reader.bool();
                    break;
                case /* bool is_armable */ 8:
                    message.isArmable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Health, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_gyrometer_calibration_ok = 1; */
        if (message.isGyrometerCalibrationOk !== false)
            writer.tag(1, WireType.Varint).bool(message.isGyrometerCalibrationOk);
        /* bool is_accelerometer_calibration_ok = 2; */
        if (message.isAccelerometerCalibrationOk !== false)
            writer.tag(2, WireType.Varint).bool(message.isAccelerometerCalibrationOk);
        /* bool is_magnetometer_calibration_ok = 3; */
        if (message.isMagnetometerCalibrationOk !== false)
            writer.tag(3, WireType.Varint).bool(message.isMagnetometerCalibrationOk);
        /* bool is_local_position_ok = 5; */
        if (message.isLocalPositionOk !== false)
            writer.tag(5, WireType.Varint).bool(message.isLocalPositionOk);
        /* bool is_global_position_ok = 6; */
        if (message.isGlobalPositionOk !== false)
            writer.tag(6, WireType.Varint).bool(message.isGlobalPositionOk);
        /* bool is_home_position_ok = 7; */
        if (message.isHomePositionOk !== false)
            writer.tag(7, WireType.Varint).bool(message.isHomePositionOk);
        /* bool is_armable = 8; */
        if (message.isArmable !== false)
            writer.tag(8, WireType.Varint).bool(message.isArmable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Health
 */
export const Health = new Health$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcStatus$Type extends MessageType<RcStatus> {
    constructor() {
        super("mavsdk.rpc.telemetry.RcStatus", [
            { no: 1, name: "was_available_once", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 2, name: "is_available", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 3, name: "signal_strength_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<RcStatus>): RcStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.wasAvailableOnce = false;
        message.isAvailable = false;
        message.signalStrengthPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<RcStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcStatus): RcStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool was_available_once */ 1:
                    message.wasAvailableOnce = reader.bool();
                    break;
                case /* bool is_available */ 2:
                    message.isAvailable = reader.bool();
                    break;
                case /* float signal_strength_percent */ 3:
                    message.signalStrengthPercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RcStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool was_available_once = 1; */
        if (message.wasAvailableOnce !== false)
            writer.tag(1, WireType.Varint).bool(message.wasAvailableOnce);
        /* bool is_available = 2; */
        if (message.isAvailable !== false)
            writer.tag(2, WireType.Varint).bool(message.isAvailable);
        /* float signal_strength_percent = 3; */
        if (message.signalStrengthPercent !== 0)
            writer.tag(3, WireType.Bit32).float(message.signalStrengthPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.RcStatus
 */
export const RcStatus = new RcStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusText$Type extends MessageType<StatusText> {
    constructor() {
        super("mavsdk.rpc.telemetry.StatusText", [
            { no: 1, name: "type", kind: "enum", T: () => ["mavsdk.rpc.telemetry.StatusTextType", StatusTextType, "STATUS_TEXT_TYPE_"] },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusText>): StatusText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<StatusText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusText): StatusText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.StatusTextType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.StatusTextType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.StatusText
 */
export const StatusText = new StatusText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorControlTarget$Type extends MessageType<ActuatorControlTarget> {
    constructor() {
        super("mavsdk.rpc.telemetry.ActuatorControlTarget", [
            { no: 1, name: "group", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "controls", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ActuatorControlTarget>): ActuatorControlTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.group = 0;
        message.controls = [];
        if (value !== undefined)
            reflectionMergePartial<ActuatorControlTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorControlTarget): ActuatorControlTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 group */ 1:
                    message.group = reader.int32();
                    break;
                case /* repeated float controls */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.controls.push(reader.float());
                    else
                        message.controls.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorControlTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 group = 1; */
        if (message.group !== 0)
            writer.tag(1, WireType.Varint).int32(message.group);
        /* repeated float controls = 2; */
        if (message.controls.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.controls.length; i++)
                writer.float(message.controls[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ActuatorControlTarget
 */
export const ActuatorControlTarget = new ActuatorControlTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorOutputStatus$Type extends MessageType<ActuatorOutputStatus> {
    constructor() {
        super("mavsdk.rpc.telemetry.ActuatorOutputStatus", [
            { no: 1, name: "active", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "actuator", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ActuatorOutputStatus>): ActuatorOutputStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.active = 0;
        message.actuator = [];
        if (value !== undefined)
            reflectionMergePartial<ActuatorOutputStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorOutputStatus): ActuatorOutputStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 active */ 1:
                    message.active = reader.uint32();
                    break;
                case /* repeated float actuator */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.actuator.push(reader.float());
                    else
                        message.actuator.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorOutputStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 active = 1; */
        if (message.active !== 0)
            writer.tag(1, WireType.Varint).uint32(message.active);
        /* repeated float actuator = 2; */
        if (message.actuator.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.actuator.length; i++)
                writer.float(message.actuator[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ActuatorOutputStatus
 */
export const ActuatorOutputStatus = new ActuatorOutputStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Covariance$Type extends MessageType<Covariance> {
    constructor() {
        super("mavsdk.rpc.telemetry.Covariance", [
            { no: 1, name: "covariance_matrix", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Covariance>): Covariance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.covarianceMatrix = [];
        if (value !== undefined)
            reflectionMergePartial<Covariance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Covariance): Covariance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float covariance_matrix */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.covarianceMatrix.push(reader.float());
                    else
                        message.covarianceMatrix.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Covariance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float covariance_matrix = 1; */
        if (message.covarianceMatrix.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.covarianceMatrix.length; i++)
                writer.float(message.covarianceMatrix[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Covariance
 */
export const Covariance = new Covariance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VelocityBody$Type extends MessageType<VelocityBody> {
    constructor() {
        super("mavsdk.rpc.telemetry.VelocityBody", [
            { no: 1, name: "x_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VelocityBody>): VelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xMS = 0;
        message.yMS = 0;
        message.zMS = 0;
        if (value !== undefined)
            reflectionMergePartial<VelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VelocityBody): VelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m_s */ 1:
                    message.xMS = reader.float();
                    break;
                case /* float y_m_s */ 2:
                    message.yMS = reader.float();
                    break;
                case /* float z_m_s */ 3:
                    message.zMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m_s = 1; */
        if (message.xMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.xMS);
        /* float y_m_s = 2; */
        if (message.yMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.yMS);
        /* float z_m_s = 3; */
        if (message.zMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.zMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.VelocityBody
 */
export const VelocityBody = new VelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionBody$Type extends MessageType<PositionBody> {
    constructor() {
        super("mavsdk.rpc.telemetry.PositionBody", [
            { no: 1, name: "x_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionBody>): PositionBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xM = 0;
        message.yM = 0;
        message.zM = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionBody): PositionBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m */ 1:
                    message.xM = reader.float();
                    break;
                case /* float y_m */ 2:
                    message.yM = reader.float();
                    break;
                case /* float z_m */ 3:
                    message.zM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m = 1; */
        if (message.xM !== 0)
            writer.tag(1, WireType.Bit32).float(message.xM);
        /* float y_m = 2; */
        if (message.yM !== 0)
            writer.tag(2, WireType.Bit32).float(message.yM);
        /* float z_m = 3; */
        if (message.zM !== 0)
            writer.tag(3, WireType.Bit32).float(message.zM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.PositionBody
 */
export const PositionBody = new PositionBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Odometry$Type extends MessageType<Odometry> {
    constructor() {
        super("mavsdk.rpc.telemetry.Odometry", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "frame_id", kind: "enum", T: () => ["mavsdk.rpc.telemetry.Odometry.MavFrame", Odometry_MavFrame, "MAV_FRAME_"] },
            { no: 3, name: "child_frame_id", kind: "enum", T: () => ["mavsdk.rpc.telemetry.Odometry.MavFrame", Odometry_MavFrame, "MAV_FRAME_"] },
            { no: 4, name: "position_body", kind: "message", T: () => PositionBody },
            { no: 5, name: "q", kind: "message", T: () => Quaternion },
            { no: 6, name: "velocity_body", kind: "message", T: () => VelocityBody },
            { no: 7, name: "angular_velocity_body", kind: "message", T: () => AngularVelocityBody },
            { no: 8, name: "pose_covariance", kind: "message", T: () => Covariance },
            { no: 9, name: "velocity_covariance", kind: "message", T: () => Covariance }
        ]);
    }
    create(value?: PartialMessage<Odometry>): Odometry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        message.frameId = 0;
        message.childFrameId = 0;
        if (value !== undefined)
            reflectionMergePartial<Odometry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Odometry): Odometry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* mavsdk.rpc.telemetry.Odometry.MavFrame frame_id */ 2:
                    message.frameId = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry.Odometry.MavFrame child_frame_id */ 3:
                    message.childFrameId = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry.PositionBody position_body */ 4:
                    message.positionBody = PositionBody.internalBinaryRead(reader, reader.uint32(), options, message.positionBody);
                    break;
                case /* mavsdk.rpc.telemetry.Quaternion q */ 5:
                    message.q = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.q);
                    break;
                case /* mavsdk.rpc.telemetry.VelocityBody velocity_body */ 6:
                    message.velocityBody = VelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.velocityBody);
                    break;
                case /* mavsdk.rpc.telemetry.AngularVelocityBody angular_velocity_body */ 7:
                    message.angularVelocityBody = AngularVelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocityBody);
                    break;
                case /* mavsdk.rpc.telemetry.Covariance pose_covariance */ 8:
                    message.poseCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.poseCovariance);
                    break;
                case /* mavsdk.rpc.telemetry.Covariance velocity_covariance */ 9:
                    message.velocityCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.velocityCovariance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Odometry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* mavsdk.rpc.telemetry.Odometry.MavFrame frame_id = 2; */
        if (message.frameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.frameId);
        /* mavsdk.rpc.telemetry.Odometry.MavFrame child_frame_id = 3; */
        if (message.childFrameId !== 0)
            writer.tag(3, WireType.Varint).int32(message.childFrameId);
        /* mavsdk.rpc.telemetry.PositionBody position_body = 4; */
        if (message.positionBody)
            PositionBody.internalBinaryWrite(message.positionBody, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.Quaternion q = 5; */
        if (message.q)
            Quaternion.internalBinaryWrite(message.q, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.VelocityBody velocity_body = 6; */
        if (message.velocityBody)
            VelocityBody.internalBinaryWrite(message.velocityBody, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.AngularVelocityBody angular_velocity_body = 7; */
        if (message.angularVelocityBody)
            AngularVelocityBody.internalBinaryWrite(message.angularVelocityBody, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.Covariance pose_covariance = 8; */
        if (message.poseCovariance)
            Covariance.internalBinaryWrite(message.poseCovariance, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.Covariance velocity_covariance = 9; */
        if (message.velocityCovariance)
            Covariance.internalBinaryWrite(message.velocityCovariance, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Odometry
 */
export const Odometry = new Odometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DistanceSensor$Type extends MessageType<DistanceSensor> {
    constructor() {
        super("mavsdk.rpc.telemetry.DistanceSensor", [
            { no: 1, name: "minimum_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "maximum_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "current_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "orientation", kind: "message", T: () => EulerAngle }
        ]);
    }
    create(value?: PartialMessage<DistanceSensor>): DistanceSensor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.minimumDistanceM = 0;
        message.maximumDistanceM = 0;
        message.currentDistanceM = 0;
        if (value !== undefined)
            reflectionMergePartial<DistanceSensor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DistanceSensor): DistanceSensor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float minimum_distance_m */ 1:
                    message.minimumDistanceM = reader.float();
                    break;
                case /* float maximum_distance_m */ 2:
                    message.maximumDistanceM = reader.float();
                    break;
                case /* float current_distance_m */ 3:
                    message.currentDistanceM = reader.float();
                    break;
                case /* mavsdk.rpc.telemetry.EulerAngle orientation */ 4:
                    message.orientation = EulerAngle.internalBinaryRead(reader, reader.uint32(), options, message.orientation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DistanceSensor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float minimum_distance_m = 1; */
        if (message.minimumDistanceM !== 0)
            writer.tag(1, WireType.Bit32).float(message.minimumDistanceM);
        /* float maximum_distance_m = 2; */
        if (message.maximumDistanceM !== 0)
            writer.tag(2, WireType.Bit32).float(message.maximumDistanceM);
        /* float current_distance_m = 3; */
        if (message.currentDistanceM !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentDistanceM);
        /* mavsdk.rpc.telemetry.EulerAngle orientation = 4; */
        if (message.orientation)
            EulerAngle.internalBinaryWrite(message.orientation, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.DistanceSensor
 */
export const DistanceSensor = new DistanceSensor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScaledPressure$Type extends MessageType<ScaledPressure> {
    constructor() {
        super("mavsdk.rpc.telemetry.ScaledPressure", [
            { no: 1, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "absolute_pressure_hpa", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "differential_pressure_hpa", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "temperature_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "differential_pressure_temperature_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ScaledPressure>): ScaledPressure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestampUs = 0n;
        message.absolutePressureHpa = 0;
        message.differentialPressureHpa = 0;
        message.temperatureDeg = 0;
        message.differentialPressureTemperatureDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<ScaledPressure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScaledPressure): ScaledPressure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp_us */ 1:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                case /* float absolute_pressure_hpa */ 2:
                    message.absolutePressureHpa = reader.float();
                    break;
                case /* float differential_pressure_hpa */ 3:
                    message.differentialPressureHpa = reader.float();
                    break;
                case /* float temperature_deg */ 4:
                    message.temperatureDeg = reader.float();
                    break;
                case /* float differential_pressure_temperature_deg */ 5:
                    message.differentialPressureTemperatureDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScaledPressure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp_us = 1; */
        if (message.timestampUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestampUs);
        /* float absolute_pressure_hpa = 2; */
        if (message.absolutePressureHpa !== 0)
            writer.tag(2, WireType.Bit32).float(message.absolutePressureHpa);
        /* float differential_pressure_hpa = 3; */
        if (message.differentialPressureHpa !== 0)
            writer.tag(3, WireType.Bit32).float(message.differentialPressureHpa);
        /* float temperature_deg = 4; */
        if (message.temperatureDeg !== 0)
            writer.tag(4, WireType.Bit32).float(message.temperatureDeg);
        /* float differential_pressure_temperature_deg = 5; */
        if (message.differentialPressureTemperatureDeg !== 0)
            writer.tag(5, WireType.Bit32).float(message.differentialPressureTemperatureDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.ScaledPressure
 */
export const ScaledPressure = new ScaledPressure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionNed$Type extends MessageType<PositionNed> {
    constructor() {
        super("mavsdk.rpc.telemetry.PositionNed", [
            { no: 1, name: "north_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "east_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<PositionNed>): PositionNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.northM = 0;
        message.eastM = 0;
        message.downM = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionNed): PositionNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float north_m */ 1:
                    message.northM = reader.float();
                    break;
                case /* float east_m */ 2:
                    message.eastM = reader.float();
                    break;
                case /* float down_m */ 3:
                    message.downM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float north_m = 1; */
        if (message.northM !== 0)
            writer.tag(1, WireType.Bit32).float(message.northM);
        /* float east_m = 2; */
        if (message.eastM !== 0)
            writer.tag(2, WireType.Bit32).float(message.eastM);
        /* float down_m = 3; */
        if (message.downM !== 0)
            writer.tag(3, WireType.Bit32).float(message.downM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.PositionNed
 */
export const PositionNed = new PositionNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VelocityNed$Type extends MessageType<VelocityNed> {
    constructor() {
        super("mavsdk.rpc.telemetry.VelocityNed", [
            { no: 1, name: "north_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "east_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "down_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VelocityNed>): VelocityNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.northMS = 0;
        message.eastMS = 0;
        message.downMS = 0;
        if (value !== undefined)
            reflectionMergePartial<VelocityNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VelocityNed): VelocityNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float north_m_s */ 1:
                    message.northMS = reader.float();
                    break;
                case /* float east_m_s */ 2:
                    message.eastMS = reader.float();
                    break;
                case /* float down_m_s */ 3:
                    message.downMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VelocityNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float north_m_s = 1; */
        if (message.northMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.northMS);
        /* float east_m_s = 2; */
        if (message.eastMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.eastMS);
        /* float down_m_s = 3; */
        if (message.downMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.downMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.VelocityNed
 */
export const VelocityNed = new VelocityNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionVelocityNed$Type extends MessageType<PositionVelocityNed> {
    constructor() {
        super("mavsdk.rpc.telemetry.PositionVelocityNed", [
            { no: 1, name: "position", kind: "message", T: () => PositionNed },
            { no: 2, name: "velocity", kind: "message", T: () => VelocityNed }
        ]);
    }
    create(value?: PartialMessage<PositionVelocityNed>): PositionVelocityNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PositionVelocityNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionVelocityNed): PositionVelocityNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.PositionNed position */ 1:
                    message.position = PositionNed.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* mavsdk.rpc.telemetry.VelocityNed velocity */ 2:
                    message.velocity = VelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionVelocityNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.PositionNed position = 1; */
        if (message.position)
            PositionNed.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.VelocityNed velocity = 2; */
        if (message.velocity)
            VelocityNed.internalBinaryWrite(message.velocity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.PositionVelocityNed
 */
export const PositionVelocityNed = new PositionVelocityNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroundTruth$Type extends MessageType<GroundTruth> {
    constructor() {
        super("mavsdk.rpc.telemetry.GroundTruth", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<GroundTruth>): GroundTruth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<GroundTruth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroundTruth): GroundTruth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroundTruth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GroundTruth
 */
export const GroundTruth = new GroundTruth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FixedwingMetrics$Type extends MessageType<FixedwingMetrics> {
    constructor() {
        super("mavsdk.rpc.telemetry.FixedwingMetrics", [
            { no: 1, name: "airspeed_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "throttle_percentage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "climb_rate_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<FixedwingMetrics>): FixedwingMetrics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.airspeedMS = 0;
        message.throttlePercentage = 0;
        message.climbRateMS = 0;
        if (value !== undefined)
            reflectionMergePartial<FixedwingMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedwingMetrics): FixedwingMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float airspeed_m_s */ 1:
                    message.airspeedMS = reader.float();
                    break;
                case /* float throttle_percentage */ 2:
                    message.throttlePercentage = reader.float();
                    break;
                case /* float climb_rate_m_s */ 3:
                    message.climbRateMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FixedwingMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float airspeed_m_s = 1; */
        if (message.airspeedMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.airspeedMS);
        /* float throttle_percentage = 2; */
        if (message.throttlePercentage !== 0)
            writer.tag(2, WireType.Bit32).float(message.throttlePercentage);
        /* float climb_rate_m_s = 3; */
        if (message.climbRateMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.climbRateMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.FixedwingMetrics
 */
export const FixedwingMetrics = new FixedwingMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccelerationFrd$Type extends MessageType<AccelerationFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry.AccelerationFrd", [
            { no: 1, name: "forward_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AccelerationFrd>): AccelerationFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardMS2 = 0;
        message.rightMS2 = 0;
        message.downMS2 = 0;
        if (value !== undefined)
            reflectionMergePartial<AccelerationFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccelerationFrd): AccelerationFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_m_s2 */ 1:
                    message.forwardMS2 = reader.float();
                    break;
                case /* float right_m_s2 */ 2:
                    message.rightMS2 = reader.float();
                    break;
                case /* float down_m_s2 */ 3:
                    message.downMS2 = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccelerationFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_m_s2 = 1; */
        if (message.forwardMS2 !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardMS2);
        /* float right_m_s2 = 2; */
        if (message.rightMS2 !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightMS2);
        /* float down_m_s2 = 3; */
        if (message.downMS2 !== 0)
            writer.tag(3, WireType.Bit32).float(message.downMS2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AccelerationFrd
 */
export const AccelerationFrd = new AccelerationFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityFrd$Type extends MessageType<AngularVelocityFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry.AngularVelocityFrd", [
            { no: 1, name: "forward_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityFrd>): AngularVelocityFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardRadS = 0;
        message.rightRadS = 0;
        message.downRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityFrd): AngularVelocityFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_rad_s */ 1:
                    message.forwardRadS = reader.float();
                    break;
                case /* float right_rad_s */ 2:
                    message.rightRadS = reader.float();
                    break;
                case /* float down_rad_s */ 3:
                    message.downRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_rad_s = 1; */
        if (message.forwardRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardRadS);
        /* float right_rad_s = 2; */
        if (message.rightRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightRadS);
        /* float down_rad_s = 3; */
        if (message.downRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.downRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.AngularVelocityFrd
 */
export const AngularVelocityFrd = new AngularVelocityFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MagneticFieldFrd$Type extends MessageType<MagneticFieldFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry.MagneticFieldFrd", [
            { no: 1, name: "forward_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<MagneticFieldFrd>): MagneticFieldFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardGauss = 0;
        message.rightGauss = 0;
        message.downGauss = 0;
        if (value !== undefined)
            reflectionMergePartial<MagneticFieldFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MagneticFieldFrd): MagneticFieldFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_gauss */ 1:
                    message.forwardGauss = reader.float();
                    break;
                case /* float right_gauss */ 2:
                    message.rightGauss = reader.float();
                    break;
                case /* float down_gauss */ 3:
                    message.downGauss = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MagneticFieldFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_gauss = 1; */
        if (message.forwardGauss !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardGauss);
        /* float right_gauss = 2; */
        if (message.rightGauss !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightGauss);
        /* float down_gauss = 3; */
        if (message.downGauss !== 0)
            writer.tag(3, WireType.Bit32).float(message.downGauss);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.MagneticFieldFrd
 */
export const MagneticFieldFrd = new MagneticFieldFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Imu$Type extends MessageType<Imu> {
    constructor() {
        super("mavsdk.rpc.telemetry.Imu", [
            { no: 1, name: "acceleration_frd", kind: "message", T: () => AccelerationFrd },
            { no: 2, name: "angular_velocity_frd", kind: "message", T: () => AngularVelocityFrd },
            { no: 3, name: "magnetic_field_frd", kind: "message", T: () => MagneticFieldFrd },
            { no: 4, name: "temperature_degc", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Imu>): Imu {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.temperatureDegc = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Imu>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Imu): Imu {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.AccelerationFrd acceleration_frd */ 1:
                    message.accelerationFrd = AccelerationFrd.internalBinaryRead(reader, reader.uint32(), options, message.accelerationFrd);
                    break;
                case /* mavsdk.rpc.telemetry.AngularVelocityFrd angular_velocity_frd */ 2:
                    message.angularVelocityFrd = AngularVelocityFrd.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocityFrd);
                    break;
                case /* mavsdk.rpc.telemetry.MagneticFieldFrd magnetic_field_frd */ 3:
                    message.magneticFieldFrd = MagneticFieldFrd.internalBinaryRead(reader, reader.uint32(), options, message.magneticFieldFrd);
                    break;
                case /* float temperature_degc */ 4:
                    message.temperatureDegc = reader.float();
                    break;
                case /* uint64 timestamp_us */ 5:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Imu, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.AccelerationFrd acceleration_frd = 1; */
        if (message.accelerationFrd)
            AccelerationFrd.internalBinaryWrite(message.accelerationFrd, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.AngularVelocityFrd angular_velocity_frd = 2; */
        if (message.angularVelocityFrd)
            AngularVelocityFrd.internalBinaryWrite(message.angularVelocityFrd, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry.MagneticFieldFrd magnetic_field_frd = 3; */
        if (message.magneticFieldFrd)
            MagneticFieldFrd.internalBinaryWrite(message.magneticFieldFrd, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* float temperature_degc = 4; */
        if (message.temperatureDegc !== 0)
            writer.tag(4, WireType.Bit32).float(message.temperatureDegc);
        /* uint64 timestamp_us = 5; */
        if (message.timestampUs !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Imu
 */
export const Imu = new Imu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpsGlobalOrigin$Type extends MessageType<GpsGlobalOrigin> {
    constructor() {
        super("mavsdk.rpc.telemetry.GpsGlobalOrigin", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<GpsGlobalOrigin>): GpsGlobalOrigin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.altitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<GpsGlobalOrigin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpsGlobalOrigin): GpsGlobalOrigin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float altitude_m */ 3:
                    message.altitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpsGlobalOrigin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float altitude_m = 3; */
        if (message.altitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.altitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.GpsGlobalOrigin
 */
export const GpsGlobalOrigin = new GpsGlobalOrigin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Altitude$Type extends MessageType<Altitude> {
    constructor() {
        super("mavsdk.rpc.telemetry.Altitude", [
            { no: 1, name: "altitude_monotonic_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "altitude_amsl_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "altitude_local_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "altitude_relative_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "altitude_terrain_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 6, name: "bottom_clearance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Altitude>): Altitude {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.altitudeMonotonicM = 0;
        message.altitudeAmslM = 0;
        message.altitudeLocalM = 0;
        message.altitudeRelativeM = 0;
        message.altitudeTerrainM = 0;
        message.bottomClearanceM = 0;
        if (value !== undefined)
            reflectionMergePartial<Altitude>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Altitude): Altitude {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float altitude_monotonic_m */ 1:
                    message.altitudeMonotonicM = reader.float();
                    break;
                case /* float altitude_amsl_m */ 2:
                    message.altitudeAmslM = reader.float();
                    break;
                case /* float altitude_local_m */ 3:
                    message.altitudeLocalM = reader.float();
                    break;
                case /* float altitude_relative_m */ 4:
                    message.altitudeRelativeM = reader.float();
                    break;
                case /* float altitude_terrain_m */ 5:
                    message.altitudeTerrainM = reader.float();
                    break;
                case /* float bottom_clearance_m */ 6:
                    message.bottomClearanceM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Altitude, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float altitude_monotonic_m = 1; */
        if (message.altitudeMonotonicM !== 0)
            writer.tag(1, WireType.Bit32).float(message.altitudeMonotonicM);
        /* float altitude_amsl_m = 2; */
        if (message.altitudeAmslM !== 0)
            writer.tag(2, WireType.Bit32).float(message.altitudeAmslM);
        /* float altitude_local_m = 3; */
        if (message.altitudeLocalM !== 0)
            writer.tag(3, WireType.Bit32).float(message.altitudeLocalM);
        /* float altitude_relative_m = 4; */
        if (message.altitudeRelativeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.altitudeRelativeM);
        /* float altitude_terrain_m = 5; */
        if (message.altitudeTerrainM !== 0)
            writer.tag(5, WireType.Bit32).float(message.altitudeTerrainM);
        /* float bottom_clearance_m = 6; */
        if (message.bottomClearanceM !== 0)
            writer.tag(6, WireType.Bit32).float(message.bottomClearanceM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.Altitude
 */
export const Altitude = new Altitude$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelemetryResult$Type extends MessageType<TelemetryResult> {
    constructor() {
        super("mavsdk.rpc.telemetry.TelemetryResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.telemetry.TelemetryResult.Result", TelemetryResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TelemetryResult>): TelemetryResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<TelemetryResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelemetryResult): TelemetryResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry.TelemetryResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelemetryResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry.TelemetryResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry.TelemetryResult
 */
export const TelemetryResult = new TelemetryResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.telemetry.TelemetryService
 */
export const TelemetryService = new ServiceType("mavsdk.rpc.telemetry.TelemetryService", [
    { name: "SubscribePosition", serverStreaming: true, options: {}, I: SubscribePositionRequest, O: PositionResponse },
    { name: "SubscribeHome", serverStreaming: true, options: {}, I: SubscribeHomeRequest, O: HomeResponse },
    { name: "SubscribeInAir", serverStreaming: true, options: {}, I: SubscribeInAirRequest, O: InAirResponse },
    { name: "SubscribeLandedState", serverStreaming: true, options: {}, I: SubscribeLandedStateRequest, O: LandedStateResponse },
    { name: "SubscribeArmed", serverStreaming: true, options: {}, I: SubscribeArmedRequest, O: ArmedResponse },
    { name: "SubscribeVtolState", serverStreaming: true, options: {}, I: SubscribeVtolStateRequest, O: VtolStateResponse },
    { name: "SubscribeAttitudeQuaternion", serverStreaming: true, options: {}, I: SubscribeAttitudeQuaternionRequest, O: AttitudeQuaternionResponse },
    { name: "SubscribeAttitudeEuler", serverStreaming: true, options: {}, I: SubscribeAttitudeEulerRequest, O: AttitudeEulerResponse },
    { name: "SubscribeAttitudeAngularVelocityBody", serverStreaming: true, options: {}, I: SubscribeAttitudeAngularVelocityBodyRequest, O: AttitudeAngularVelocityBodyResponse },
    { name: "SubscribeVelocityNed", serverStreaming: true, options: {}, I: SubscribeVelocityNedRequest, O: VelocityNedResponse },
    { name: "SubscribeGpsInfo", serverStreaming: true, options: {}, I: SubscribeGpsInfoRequest, O: GpsInfoResponse },
    { name: "SubscribeRawGps", serverStreaming: true, options: {}, I: SubscribeRawGpsRequest, O: RawGpsResponse },
    { name: "SubscribeBattery", serverStreaming: true, options: {}, I: SubscribeBatteryRequest, O: BatteryResponse },
    { name: "SubscribeFlightMode", serverStreaming: true, options: {}, I: SubscribeFlightModeRequest, O: FlightModeResponse },
    { name: "SubscribeHealth", serverStreaming: true, options: {}, I: SubscribeHealthRequest, O: HealthResponse },
    { name: "SubscribeRcStatus", serverStreaming: true, options: {}, I: SubscribeRcStatusRequest, O: RcStatusResponse },
    { name: "SubscribeStatusText", serverStreaming: true, options: {}, I: SubscribeStatusTextRequest, O: StatusTextResponse },
    { name: "SubscribeActuatorControlTarget", serverStreaming: true, options: {}, I: SubscribeActuatorControlTargetRequest, O: ActuatorControlTargetResponse },
    { name: "SubscribeActuatorOutputStatus", serverStreaming: true, options: {}, I: SubscribeActuatorOutputStatusRequest, O: ActuatorOutputStatusResponse },
    { name: "SubscribeOdometry", serverStreaming: true, options: {}, I: SubscribeOdometryRequest, O: OdometryResponse },
    { name: "SubscribePositionVelocityNed", serverStreaming: true, options: {}, I: SubscribePositionVelocityNedRequest, O: PositionVelocityNedResponse },
    { name: "SubscribeGroundTruth", serverStreaming: true, options: {}, I: SubscribeGroundTruthRequest, O: GroundTruthResponse },
    { name: "SubscribeFixedwingMetrics", serverStreaming: true, options: {}, I: SubscribeFixedwingMetricsRequest, O: FixedwingMetricsResponse },
    { name: "SubscribeImu", serverStreaming: true, options: {}, I: SubscribeImuRequest, O: ImuResponse },
    { name: "SubscribeScaledImu", serverStreaming: true, options: {}, I: SubscribeScaledImuRequest, O: ScaledImuResponse },
    { name: "SubscribeRawImu", serverStreaming: true, options: {}, I: SubscribeRawImuRequest, O: RawImuResponse },
    { name: "SubscribeHealthAllOk", serverStreaming: true, options: {}, I: SubscribeHealthAllOkRequest, O: HealthAllOkResponse },
    { name: "SubscribeUnixEpochTime", serverStreaming: true, options: {}, I: SubscribeUnixEpochTimeRequest, O: UnixEpochTimeResponse },
    { name: "SubscribeDistanceSensor", serverStreaming: true, options: {}, I: SubscribeDistanceSensorRequest, O: DistanceSensorResponse },
    { name: "SubscribeScaledPressure", serverStreaming: true, options: {}, I: SubscribeScaledPressureRequest, O: ScaledPressureResponse },
    { name: "SubscribeHeading", serverStreaming: true, options: {}, I: SubscribeHeadingRequest, O: HeadingResponse },
    { name: "SubscribeAltitude", serverStreaming: true, options: {}, I: SubscribeAltitudeRequest, O: AltitudeResponse },
    { name: "SetRatePosition", options: {}, I: SetRatePositionRequest, O: SetRatePositionResponse },
    { name: "SetRateHome", options: {}, I: SetRateHomeRequest, O: SetRateHomeResponse },
    { name: "SetRateInAir", options: {}, I: SetRateInAirRequest, O: SetRateInAirResponse },
    { name: "SetRateLandedState", options: {}, I: SetRateLandedStateRequest, O: SetRateLandedStateResponse },
    { name: "SetRateVtolState", options: {}, I: SetRateVtolStateRequest, O: SetRateVtolStateResponse },
    { name: "SetRateAttitudeQuaternion", options: {}, I: SetRateAttitudeQuaternionRequest, O: SetRateAttitudeQuaternionResponse },
    { name: "SetRateAttitudeEuler", options: {}, I: SetRateAttitudeEulerRequest, O: SetRateAttitudeEulerResponse },
    { name: "SetRateVelocityNed", options: {}, I: SetRateVelocityNedRequest, O: SetRateVelocityNedResponse },
    { name: "SetRateGpsInfo", options: {}, I: SetRateGpsInfoRequest, O: SetRateGpsInfoResponse },
    { name: "SetRateBattery", options: {}, I: SetRateBatteryRequest, O: SetRateBatteryResponse },
    { name: "SetRateRcStatus", options: {}, I: SetRateRcStatusRequest, O: SetRateRcStatusResponse },
    { name: "SetRateActuatorControlTarget", options: {}, I: SetRateActuatorControlTargetRequest, O: SetRateActuatorControlTargetResponse },
    { name: "SetRateActuatorOutputStatus", options: {}, I: SetRateActuatorOutputStatusRequest, O: SetRateActuatorOutputStatusResponse },
    { name: "SetRateOdometry", options: {}, I: SetRateOdometryRequest, O: SetRateOdometryResponse },
    { name: "SetRatePositionVelocityNed", options: {}, I: SetRatePositionVelocityNedRequest, O: SetRatePositionVelocityNedResponse },
    { name: "SetRateGroundTruth", options: {}, I: SetRateGroundTruthRequest, O: SetRateGroundTruthResponse },
    { name: "SetRateFixedwingMetrics", options: {}, I: SetRateFixedwingMetricsRequest, O: SetRateFixedwingMetricsResponse },
    { name: "SetRateImu", options: {}, I: SetRateImuRequest, O: SetRateImuResponse },
    { name: "SetRateScaledImu", options: {}, I: SetRateScaledImuRequest, O: SetRateScaledImuResponse },
    { name: "SetRateRawImu", options: {}, I: SetRateRawImuRequest, O: SetRateRawImuResponse },
    { name: "SetRateUnixEpochTime", options: {}, I: SetRateUnixEpochTimeRequest, O: SetRateUnixEpochTimeResponse },
    { name: "SetRateDistanceSensor", options: {}, I: SetRateDistanceSensorRequest, O: SetRateDistanceSensorResponse },
    { name: "SetRateAltitude", options: {}, I: SetRateAltitudeRequest, O: SetRateAltitudeResponse },
    { name: "GetGpsGlobalOrigin", options: {}, I: GetGpsGlobalOriginRequest, O: GetGpsGlobalOriginResponse }
]);
