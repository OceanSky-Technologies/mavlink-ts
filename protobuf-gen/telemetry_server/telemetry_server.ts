/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "telemetry_server/telemetry_server.proto" (package "mavsdk.rpc.telemetry_server", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishPositionRequest
 */
export interface PublishPositionRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Position position = 1;
     */
    position?: Position; // The next position
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.VelocityNed velocity_ned = 2;
     */
    velocityNed?: VelocityNed; // The next velocity (NED)
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Heading heading = 3;
     */
    heading?: Heading; // Heading (yaw) in degrees
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishHomeRequest
 */
export interface PublishHomeRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Position home = 1;
     */
    home?: Position; // The next home position
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishSysStatusRequest
 */
export interface PublishSysStatusRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Battery battery = 1;
     */
    battery?: Battery; // The next 'battery' state
    /**
     * @generated from protobuf field: bool rc_receiver_status = 2;
     */
    rcReceiverStatus: boolean; // rc receiver status
    /**
     * @generated from protobuf field: bool gyro_status = 3;
     */
    gyroStatus: boolean;
    /**
     * @generated from protobuf field: bool accel_status = 4;
     */
    accelStatus: boolean;
    /**
     * @generated from protobuf field: bool mag_status = 5;
     */
    magStatus: boolean;
    /**
     * @generated from protobuf field: bool gps_status = 6;
     */
    gpsStatus: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishExtendedSysStateRequest
 */
export interface PublishExtendedSysStateRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.VtolState vtol_state = 1;
     */
    vtolState: VtolState;
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.LandedState landed_state = 2;
     */
    landedState: LandedState;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishInAirRequest
 */
export interface PublishInAirRequest {
    /**
     * @generated from protobuf field: bool is_in_air = 1;
     */
    isInAir: boolean; // The next 'in-air' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishLandedStateRequest
 */
export interface PublishLandedStateRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.LandedState landed_state = 1;
     */
    landedState: LandedState; // The next 'landed' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishRawGpsRequest
 */
export interface PublishRawGpsRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.RawGps raw_gps = 1;
     */
    rawGps?: RawGps; // The next 'Raw GPS' state. Warning: this is an advanced feature, use `Position` updates to get the location of the drone!
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.GpsInfo gps_info = 2;
     */
    gpsInfo?: GpsInfo; // The next 'GPS info' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishBatteryRequest
 */
export interface PublishBatteryRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Battery battery = 1;
     */
    battery?: Battery; // The next 'battery' state
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishRcStatusRequest
 */
export interface PublishRcStatusRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.RcStatus rc_status = 1;
     */
    rcStatus?: RcStatus; // The next RC status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishStatusTextRequest
 */
export interface PublishStatusTextRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.StatusText status_text = 1;
     */
    statusText?: StatusText; // The next 'status text'
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishOdometryRequest
 */
export interface PublishOdometryRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Odometry odometry = 1;
     */
    odometry?: Odometry; // The next odometry status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishPositionVelocityNedRequest
 */
export interface PublishPositionVelocityNedRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.PositionVelocityNed position_velocity_ned = 1;
     */
    positionVelocityNed?: PositionVelocityNed; // The next position and velocity status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishGroundTruthRequest
 */
export interface PublishGroundTruthRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.GroundTruth ground_truth = 1;
     */
    groundTruth?: GroundTruth; // Ground truth position information available in simulation
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishImuRequest
 */
export interface PublishImuRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Imu imu = 1;
     */
    imu?: Imu; // The next IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishScaledImuRequest
 */
export interface PublishScaledImuRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Imu imu = 1;
     */
    imu?: Imu; // The next scaled IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishRawImuRequest
 */
export interface PublishRawImuRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Imu imu = 1;
     */
    imu?: Imu; // The next raw IMU status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishUnixEpochTimeRequest
 */
export interface PublishUnixEpochTimeRequest {
    /**
     * @generated from protobuf field: uint64 time_us = 1;
     */
    timeUs: bigint; // The next 'unix epoch time' status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishDistanceSensorRequest
 */
export interface PublishDistanceSensorRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.DistanceSensor distance_sensor = 1;
     */
    distanceSensor?: DistanceSensor; // The next 'Distance Sensor' status
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishPositionResponse
 */
export interface PublishPositionResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishHomeResponse
 */
export interface PublishHomeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishSysStatusResponse
 */
export interface PublishSysStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishExtendedSysStateResponse
 */
export interface PublishExtendedSysStateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishRawGpsResponse
 */
export interface PublishRawGpsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishBatteryResponse
 */
export interface PublishBatteryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishStatusTextResponse
 */
export interface PublishStatusTextResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishOdometryResponse
 */
export interface PublishOdometryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishPositionVelocityNedResponse
 */
export interface PublishPositionVelocityNedResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishGroundTruthResponse
 */
export interface PublishGroundTruthResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishImuResponse
 */
export interface PublishImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishScaledImuResponse
 */
export interface PublishScaledImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishRawImuResponse
 */
export interface PublishRawImuResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishUnixEpochTimeResponse
 */
export interface PublishUnixEpochTimeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PublishDistanceSensorResponse
 */
export interface PublishDistanceSensorResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1;
     */
    telemetryServerResult?: TelemetryServerResult;
}
/**
 * Position type in global coordinates.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to +180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float relative_altitude_m = 4;
     */
    relativeAltitudeM: number; // Altitude relative to takeoff altitude in metres
}
/**
 * Heading type used for global position
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Heading
 */
export interface Heading {
    /**
     * @generated from protobuf field: double heading_deg = 1;
     */
    headingDeg: number; // Heading in degrees (range: 0 to +360)
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
    /**
     * @generated from protobuf field: uint64 timestamp_us = 5;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 *
 * Euler angle type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
 *
 * For more info see https://en.wikipedia.org/wiki/Euler_angles
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.EulerAngle
 */
export interface EulerAngle {
    /**
     * @generated from protobuf field: float roll_deg = 1;
     */
    rollDeg: number; // Roll angle in degrees, positive is banking to the right
    /**
     * @generated from protobuf field: float pitch_deg = 2;
     */
    pitchDeg: number; // Pitch angle in degrees, positive is pitching nose up
    /**
     * @generated from protobuf field: float yaw_deg = 3;
     */
    yawDeg: number; // Yaw angle in degrees, positive is clock-wise seen from above
    /**
     * @generated from protobuf field: uint64 timestamp_us = 4;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 * Angular velocity type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.AngularVelocityBody
 */
export interface AngularVelocityBody {
    /**
     * @generated from protobuf field: float roll_rad_s = 1;
     */
    rollRadS: number; // Roll angular velocity
    /**
     * @generated from protobuf field: float pitch_rad_s = 2;
     */
    pitchRadS: number; // Pitch angular velocity
    /**
     * @generated from protobuf field: float yaw_rad_s = 3;
     */
    yawRadS: number; // Yaw angular velocity
}
/**
 * GPS information type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.GpsInfo
 */
export interface GpsInfo {
    /**
     * @generated from protobuf field: int32 num_satellites = 1;
     */
    numSatellites: number; // Number of visible satellites in use
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.FixType fix_type = 2;
     */
    fixType: FixType; // Fix type
}
/**
 *
 * Raw GPS information type.
 *
 * Warning: this is an advanced type! If you want the location of the drone, use
 * the position instead. This message exposes the raw values of the GNSS sensor.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.RawGps
 */
export interface RawGps {
    /**
     * @generated from protobuf field: uint64 timestamp_us = 1;
     */
    timestampUs: bigint; // Timestamp in microseconds (UNIX Epoch time or time since system boot, to be inferred)
    /**
     * @generated from protobuf field: double latitude_deg = 2;
     */
    latitudeDeg: number; // Latitude in degrees (WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: double longitude_deg = 3;
     */
    longitudeDeg: number; // Longitude in degrees (WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 4;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float hdop = 5;
     */
    hdop: number; // GPS HDOP horizontal dilution of position (unitless). If unknown, set to NaN
    /**
     * @generated from protobuf field: float vdop = 6;
     */
    vdop: number; // GPS VDOP vertical dilution of position (unitless). If unknown, set to NaN
    /**
     * @generated from protobuf field: float velocity_m_s = 7;
     */
    velocityMS: number; // Ground velocity in metres per second
    /**
     * @generated from protobuf field: float cog_deg = 8;
     */
    cogDeg: number; // Course over ground (NOT heading, but direction of movement) in degrees. If unknown, set to NaN
    /**
     * @generated from protobuf field: float altitude_ellipsoid_m = 9;
     */
    altitudeEllipsoidM: number; // Altitude in metres (above WGS84, EGM96 ellipsoid)
    /**
     * @generated from protobuf field: float horizontal_uncertainty_m = 10;
     */
    horizontalUncertaintyM: number; // Position uncertainty in metres
    /**
     * @generated from protobuf field: float vertical_uncertainty_m = 11;
     */
    verticalUncertaintyM: number; // Altitude uncertainty in metres
    /**
     * @generated from protobuf field: float velocity_uncertainty_m_s = 12;
     */
    velocityUncertaintyMS: number; // Velocity uncertainty in metres per second
    /**
     * @generated from protobuf field: float heading_uncertainty_deg = 13;
     */
    headingUncertaintyDeg: number; // Heading uncertainty in degrees
    /**
     * @generated from protobuf field: float yaw_deg = 14;
     */
    yawDeg: number; // Yaw in earth frame from north.
}
/**
 * Battery type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Battery
 */
export interface Battery {
    /**
     * @generated from protobuf field: float voltage_v = 1;
     */
    voltageV: number; // Voltage in volts
    /**
     * @generated from protobuf field: float remaining_percent = 2;
     */
    remainingPercent: number; // Estimated battery remaining (range: 0.0 to 1.0)
}
/**
 * Remote control status type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.RcStatus
 */
export interface RcStatus {
    /**
     * @generated from protobuf field: bool was_available_once = 1;
     */
    wasAvailableOnce: boolean; // True if an RC signal has been available once
    /**
     * @generated from protobuf field: bool is_available = 2;
     */
    isAvailable: boolean; // True if the RC signal is available now
    /**
     * @generated from protobuf field: float signal_strength_percent = 3;
     */
    signalStrengthPercent: number; // Signal strength (range: 0 to 100, NaN if unknown)
}
/**
 * StatusText information type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.StatusText
 */
export interface StatusText {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.StatusTextType type = 1;
     */
    type: StatusTextType; // Message type
    /**
     * @generated from protobuf field: string text = 2;
     */
    text: string; // MAVLink status message
}
/**
 * Actuator control target type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.ActuatorControlTarget
 */
export interface ActuatorControlTarget {
    /**
     * @generated from protobuf field: int32 group = 1;
     */
    group: number; // An actuator control group is e.g. 'attitude' for the core flight controls, or 'gimbal' for a payload.
    /**
     * @generated from protobuf field: repeated float controls = 2;
     */
    controls: number[]; // Controls normed from -1 to 1, where 0 is neutral position.
}
/**
 * Actuator output status type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.ActuatorOutputStatus
 */
export interface ActuatorOutputStatus {
    /**
     * @generated from protobuf field: uint32 active = 1;
     */
    active: number; // Active outputs
    /**
     * @generated from protobuf field: repeated float actuator = 2;
     */
    actuator: number[]; // Servo/motor output values
}
/**
 *
 * Covariance type.
 *
 * Row-major representation of a 6x6 cross-covariance matrix
 * upper right triangle.
 * Set first to NaN if unknown.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Covariance
 */
export interface Covariance {
    /**
     * @generated from protobuf field: repeated float covariance_matrix = 1;
     */
    covarianceMatrix: number[]; // Representation of a covariance matrix.
}
/**
 * Velocity type, represented in the Body (X Y Z) frame and in metres/second.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.VelocityBody
 */
export interface VelocityBody {
    /**
     * @generated from protobuf field: float x_m_s = 1;
     */
    xMS: number; // Velocity in X in metres/second
    /**
     * @generated from protobuf field: float y_m_s = 2;
     */
    yMS: number; // Velocity in Y in metres/second
    /**
     * @generated from protobuf field: float z_m_s = 3;
     */
    zMS: number; // Velocity in Z in metres/second
}
/**
 * Position type, represented in the Body (X Y Z) frame
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PositionBody
 */
export interface PositionBody {
    /**
     * @generated from protobuf field: float x_m = 1;
     */
    xM: number; // X Position in metres.
    /**
     * @generated from protobuf field: float y_m = 2;
     */
    yM: number; // Y Position in metres.
    /**
     * @generated from protobuf field: float z_m = 3;
     */
    zM: number; // Z Position in metres.
}
/**
 * Odometry message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Odometry
 */
export interface Odometry {
    /**
     * @generated from protobuf field: uint64 time_usec = 1;
     */
    timeUsec: bigint; // Timestamp (0 to use Backend timestamp).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Odometry.MavFrame frame_id = 2;
     */
    frameId: Odometry_MavFrame; // Coordinate frame of reference for the pose data.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Odometry.MavFrame child_frame_id = 3;
     */
    childFrameId: Odometry_MavFrame; // Coordinate frame of reference for the velocity in free space (twist) data.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.PositionBody position_body = 4;
     */
    positionBody?: PositionBody; // Position.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Quaternion q = 5;
     */
    q?: Quaternion; // Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.VelocityBody velocity_body = 6;
     */
    velocityBody?: VelocityBody; // Linear velocity (m/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.AngularVelocityBody angular_velocity_body = 7;
     */
    angularVelocityBody?: AngularVelocityBody; // Angular velocity (rad/s).
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Covariance pose_covariance = 8;
     */
    poseCovariance?: Covariance; // Pose cross-covariance matrix.
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.Covariance velocity_covariance = 9;
     */
    velocityCovariance?: Covariance; // Velocity cross-covariance matrix.
}
/**
 * Mavlink frame id
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.Odometry.MavFrame
 */
export enum Odometry_MavFrame {
    /**
     * Frame is undefined.
     *
     * @generated from protobuf enum value: MAV_FRAME_UNDEF = 0;
     */
    UNDEF = 0,
    /**
     * Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.
     *
     * @generated from protobuf enum value: MAV_FRAME_BODY_NED = 8;
     */
    BODY_NED = 8,
    /**
     * Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down).
     *
     * @generated from protobuf enum value: MAV_FRAME_VISION_NED = 16;
     */
    VISION_NED = 16,
    /**
     * Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down).
     *
     * @generated from protobuf enum value: MAV_FRAME_ESTIM_NED = 18;
     */
    ESTIM_NED = 18
}
/**
 * DistanceSensor message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.DistanceSensor
 */
export interface DistanceSensor {
    /**
     * @generated from protobuf field: float minimum_distance_m = 1;
     */
    minimumDistanceM: number; // Minimum distance the sensor can measure, NaN if unknown.
    /**
     * @generated from protobuf field: float maximum_distance_m = 2;
     */
    maximumDistanceM: number; // Maximum distance the sensor can measure, NaN if unknown.
    /**
     * @generated from protobuf field: float current_distance_m = 3;
     */
    currentDistanceM: number; // Current distance reading, NaN if unknown.
}
/**
 * Scaled Pressure message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.ScaledPressure
 */
export interface ScaledPressure {
    /**
     * @generated from protobuf field: uint64 timestamp_us = 1;
     */
    timestampUs: bigint; // Timestamp (time since system boot)
    /**
     * @generated from protobuf field: float absolute_pressure_hpa = 2;
     */
    absolutePressureHpa: number; // Absolute pressure in hPa
    /**
     * @generated from protobuf field: float differential_pressure_hpa = 3;
     */
    differentialPressureHpa: number; // Differential pressure 1 in hPa
    /**
     * @generated from protobuf field: float temperature_deg = 4;
     */
    temperatureDeg: number; // Absolute pressure temperature (in celsius)
    /**
     * @generated from protobuf field: float differential_pressure_temperature_deg = 5;
     */
    differentialPressureTemperatureDeg: number; // Differential pressure temperature (in celsius, 0 if not available)
}
/**
 * PositionNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PositionNed
 */
export interface PositionNed {
    /**
     * @generated from protobuf field: float north_m = 1;
     */
    northM: number; // Position along north direction in metres
    /**
     * @generated from protobuf field: float east_m = 2;
     */
    eastM: number; // Position along east direction in metres
    /**
     * @generated from protobuf field: float down_m = 3;
     */
    downM: number; // Position along down direction in metres
}
/**
 * VelocityNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.VelocityNed
 */
export interface VelocityNed {
    /**
     * @generated from protobuf field: float north_m_s = 1;
     */
    northMS: number; // Velocity along north direction in metres per second
    /**
     * @generated from protobuf field: float east_m_s = 2;
     */
    eastMS: number; // Velocity along east direction in metres per second
    /**
     * @generated from protobuf field: float down_m_s = 3;
     */
    downMS: number; // Velocity along down direction in metres per second
}
/**
 * PositionVelocityNed message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.PositionVelocityNed
 */
export interface PositionVelocityNed {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.PositionNed position = 1;
     */
    position?: PositionNed; // Position (NED)
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.VelocityNed velocity = 2;
     */
    velocity?: VelocityNed; // Velocity (NED)
}
/**
 * GroundTruth message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.GroundTruth
 */
export interface GroundTruth {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to 180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
}
/**
 * FixedwingMetrics message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.FixedwingMetrics
 */
export interface FixedwingMetrics {
    /**
     * @generated from protobuf field: float airspeed_m_s = 1;
     */
    airspeedMS: number; // Current indicated airspeed (IAS) in metres per second
    /**
     * @generated from protobuf field: float throttle_percentage = 2;
     */
    throttlePercentage: number; // Current throttle setting (0 to 100)
    /**
     * @generated from protobuf field: float climb_rate_m_s = 3;
     */
    climbRateMS: number; // Current climb rate in metres per second
}
/**
 * AccelerationFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.AccelerationFrd
 */
export interface AccelerationFrd {
    /**
     * @generated from protobuf field: float forward_m_s2 = 1;
     */
    forwardMS2: number; // Acceleration in forward direction in metres per second^2
    /**
     * @generated from protobuf field: float right_m_s2 = 2;
     */
    rightMS2: number; // Acceleration in right direction in metres per second^2
    /**
     * @generated from protobuf field: float down_m_s2 = 3;
     */
    downMS2: number; // Acceleration in down direction in metres per second^2
}
/**
 * AngularVelocityFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.AngularVelocityFrd
 */
export interface AngularVelocityFrd {
    /**
     * @generated from protobuf field: float forward_rad_s = 1;
     */
    forwardRadS: number; // Angular velocity in forward direction in radians per second
    /**
     * @generated from protobuf field: float right_rad_s = 2;
     */
    rightRadS: number; // Angular velocity in right direction in radians per second
    /**
     * @generated from protobuf field: float down_rad_s = 3;
     */
    downRadS: number; // Angular velocity in Down direction in radians per second
}
/**
 * MagneticFieldFrd message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.MagneticFieldFrd
 */
export interface MagneticFieldFrd {
    /**
     * @generated from protobuf field: float forward_gauss = 1;
     */
    forwardGauss: number; // Magnetic field in forward direction measured in Gauss
    /**
     * @generated from protobuf field: float right_gauss = 2;
     */
    rightGauss: number; // Magnetic field in East direction measured in Gauss
    /**
     * @generated from protobuf field: float down_gauss = 3;
     */
    downGauss: number; // Magnetic field in Down direction measured in Gauss
}
/**
 * Imu message type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.Imu
 */
export interface Imu {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.AccelerationFrd acceleration_frd = 1;
     */
    accelerationFrd?: AccelerationFrd; // Acceleration
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.AngularVelocityFrd angular_velocity_frd = 2;
     */
    angularVelocityFrd?: AngularVelocityFrd; // Angular velocity
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.MagneticFieldFrd magnetic_field_frd = 3;
     */
    magneticFieldFrd?: MagneticFieldFrd; // Magnetic field
    /**
     * @generated from protobuf field: float temperature_degc = 4;
     */
    temperatureDegc: number; // Temperature
    /**
     * @generated from protobuf field: uint64 timestamp_us = 5;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.telemetry_server.TelemetryServerResult
 */
export interface TelemetryServerResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.telemetry_server.TelemetryServerResult.Result result = 1;
     */
    result: TelemetryServerResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for telemetry requests.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.TelemetryServerResult.Result
 */
export enum TelemetryServerResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Success: the telemetry command was accepted by the vehicle
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Connection error
     *
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 3;
     */
    CONNECTION_ERROR = 3,
    /**
     * Vehicle is busy
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Command refused by vehicle
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED = 5;
     */
    COMMAND_DENIED = 5,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * Request not supported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 7;
     */
    UNSUPPORTED = 7
}
/**
 * GPS fix type.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.FixType
 */
export enum FixType {
    /**
     * No GPS connected
     *
     * @generated from protobuf enum value: FIX_TYPE_NO_GPS = 0;
     */
    NO_GPS = 0,
    /**
     * No position information, GPS is connected
     *
     * @generated from protobuf enum value: FIX_TYPE_NO_FIX = 1;
     */
    NO_FIX = 1,
    /**
     * 2D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_2D = 2;
     */
    FIX_2D = 2,
    /**
     * 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_3D = 3;
     */
    FIX_3D = 3,
    /**
     * DGPS/SBAS aided 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_FIX_DGPS = 4;
     */
    FIX_DGPS = 4,
    /**
     * RTK float, 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_RTK_FLOAT = 5;
     */
    RTK_FLOAT = 5,
    /**
     * RTK Fixed, 3D position
     *
     * @generated from protobuf enum value: FIX_TYPE_RTK_FIXED = 6;
     */
    RTK_FIXED = 6
}
/**
 * Maps to MAV_VTOL_STATE
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.VtolState
 */
export enum VtolState {
    /**
     * Not VTOL
     *
     * @generated from protobuf enum value: VTOL_STATE_UNDEFINED = 0;
     */
    UNDEFINED = 0,
    /**
     * Transitioning to fixed-wing
     *
     * @generated from protobuf enum value: VTOL_STATE_TRANSITION_TO_FW = 1;
     */
    TRANSITION_TO_FW = 1,
    /**
     * Transitioning to multi-copter
     *
     * @generated from protobuf enum value: VTOL_STATE_TRANSITION_TO_MC = 2;
     */
    TRANSITION_TO_MC = 2,
    /**
     * Multi-copter
     *
     * @generated from protobuf enum value: VTOL_STATE_MC = 3;
     */
    MC = 3,
    /**
     * Fixed-wing
     *
     * @generated from protobuf enum value: VTOL_STATE_FW = 4;
     */
    FW = 4
}
/**
 * Status types.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.StatusTextType
 */
export enum StatusTextType {
    /**
     * Debug
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_DEBUG = 0;
     */
    DEBUG = 0,
    /**
     * Information
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_INFO = 1;
     */
    INFO = 1,
    /**
     * Notice
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_NOTICE = 2;
     */
    NOTICE = 2,
    /**
     * Warning
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_WARNING = 3;
     */
    WARNING = 3,
    /**
     * Error
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_ERROR = 4;
     */
    ERROR = 4,
    /**
     * Critical
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_CRITICAL = 5;
     */
    CRITICAL = 5,
    /**
     * Alert
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_ALERT = 6;
     */
    ALERT = 6,
    /**
     * Emergency
     *
     * @generated from protobuf enum value: STATUS_TEXT_TYPE_EMERGENCY = 7;
     */
    EMERGENCY = 7
}
/**
 * Landed State enumeration.
 *
 * @generated from protobuf enum mavsdk.rpc.telemetry_server.LandedState
 */
export enum LandedState {
    /**
     * Landed state is unknown
     *
     * @generated from protobuf enum value: LANDED_STATE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * The vehicle is on the ground
     *
     * @generated from protobuf enum value: LANDED_STATE_ON_GROUND = 1;
     */
    ON_GROUND = 1,
    /**
     * The vehicle is in the air
     *
     * @generated from protobuf enum value: LANDED_STATE_IN_AIR = 2;
     */
    IN_AIR = 2,
    /**
     * The vehicle is taking off
     *
     * @generated from protobuf enum value: LANDED_STATE_TAKING_OFF = 3;
     */
    TAKING_OFF = 3,
    /**
     * The vehicle is landing
     *
     * @generated from protobuf enum value: LANDED_STATE_LANDING = 4;
     */
    LANDING = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class PublishPositionRequest$Type extends MessageType<PublishPositionRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishPositionRequest", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "velocity_ned", kind: "message", T: () => VelocityNed },
            { no: 3, name: "heading", kind: "message", T: () => Heading }
        ]);
    }
    create(value?: PartialMessage<PublishPositionRequest>): PublishPositionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishPositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishPositionRequest): PublishPositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* mavsdk.rpc.telemetry_server.VelocityNed velocity_ned */ 2:
                    message.velocityNed = VelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.velocityNed);
                    break;
                case /* mavsdk.rpc.telemetry_server.Heading heading */ 3:
                    message.heading = Heading.internalBinaryRead(reader, reader.uint32(), options, message.heading);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishPositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.VelocityNed velocity_ned = 2; */
        if (message.velocityNed)
            VelocityNed.internalBinaryWrite(message.velocityNed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.Heading heading = 3; */
        if (message.heading)
            Heading.internalBinaryWrite(message.heading, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishPositionRequest
 */
export const PublishPositionRequest = new PublishPositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishHomeRequest$Type extends MessageType<PublishHomeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishHomeRequest", [
            { no: 1, name: "home", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<PublishHomeRequest>): PublishHomeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishHomeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishHomeRequest): PublishHomeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Position home */ 1:
                    message.home = Position.internalBinaryRead(reader, reader.uint32(), options, message.home);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishHomeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Position home = 1; */
        if (message.home)
            Position.internalBinaryWrite(message.home, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishHomeRequest
 */
export const PublishHomeRequest = new PublishHomeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishSysStatusRequest$Type extends MessageType<PublishSysStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishSysStatusRequest", [
            { no: 1, name: "battery", kind: "message", T: () => Battery },
            { no: 2, name: "rc_receiver_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "gyro_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "accel_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "mag_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "gps_status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PublishSysStatusRequest>): PublishSysStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rcReceiverStatus = false;
        message.gyroStatus = false;
        message.accelStatus = false;
        message.magStatus = false;
        message.gpsStatus = false;
        if (value !== undefined)
            reflectionMergePartial<PublishSysStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishSysStatusRequest): PublishSysStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Battery battery */ 1:
                    message.battery = Battery.internalBinaryRead(reader, reader.uint32(), options, message.battery);
                    break;
                case /* bool rc_receiver_status */ 2:
                    message.rcReceiverStatus = reader.bool();
                    break;
                case /* bool gyro_status */ 3:
                    message.gyroStatus = reader.bool();
                    break;
                case /* bool accel_status */ 4:
                    message.accelStatus = reader.bool();
                    break;
                case /* bool mag_status */ 5:
                    message.magStatus = reader.bool();
                    break;
                case /* bool gps_status */ 6:
                    message.gpsStatus = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishSysStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Battery battery = 1; */
        if (message.battery)
            Battery.internalBinaryWrite(message.battery, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool rc_receiver_status = 2; */
        if (message.rcReceiverStatus !== false)
            writer.tag(2, WireType.Varint).bool(message.rcReceiverStatus);
        /* bool gyro_status = 3; */
        if (message.gyroStatus !== false)
            writer.tag(3, WireType.Varint).bool(message.gyroStatus);
        /* bool accel_status = 4; */
        if (message.accelStatus !== false)
            writer.tag(4, WireType.Varint).bool(message.accelStatus);
        /* bool mag_status = 5; */
        if (message.magStatus !== false)
            writer.tag(5, WireType.Varint).bool(message.magStatus);
        /* bool gps_status = 6; */
        if (message.gpsStatus !== false)
            writer.tag(6, WireType.Varint).bool(message.gpsStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishSysStatusRequest
 */
export const PublishSysStatusRequest = new PublishSysStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishExtendedSysStateRequest$Type extends MessageType<PublishExtendedSysStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishExtendedSysStateRequest", [
            { no: 1, name: "vtol_state", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.VtolState", VtolState, "VTOL_STATE_"] },
            { no: 2, name: "landed_state", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.LandedState", LandedState, "LANDED_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<PublishExtendedSysStateRequest>): PublishExtendedSysStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vtolState = 0;
        message.landedState = 0;
        if (value !== undefined)
            reflectionMergePartial<PublishExtendedSysStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishExtendedSysStateRequest): PublishExtendedSysStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.VtolState vtol_state */ 1:
                    message.vtolState = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry_server.LandedState landed_state */ 2:
                    message.landedState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishExtendedSysStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.VtolState vtol_state = 1; */
        if (message.vtolState !== 0)
            writer.tag(1, WireType.Varint).int32(message.vtolState);
        /* mavsdk.rpc.telemetry_server.LandedState landed_state = 2; */
        if (message.landedState !== 0)
            writer.tag(2, WireType.Varint).int32(message.landedState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishExtendedSysStateRequest
 */
export const PublishExtendedSysStateRequest = new PublishExtendedSysStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishInAirRequest$Type extends MessageType<PublishInAirRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishInAirRequest", [
            { no: 1, name: "is_in_air", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PublishInAirRequest>): PublishInAirRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isInAir = false;
        if (value !== undefined)
            reflectionMergePartial<PublishInAirRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishInAirRequest): PublishInAirRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_in_air */ 1:
                    message.isInAir = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishInAirRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_in_air = 1; */
        if (message.isInAir !== false)
            writer.tag(1, WireType.Varint).bool(message.isInAir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishInAirRequest
 */
export const PublishInAirRequest = new PublishInAirRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishLandedStateRequest$Type extends MessageType<PublishLandedStateRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishLandedStateRequest", [
            { no: 1, name: "landed_state", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.LandedState", LandedState, "LANDED_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<PublishLandedStateRequest>): PublishLandedStateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.landedState = 0;
        if (value !== undefined)
            reflectionMergePartial<PublishLandedStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishLandedStateRequest): PublishLandedStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.LandedState landed_state */ 1:
                    message.landedState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishLandedStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.LandedState landed_state = 1; */
        if (message.landedState !== 0)
            writer.tag(1, WireType.Varint).int32(message.landedState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishLandedStateRequest
 */
export const PublishLandedStateRequest = new PublishLandedStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRawGpsRequest$Type extends MessageType<PublishRawGpsRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishRawGpsRequest", [
            { no: 1, name: "raw_gps", kind: "message", T: () => RawGps },
            { no: 2, name: "gps_info", kind: "message", T: () => GpsInfo }
        ]);
    }
    create(value?: PartialMessage<PublishRawGpsRequest>): PublishRawGpsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishRawGpsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRawGpsRequest): PublishRawGpsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.RawGps raw_gps */ 1:
                    message.rawGps = RawGps.internalBinaryRead(reader, reader.uint32(), options, message.rawGps);
                    break;
                case /* mavsdk.rpc.telemetry_server.GpsInfo gps_info */ 2:
                    message.gpsInfo = GpsInfo.internalBinaryRead(reader, reader.uint32(), options, message.gpsInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRawGpsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.RawGps raw_gps = 1; */
        if (message.rawGps)
            RawGps.internalBinaryWrite(message.rawGps, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.GpsInfo gps_info = 2; */
        if (message.gpsInfo)
            GpsInfo.internalBinaryWrite(message.gpsInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishRawGpsRequest
 */
export const PublishRawGpsRequest = new PublishRawGpsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishBatteryRequest$Type extends MessageType<PublishBatteryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishBatteryRequest", [
            { no: 1, name: "battery", kind: "message", T: () => Battery }
        ]);
    }
    create(value?: PartialMessage<PublishBatteryRequest>): PublishBatteryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishBatteryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishBatteryRequest): PublishBatteryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Battery battery */ 1:
                    message.battery = Battery.internalBinaryRead(reader, reader.uint32(), options, message.battery);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishBatteryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Battery battery = 1; */
        if (message.battery)
            Battery.internalBinaryWrite(message.battery, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishBatteryRequest
 */
export const PublishBatteryRequest = new PublishBatteryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRcStatusRequest$Type extends MessageType<PublishRcStatusRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishRcStatusRequest", [
            { no: 1, name: "rc_status", kind: "message", T: () => RcStatus }
        ]);
    }
    create(value?: PartialMessage<PublishRcStatusRequest>): PublishRcStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishRcStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRcStatusRequest): PublishRcStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.RcStatus rc_status */ 1:
                    message.rcStatus = RcStatus.internalBinaryRead(reader, reader.uint32(), options, message.rcStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRcStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.RcStatus rc_status = 1; */
        if (message.rcStatus)
            RcStatus.internalBinaryWrite(message.rcStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishRcStatusRequest
 */
export const PublishRcStatusRequest = new PublishRcStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishStatusTextRequest$Type extends MessageType<PublishStatusTextRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishStatusTextRequest", [
            { no: 1, name: "status_text", kind: "message", T: () => StatusText }
        ]);
    }
    create(value?: PartialMessage<PublishStatusTextRequest>): PublishStatusTextRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishStatusTextRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishStatusTextRequest): PublishStatusTextRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.StatusText status_text */ 1:
                    message.statusText = StatusText.internalBinaryRead(reader, reader.uint32(), options, message.statusText);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishStatusTextRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.StatusText status_text = 1; */
        if (message.statusText)
            StatusText.internalBinaryWrite(message.statusText, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishStatusTextRequest
 */
export const PublishStatusTextRequest = new PublishStatusTextRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishOdometryRequest$Type extends MessageType<PublishOdometryRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishOdometryRequest", [
            { no: 1, name: "odometry", kind: "message", T: () => Odometry }
        ]);
    }
    create(value?: PartialMessage<PublishOdometryRequest>): PublishOdometryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishOdometryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishOdometryRequest): PublishOdometryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Odometry odometry */ 1:
                    message.odometry = Odometry.internalBinaryRead(reader, reader.uint32(), options, message.odometry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishOdometryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Odometry odometry = 1; */
        if (message.odometry)
            Odometry.internalBinaryWrite(message.odometry, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishOdometryRequest
 */
export const PublishOdometryRequest = new PublishOdometryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishPositionVelocityNedRequest$Type extends MessageType<PublishPositionVelocityNedRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishPositionVelocityNedRequest", [
            { no: 1, name: "position_velocity_ned", kind: "message", T: () => PositionVelocityNed }
        ]);
    }
    create(value?: PartialMessage<PublishPositionVelocityNedRequest>): PublishPositionVelocityNedRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishPositionVelocityNedRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishPositionVelocityNedRequest): PublishPositionVelocityNedRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.PositionVelocityNed position_velocity_ned */ 1:
                    message.positionVelocityNed = PositionVelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.positionVelocityNed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishPositionVelocityNedRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.PositionVelocityNed position_velocity_ned = 1; */
        if (message.positionVelocityNed)
            PositionVelocityNed.internalBinaryWrite(message.positionVelocityNed, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishPositionVelocityNedRequest
 */
export const PublishPositionVelocityNedRequest = new PublishPositionVelocityNedRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishGroundTruthRequest$Type extends MessageType<PublishGroundTruthRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishGroundTruthRequest", [
            { no: 1, name: "ground_truth", kind: "message", T: () => GroundTruth }
        ]);
    }
    create(value?: PartialMessage<PublishGroundTruthRequest>): PublishGroundTruthRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishGroundTruthRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishGroundTruthRequest): PublishGroundTruthRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.GroundTruth ground_truth */ 1:
                    message.groundTruth = GroundTruth.internalBinaryRead(reader, reader.uint32(), options, message.groundTruth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishGroundTruthRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.GroundTruth ground_truth = 1; */
        if (message.groundTruth)
            GroundTruth.internalBinaryWrite(message.groundTruth, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishGroundTruthRequest
 */
export const PublishGroundTruthRequest = new PublishGroundTruthRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishImuRequest$Type extends MessageType<PublishImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishImuRequest", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<PublishImuRequest>): PublishImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishImuRequest): PublishImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishImuRequest
 */
export const PublishImuRequest = new PublishImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishScaledImuRequest$Type extends MessageType<PublishScaledImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishScaledImuRequest", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<PublishScaledImuRequest>): PublishScaledImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishScaledImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishScaledImuRequest): PublishScaledImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishScaledImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishScaledImuRequest
 */
export const PublishScaledImuRequest = new PublishScaledImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRawImuRequest$Type extends MessageType<PublishRawImuRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishRawImuRequest", [
            { no: 1, name: "imu", kind: "message", T: () => Imu }
        ]);
    }
    create(value?: PartialMessage<PublishRawImuRequest>): PublishRawImuRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishRawImuRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRawImuRequest): PublishRawImuRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.Imu imu */ 1:
                    message.imu = Imu.internalBinaryRead(reader, reader.uint32(), options, message.imu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRawImuRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.Imu imu = 1; */
        if (message.imu)
            Imu.internalBinaryWrite(message.imu, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishRawImuRequest
 */
export const PublishRawImuRequest = new PublishRawImuRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishUnixEpochTimeRequest$Type extends MessageType<PublishUnixEpochTimeRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishUnixEpochTimeRequest", [
            { no: 1, name: "time_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PublishUnixEpochTimeRequest>): PublishUnixEpochTimeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<PublishUnixEpochTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishUnixEpochTimeRequest): PublishUnixEpochTimeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_us */ 1:
                    message.timeUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishUnixEpochTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_us = 1; */
        if (message.timeUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishUnixEpochTimeRequest
 */
export const PublishUnixEpochTimeRequest = new PublishUnixEpochTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishDistanceSensorRequest$Type extends MessageType<PublishDistanceSensorRequest> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishDistanceSensorRequest", [
            { no: 1, name: "distance_sensor", kind: "message", T: () => DistanceSensor }
        ]);
    }
    create(value?: PartialMessage<PublishDistanceSensorRequest>): PublishDistanceSensorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishDistanceSensorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishDistanceSensorRequest): PublishDistanceSensorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.DistanceSensor distance_sensor */ 1:
                    message.distanceSensor = DistanceSensor.internalBinaryRead(reader, reader.uint32(), options, message.distanceSensor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishDistanceSensorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.DistanceSensor distance_sensor = 1; */
        if (message.distanceSensor)
            DistanceSensor.internalBinaryWrite(message.distanceSensor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishDistanceSensorRequest
 */
export const PublishDistanceSensorRequest = new PublishDistanceSensorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishPositionResponse$Type extends MessageType<PublishPositionResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishPositionResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishPositionResponse>): PublishPositionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishPositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishPositionResponse): PublishPositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishPositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishPositionResponse
 */
export const PublishPositionResponse = new PublishPositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishHomeResponse$Type extends MessageType<PublishHomeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishHomeResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishHomeResponse>): PublishHomeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishHomeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishHomeResponse): PublishHomeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishHomeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishHomeResponse
 */
export const PublishHomeResponse = new PublishHomeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishSysStatusResponse$Type extends MessageType<PublishSysStatusResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishSysStatusResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishSysStatusResponse>): PublishSysStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishSysStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishSysStatusResponse): PublishSysStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishSysStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishSysStatusResponse
 */
export const PublishSysStatusResponse = new PublishSysStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishExtendedSysStateResponse$Type extends MessageType<PublishExtendedSysStateResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishExtendedSysStateResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishExtendedSysStateResponse>): PublishExtendedSysStateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishExtendedSysStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishExtendedSysStateResponse): PublishExtendedSysStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishExtendedSysStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishExtendedSysStateResponse
 */
export const PublishExtendedSysStateResponse = new PublishExtendedSysStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRawGpsResponse$Type extends MessageType<PublishRawGpsResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishRawGpsResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishRawGpsResponse>): PublishRawGpsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishRawGpsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRawGpsResponse): PublishRawGpsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRawGpsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishRawGpsResponse
 */
export const PublishRawGpsResponse = new PublishRawGpsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishBatteryResponse$Type extends MessageType<PublishBatteryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishBatteryResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishBatteryResponse>): PublishBatteryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishBatteryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishBatteryResponse): PublishBatteryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishBatteryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishBatteryResponse
 */
export const PublishBatteryResponse = new PublishBatteryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishStatusTextResponse$Type extends MessageType<PublishStatusTextResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishStatusTextResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishStatusTextResponse>): PublishStatusTextResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishStatusTextResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishStatusTextResponse): PublishStatusTextResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishStatusTextResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishStatusTextResponse
 */
export const PublishStatusTextResponse = new PublishStatusTextResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishOdometryResponse$Type extends MessageType<PublishOdometryResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishOdometryResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishOdometryResponse>): PublishOdometryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishOdometryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishOdometryResponse): PublishOdometryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishOdometryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishOdometryResponse
 */
export const PublishOdometryResponse = new PublishOdometryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishPositionVelocityNedResponse$Type extends MessageType<PublishPositionVelocityNedResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishPositionVelocityNedResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishPositionVelocityNedResponse>): PublishPositionVelocityNedResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishPositionVelocityNedResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishPositionVelocityNedResponse): PublishPositionVelocityNedResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishPositionVelocityNedResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishPositionVelocityNedResponse
 */
export const PublishPositionVelocityNedResponse = new PublishPositionVelocityNedResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishGroundTruthResponse$Type extends MessageType<PublishGroundTruthResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishGroundTruthResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishGroundTruthResponse>): PublishGroundTruthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishGroundTruthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishGroundTruthResponse): PublishGroundTruthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishGroundTruthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishGroundTruthResponse
 */
export const PublishGroundTruthResponse = new PublishGroundTruthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishImuResponse$Type extends MessageType<PublishImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishImuResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishImuResponse>): PublishImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishImuResponse): PublishImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishImuResponse
 */
export const PublishImuResponse = new PublishImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishScaledImuResponse$Type extends MessageType<PublishScaledImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishScaledImuResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishScaledImuResponse>): PublishScaledImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishScaledImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishScaledImuResponse): PublishScaledImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishScaledImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishScaledImuResponse
 */
export const PublishScaledImuResponse = new PublishScaledImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRawImuResponse$Type extends MessageType<PublishRawImuResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishRawImuResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishRawImuResponse>): PublishRawImuResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishRawImuResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRawImuResponse): PublishRawImuResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRawImuResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishRawImuResponse
 */
export const PublishRawImuResponse = new PublishRawImuResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishUnixEpochTimeResponse$Type extends MessageType<PublishUnixEpochTimeResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishUnixEpochTimeResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishUnixEpochTimeResponse>): PublishUnixEpochTimeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishUnixEpochTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishUnixEpochTimeResponse): PublishUnixEpochTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishUnixEpochTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishUnixEpochTimeResponse
 */
export const PublishUnixEpochTimeResponse = new PublishUnixEpochTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishDistanceSensorResponse$Type extends MessageType<PublishDistanceSensorResponse> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PublishDistanceSensorResponse", [
            { no: 1, name: "telemetry_server_result", kind: "message", T: () => TelemetryServerResult }
        ]);
    }
    create(value?: PartialMessage<PublishDistanceSensorResponse>): PublishDistanceSensorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PublishDistanceSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishDistanceSensorResponse): PublishDistanceSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result */ 1:
                    message.telemetryServerResult = TelemetryServerResult.internalBinaryRead(reader, reader.uint32(), options, message.telemetryServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishDistanceSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult telemetry_server_result = 1; */
        if (message.telemetryServerResult)
            TelemetryServerResult.internalBinaryWrite(message.telemetryServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PublishDistanceSensorResponse
 */
export const PublishDistanceSensorResponse = new PublishDistanceSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Position", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "relative_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.relativeAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float relative_altitude_m */ 4:
                    message.relativeAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float relative_altitude_m = 4; */
        if (message.relativeAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.relativeAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Heading$Type extends MessageType<Heading> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Heading", [
            { no: 1, name: "heading_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Heading>): Heading {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headingDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<Heading>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heading): Heading {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double heading_deg */ 1:
                    message.headingDeg = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heading, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double heading_deg = 1; */
        if (message.headingDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.headingDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Heading
 */
export const Heading = new Heading$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                case /* uint64 timestamp_us */ 5:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        /* uint64 timestamp_us = 5; */
        if (message.timestampUs !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EulerAngle$Type extends MessageType<EulerAngle> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.EulerAngle", [
            { no: 1, name: "roll_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EulerAngle>): EulerAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollDeg = 0;
        message.pitchDeg = 0;
        message.yawDeg = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<EulerAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EulerAngle): EulerAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_deg */ 1:
                    message.rollDeg = reader.float();
                    break;
                case /* float pitch_deg */ 2:
                    message.pitchDeg = reader.float();
                    break;
                case /* float yaw_deg */ 3:
                    message.yawDeg = reader.float();
                    break;
                case /* uint64 timestamp_us */ 4:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EulerAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_deg = 1; */
        if (message.rollDeg !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollDeg);
        /* float pitch_deg = 2; */
        if (message.pitchDeg !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchDeg);
        /* float yaw_deg = 3; */
        if (message.yawDeg !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawDeg);
        /* uint64 timestamp_us = 4; */
        if (message.timestampUs !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.EulerAngle
 */
export const EulerAngle = new EulerAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityBody$Type extends MessageType<AngularVelocityBody> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.AngularVelocityBody", [
            { no: 1, name: "roll_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityBody>): AngularVelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollRadS = 0;
        message.pitchRadS = 0;
        message.yawRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityBody): AngularVelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_rad_s */ 1:
                    message.rollRadS = reader.float();
                    break;
                case /* float pitch_rad_s */ 2:
                    message.pitchRadS = reader.float();
                    break;
                case /* float yaw_rad_s */ 3:
                    message.yawRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_rad_s = 1; */
        if (message.rollRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollRadS);
        /* float pitch_rad_s = 2; */
        if (message.pitchRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchRadS);
        /* float yaw_rad_s = 3; */
        if (message.yawRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.AngularVelocityBody
 */
export const AngularVelocityBody = new AngularVelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GpsInfo$Type extends MessageType<GpsInfo> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.GpsInfo", [
            { no: 1, name: "num_satellites", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "fix_type", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.FixType", FixType, "FIX_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<GpsInfo>): GpsInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numSatellites = 0;
        message.fixType = 0;
        if (value !== undefined)
            reflectionMergePartial<GpsInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GpsInfo): GpsInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 num_satellites */ 1:
                    message.numSatellites = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry_server.FixType fix_type */ 2:
                    message.fixType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GpsInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 num_satellites = 1; */
        if (message.numSatellites !== 0)
            writer.tag(1, WireType.Varint).int32(message.numSatellites);
        /* mavsdk.rpc.telemetry_server.FixType fix_type = 2; */
        if (message.fixType !== 0)
            writer.tag(2, WireType.Varint).int32(message.fixType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.GpsInfo
 */
export const GpsInfo = new GpsInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RawGps$Type extends MessageType<RawGps> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.RawGps", [
            { no: 1, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "hdop", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "vdop", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "velocity_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "cog_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "altitude_ellipsoid_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "horizontal_uncertainty_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "vertical_uncertainty_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "velocity_uncertainty_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "heading_uncertainty_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<RawGps>): RawGps {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestampUs = 0n;
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.hdop = 0;
        message.vdop = 0;
        message.velocityMS = 0;
        message.cogDeg = 0;
        message.altitudeEllipsoidM = 0;
        message.horizontalUncertaintyM = 0;
        message.verticalUncertaintyM = 0;
        message.velocityUncertaintyMS = 0;
        message.headingUncertaintyDeg = 0;
        message.yawDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<RawGps>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RawGps): RawGps {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp_us */ 1:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                case /* double latitude_deg */ 2:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 3:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 4:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float hdop */ 5:
                    message.hdop = reader.float();
                    break;
                case /* float vdop */ 6:
                    message.vdop = reader.float();
                    break;
                case /* float velocity_m_s */ 7:
                    message.velocityMS = reader.float();
                    break;
                case /* float cog_deg */ 8:
                    message.cogDeg = reader.float();
                    break;
                case /* float altitude_ellipsoid_m */ 9:
                    message.altitudeEllipsoidM = reader.float();
                    break;
                case /* float horizontal_uncertainty_m */ 10:
                    message.horizontalUncertaintyM = reader.float();
                    break;
                case /* float vertical_uncertainty_m */ 11:
                    message.verticalUncertaintyM = reader.float();
                    break;
                case /* float velocity_uncertainty_m_s */ 12:
                    message.velocityUncertaintyMS = reader.float();
                    break;
                case /* float heading_uncertainty_deg */ 13:
                    message.headingUncertaintyDeg = reader.float();
                    break;
                case /* float yaw_deg */ 14:
                    message.yawDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RawGps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp_us = 1; */
        if (message.timestampUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestampUs);
        /* double latitude_deg = 2; */
        if (message.latitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 3; */
        if (message.longitudeDeg !== 0)
            writer.tag(3, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 4; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float hdop = 5; */
        if (message.hdop !== 0)
            writer.tag(5, WireType.Bit32).float(message.hdop);
        /* float vdop = 6; */
        if (message.vdop !== 0)
            writer.tag(6, WireType.Bit32).float(message.vdop);
        /* float velocity_m_s = 7; */
        if (message.velocityMS !== 0)
            writer.tag(7, WireType.Bit32).float(message.velocityMS);
        /* float cog_deg = 8; */
        if (message.cogDeg !== 0)
            writer.tag(8, WireType.Bit32).float(message.cogDeg);
        /* float altitude_ellipsoid_m = 9; */
        if (message.altitudeEllipsoidM !== 0)
            writer.tag(9, WireType.Bit32).float(message.altitudeEllipsoidM);
        /* float horizontal_uncertainty_m = 10; */
        if (message.horizontalUncertaintyM !== 0)
            writer.tag(10, WireType.Bit32).float(message.horizontalUncertaintyM);
        /* float vertical_uncertainty_m = 11; */
        if (message.verticalUncertaintyM !== 0)
            writer.tag(11, WireType.Bit32).float(message.verticalUncertaintyM);
        /* float velocity_uncertainty_m_s = 12; */
        if (message.velocityUncertaintyMS !== 0)
            writer.tag(12, WireType.Bit32).float(message.velocityUncertaintyMS);
        /* float heading_uncertainty_deg = 13; */
        if (message.headingUncertaintyDeg !== 0)
            writer.tag(13, WireType.Bit32).float(message.headingUncertaintyDeg);
        /* float yaw_deg = 14; */
        if (message.yawDeg !== 0)
            writer.tag(14, WireType.Bit32).float(message.yawDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.RawGps
 */
export const RawGps = new RawGps$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Battery$Type extends MessageType<Battery> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Battery", [
            { no: 1, name: "voltage_v", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "remaining_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Battery>): Battery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.voltageV = 0;
        message.remainingPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<Battery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Battery): Battery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float voltage_v */ 1:
                    message.voltageV = reader.float();
                    break;
                case /* float remaining_percent */ 2:
                    message.remainingPercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Battery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float voltage_v = 1; */
        if (message.voltageV !== 0)
            writer.tag(1, WireType.Bit32).float(message.voltageV);
        /* float remaining_percent = 2; */
        if (message.remainingPercent !== 0)
            writer.tag(2, WireType.Bit32).float(message.remainingPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Battery
 */
export const Battery = new Battery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcStatus$Type extends MessageType<RcStatus> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.RcStatus", [
            { no: 1, name: "was_available_once", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 2, name: "is_available", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "mavsdk.options.default_value": "false" } },
            { no: 3, name: "signal_strength_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<RcStatus>): RcStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.wasAvailableOnce = false;
        message.isAvailable = false;
        message.signalStrengthPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<RcStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcStatus): RcStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool was_available_once */ 1:
                    message.wasAvailableOnce = reader.bool();
                    break;
                case /* bool is_available */ 2:
                    message.isAvailable = reader.bool();
                    break;
                case /* float signal_strength_percent */ 3:
                    message.signalStrengthPercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RcStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool was_available_once = 1; */
        if (message.wasAvailableOnce !== false)
            writer.tag(1, WireType.Varint).bool(message.wasAvailableOnce);
        /* bool is_available = 2; */
        if (message.isAvailable !== false)
            writer.tag(2, WireType.Varint).bool(message.isAvailable);
        /* float signal_strength_percent = 3; */
        if (message.signalStrengthPercent !== 0)
            writer.tag(3, WireType.Bit32).float(message.signalStrengthPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.RcStatus
 */
export const RcStatus = new RcStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusText$Type extends MessageType<StatusText> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.StatusText", [
            { no: 1, name: "type", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.StatusTextType", StatusTextType, "STATUS_TEXT_TYPE_"] },
            { no: 2, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusText>): StatusText {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<StatusText>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusText): StatusText {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.StatusTextType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string text */ 2:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusText, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.StatusTextType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string text = 2; */
        if (message.text !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.StatusText
 */
export const StatusText = new StatusText$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorControlTarget$Type extends MessageType<ActuatorControlTarget> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.ActuatorControlTarget", [
            { no: 1, name: "group", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "controls", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ActuatorControlTarget>): ActuatorControlTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.group = 0;
        message.controls = [];
        if (value !== undefined)
            reflectionMergePartial<ActuatorControlTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorControlTarget): ActuatorControlTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 group */ 1:
                    message.group = reader.int32();
                    break;
                case /* repeated float controls */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.controls.push(reader.float());
                    else
                        message.controls.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorControlTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 group = 1; */
        if (message.group !== 0)
            writer.tag(1, WireType.Varint).int32(message.group);
        /* repeated float controls = 2; */
        if (message.controls.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.controls.length; i++)
                writer.float(message.controls[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.ActuatorControlTarget
 */
export const ActuatorControlTarget = new ActuatorControlTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActuatorOutputStatus$Type extends MessageType<ActuatorOutputStatus> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.ActuatorOutputStatus", [
            { no: 1, name: "active", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "mavsdk.options.default_value": "0" } },
            { no: 2, name: "actuator", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ActuatorOutputStatus>): ActuatorOutputStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.active = 0;
        message.actuator = [];
        if (value !== undefined)
            reflectionMergePartial<ActuatorOutputStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActuatorOutputStatus): ActuatorOutputStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 active */ 1:
                    message.active = reader.uint32();
                    break;
                case /* repeated float actuator */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.actuator.push(reader.float());
                    else
                        message.actuator.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActuatorOutputStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 active = 1; */
        if (message.active !== 0)
            writer.tag(1, WireType.Varint).uint32(message.active);
        /* repeated float actuator = 2; */
        if (message.actuator.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.actuator.length; i++)
                writer.float(message.actuator[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.ActuatorOutputStatus
 */
export const ActuatorOutputStatus = new ActuatorOutputStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Covariance$Type extends MessageType<Covariance> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Covariance", [
            { no: 1, name: "covariance_matrix", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Covariance>): Covariance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.covarianceMatrix = [];
        if (value !== undefined)
            reflectionMergePartial<Covariance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Covariance): Covariance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated float covariance_matrix */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.covarianceMatrix.push(reader.float());
                    else
                        message.covarianceMatrix.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Covariance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated float covariance_matrix = 1; */
        if (message.covarianceMatrix.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.covarianceMatrix.length; i++)
                writer.float(message.covarianceMatrix[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Covariance
 */
export const Covariance = new Covariance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VelocityBody$Type extends MessageType<VelocityBody> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.VelocityBody", [
            { no: 1, name: "x_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VelocityBody>): VelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xMS = 0;
        message.yMS = 0;
        message.zMS = 0;
        if (value !== undefined)
            reflectionMergePartial<VelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VelocityBody): VelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m_s */ 1:
                    message.xMS = reader.float();
                    break;
                case /* float y_m_s */ 2:
                    message.yMS = reader.float();
                    break;
                case /* float z_m_s */ 3:
                    message.zMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m_s = 1; */
        if (message.xMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.xMS);
        /* float y_m_s = 2; */
        if (message.yMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.yMS);
        /* float z_m_s = 3; */
        if (message.zMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.zMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.VelocityBody
 */
export const VelocityBody = new VelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionBody$Type extends MessageType<PositionBody> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PositionBody", [
            { no: 1, name: "x_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "z_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionBody>): PositionBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xM = 0;
        message.yM = 0;
        message.zM = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionBody): PositionBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x_m */ 1:
                    message.xM = reader.float();
                    break;
                case /* float y_m */ 2:
                    message.yM = reader.float();
                    break;
                case /* float z_m */ 3:
                    message.zM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float x_m = 1; */
        if (message.xM !== 0)
            writer.tag(1, WireType.Bit32).float(message.xM);
        /* float y_m = 2; */
        if (message.yM !== 0)
            writer.tag(2, WireType.Bit32).float(message.yM);
        /* float z_m = 3; */
        if (message.zM !== 0)
            writer.tag(3, WireType.Bit32).float(message.zM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PositionBody
 */
export const PositionBody = new PositionBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Odometry$Type extends MessageType<Odometry> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Odometry", [
            { no: 1, name: "time_usec", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "frame_id", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.Odometry.MavFrame", Odometry_MavFrame, "MAV_FRAME_"] },
            { no: 3, name: "child_frame_id", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.Odometry.MavFrame", Odometry_MavFrame, "MAV_FRAME_"] },
            { no: 4, name: "position_body", kind: "message", T: () => PositionBody },
            { no: 5, name: "q", kind: "message", T: () => Quaternion },
            { no: 6, name: "velocity_body", kind: "message", T: () => VelocityBody },
            { no: 7, name: "angular_velocity_body", kind: "message", T: () => AngularVelocityBody },
            { no: 8, name: "pose_covariance", kind: "message", T: () => Covariance },
            { no: 9, name: "velocity_covariance", kind: "message", T: () => Covariance }
        ]);
    }
    create(value?: PartialMessage<Odometry>): Odometry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUsec = 0n;
        message.frameId = 0;
        message.childFrameId = 0;
        if (value !== undefined)
            reflectionMergePartial<Odometry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Odometry): Odometry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 time_usec */ 1:
                    message.timeUsec = reader.uint64().toBigInt();
                    break;
                case /* mavsdk.rpc.telemetry_server.Odometry.MavFrame frame_id */ 2:
                    message.frameId = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry_server.Odometry.MavFrame child_frame_id */ 3:
                    message.childFrameId = reader.int32();
                    break;
                case /* mavsdk.rpc.telemetry_server.PositionBody position_body */ 4:
                    message.positionBody = PositionBody.internalBinaryRead(reader, reader.uint32(), options, message.positionBody);
                    break;
                case /* mavsdk.rpc.telemetry_server.Quaternion q */ 5:
                    message.q = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.q);
                    break;
                case /* mavsdk.rpc.telemetry_server.VelocityBody velocity_body */ 6:
                    message.velocityBody = VelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.velocityBody);
                    break;
                case /* mavsdk.rpc.telemetry_server.AngularVelocityBody angular_velocity_body */ 7:
                    message.angularVelocityBody = AngularVelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocityBody);
                    break;
                case /* mavsdk.rpc.telemetry_server.Covariance pose_covariance */ 8:
                    message.poseCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.poseCovariance);
                    break;
                case /* mavsdk.rpc.telemetry_server.Covariance velocity_covariance */ 9:
                    message.velocityCovariance = Covariance.internalBinaryRead(reader, reader.uint32(), options, message.velocityCovariance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Odometry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 time_usec = 1; */
        if (message.timeUsec !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timeUsec);
        /* mavsdk.rpc.telemetry_server.Odometry.MavFrame frame_id = 2; */
        if (message.frameId !== 0)
            writer.tag(2, WireType.Varint).int32(message.frameId);
        /* mavsdk.rpc.telemetry_server.Odometry.MavFrame child_frame_id = 3; */
        if (message.childFrameId !== 0)
            writer.tag(3, WireType.Varint).int32(message.childFrameId);
        /* mavsdk.rpc.telemetry_server.PositionBody position_body = 4; */
        if (message.positionBody)
            PositionBody.internalBinaryWrite(message.positionBody, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.Quaternion q = 5; */
        if (message.q)
            Quaternion.internalBinaryWrite(message.q, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.VelocityBody velocity_body = 6; */
        if (message.velocityBody)
            VelocityBody.internalBinaryWrite(message.velocityBody, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.AngularVelocityBody angular_velocity_body = 7; */
        if (message.angularVelocityBody)
            AngularVelocityBody.internalBinaryWrite(message.angularVelocityBody, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.Covariance pose_covariance = 8; */
        if (message.poseCovariance)
            Covariance.internalBinaryWrite(message.poseCovariance, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.Covariance velocity_covariance = 9; */
        if (message.velocityCovariance)
            Covariance.internalBinaryWrite(message.velocityCovariance, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Odometry
 */
export const Odometry = new Odometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DistanceSensor$Type extends MessageType<DistanceSensor> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.DistanceSensor", [
            { no: 1, name: "minimum_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "maximum_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "current_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<DistanceSensor>): DistanceSensor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.minimumDistanceM = 0;
        message.maximumDistanceM = 0;
        message.currentDistanceM = 0;
        if (value !== undefined)
            reflectionMergePartial<DistanceSensor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DistanceSensor): DistanceSensor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float minimum_distance_m */ 1:
                    message.minimumDistanceM = reader.float();
                    break;
                case /* float maximum_distance_m */ 2:
                    message.maximumDistanceM = reader.float();
                    break;
                case /* float current_distance_m */ 3:
                    message.currentDistanceM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DistanceSensor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float minimum_distance_m = 1; */
        if (message.minimumDistanceM !== 0)
            writer.tag(1, WireType.Bit32).float(message.minimumDistanceM);
        /* float maximum_distance_m = 2; */
        if (message.maximumDistanceM !== 0)
            writer.tag(2, WireType.Bit32).float(message.maximumDistanceM);
        /* float current_distance_m = 3; */
        if (message.currentDistanceM !== 0)
            writer.tag(3, WireType.Bit32).float(message.currentDistanceM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.DistanceSensor
 */
export const DistanceSensor = new DistanceSensor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScaledPressure$Type extends MessageType<ScaledPressure> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.ScaledPressure", [
            { no: 1, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "absolute_pressure_hpa", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "differential_pressure_hpa", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "temperature_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "differential_pressure_temperature_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ScaledPressure>): ScaledPressure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timestampUs = 0n;
        message.absolutePressureHpa = 0;
        message.differentialPressureHpa = 0;
        message.temperatureDeg = 0;
        message.differentialPressureTemperatureDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<ScaledPressure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScaledPressure): ScaledPressure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp_us */ 1:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                case /* float absolute_pressure_hpa */ 2:
                    message.absolutePressureHpa = reader.float();
                    break;
                case /* float differential_pressure_hpa */ 3:
                    message.differentialPressureHpa = reader.float();
                    break;
                case /* float temperature_deg */ 4:
                    message.temperatureDeg = reader.float();
                    break;
                case /* float differential_pressure_temperature_deg */ 5:
                    message.differentialPressureTemperatureDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScaledPressure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp_us = 1; */
        if (message.timestampUs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestampUs);
        /* float absolute_pressure_hpa = 2; */
        if (message.absolutePressureHpa !== 0)
            writer.tag(2, WireType.Bit32).float(message.absolutePressureHpa);
        /* float differential_pressure_hpa = 3; */
        if (message.differentialPressureHpa !== 0)
            writer.tag(3, WireType.Bit32).float(message.differentialPressureHpa);
        /* float temperature_deg = 4; */
        if (message.temperatureDeg !== 0)
            writer.tag(4, WireType.Bit32).float(message.temperatureDeg);
        /* float differential_pressure_temperature_deg = 5; */
        if (message.differentialPressureTemperatureDeg !== 0)
            writer.tag(5, WireType.Bit32).float(message.differentialPressureTemperatureDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.ScaledPressure
 */
export const ScaledPressure = new ScaledPressure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionNed$Type extends MessageType<PositionNed> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PositionNed", [
            { no: 1, name: "north_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "east_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<PositionNed>): PositionNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.northM = 0;
        message.eastM = 0;
        message.downM = 0;
        if (value !== undefined)
            reflectionMergePartial<PositionNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionNed): PositionNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float north_m */ 1:
                    message.northM = reader.float();
                    break;
                case /* float east_m */ 2:
                    message.eastM = reader.float();
                    break;
                case /* float down_m */ 3:
                    message.downM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float north_m = 1; */
        if (message.northM !== 0)
            writer.tag(1, WireType.Bit32).float(message.northM);
        /* float east_m = 2; */
        if (message.eastM !== 0)
            writer.tag(2, WireType.Bit32).float(message.eastM);
        /* float down_m = 3; */
        if (message.downM !== 0)
            writer.tag(3, WireType.Bit32).float(message.downM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PositionNed
 */
export const PositionNed = new PositionNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VelocityNed$Type extends MessageType<VelocityNed> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.VelocityNed", [
            { no: 1, name: "north_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "east_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "down_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VelocityNed>): VelocityNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.northMS = 0;
        message.eastMS = 0;
        message.downMS = 0;
        if (value !== undefined)
            reflectionMergePartial<VelocityNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VelocityNed): VelocityNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float north_m_s */ 1:
                    message.northMS = reader.float();
                    break;
                case /* float east_m_s */ 2:
                    message.eastMS = reader.float();
                    break;
                case /* float down_m_s */ 3:
                    message.downMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VelocityNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float north_m_s = 1; */
        if (message.northMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.northMS);
        /* float east_m_s = 2; */
        if (message.eastMS !== 0)
            writer.tag(2, WireType.Bit32).float(message.eastMS);
        /* float down_m_s = 3; */
        if (message.downMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.downMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.VelocityNed
 */
export const VelocityNed = new VelocityNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionVelocityNed$Type extends MessageType<PositionVelocityNed> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.PositionVelocityNed", [
            { no: 1, name: "position", kind: "message", T: () => PositionNed },
            { no: 2, name: "velocity", kind: "message", T: () => VelocityNed }
        ]);
    }
    create(value?: PartialMessage<PositionVelocityNed>): PositionVelocityNed {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PositionVelocityNed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionVelocityNed): PositionVelocityNed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.PositionNed position */ 1:
                    message.position = PositionNed.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* mavsdk.rpc.telemetry_server.VelocityNed velocity */ 2:
                    message.velocity = VelocityNed.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionVelocityNed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.PositionNed position = 1; */
        if (message.position)
            PositionNed.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.VelocityNed velocity = 2; */
        if (message.velocity)
            VelocityNed.internalBinaryWrite(message.velocity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.PositionVelocityNed
 */
export const PositionVelocityNed = new PositionVelocityNed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroundTruth$Type extends MessageType<GroundTruth> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.GroundTruth", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<GroundTruth>): GroundTruth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<GroundTruth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroundTruth): GroundTruth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroundTruth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.GroundTruth
 */
export const GroundTruth = new GroundTruth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FixedwingMetrics$Type extends MessageType<FixedwingMetrics> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.FixedwingMetrics", [
            { no: 1, name: "airspeed_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "throttle_percentage", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "climb_rate_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<FixedwingMetrics>): FixedwingMetrics {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.airspeedMS = 0;
        message.throttlePercentage = 0;
        message.climbRateMS = 0;
        if (value !== undefined)
            reflectionMergePartial<FixedwingMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FixedwingMetrics): FixedwingMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float airspeed_m_s */ 1:
                    message.airspeedMS = reader.float();
                    break;
                case /* float throttle_percentage */ 2:
                    message.throttlePercentage = reader.float();
                    break;
                case /* float climb_rate_m_s */ 3:
                    message.climbRateMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FixedwingMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float airspeed_m_s = 1; */
        if (message.airspeedMS !== 0)
            writer.tag(1, WireType.Bit32).float(message.airspeedMS);
        /* float throttle_percentage = 2; */
        if (message.throttlePercentage !== 0)
            writer.tag(2, WireType.Bit32).float(message.throttlePercentage);
        /* float climb_rate_m_s = 3; */
        if (message.climbRateMS !== 0)
            writer.tag(3, WireType.Bit32).float(message.climbRateMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.FixedwingMetrics
 */
export const FixedwingMetrics = new FixedwingMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccelerationFrd$Type extends MessageType<AccelerationFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.AccelerationFrd", [
            { no: 1, name: "forward_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_m_s2", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AccelerationFrd>): AccelerationFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardMS2 = 0;
        message.rightMS2 = 0;
        message.downMS2 = 0;
        if (value !== undefined)
            reflectionMergePartial<AccelerationFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccelerationFrd): AccelerationFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_m_s2 */ 1:
                    message.forwardMS2 = reader.float();
                    break;
                case /* float right_m_s2 */ 2:
                    message.rightMS2 = reader.float();
                    break;
                case /* float down_m_s2 */ 3:
                    message.downMS2 = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccelerationFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_m_s2 = 1; */
        if (message.forwardMS2 !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardMS2);
        /* float right_m_s2 = 2; */
        if (message.rightMS2 !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightMS2);
        /* float down_m_s2 = 3; */
        if (message.downMS2 !== 0)
            writer.tag(3, WireType.Bit32).float(message.downMS2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.AccelerationFrd
 */
export const AccelerationFrd = new AccelerationFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityFrd$Type extends MessageType<AngularVelocityFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.AngularVelocityFrd", [
            { no: 1, name: "forward_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityFrd>): AngularVelocityFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardRadS = 0;
        message.rightRadS = 0;
        message.downRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityFrd): AngularVelocityFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_rad_s */ 1:
                    message.forwardRadS = reader.float();
                    break;
                case /* float right_rad_s */ 2:
                    message.rightRadS = reader.float();
                    break;
                case /* float down_rad_s */ 3:
                    message.downRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_rad_s = 1; */
        if (message.forwardRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardRadS);
        /* float right_rad_s = 2; */
        if (message.rightRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightRadS);
        /* float down_rad_s = 3; */
        if (message.downRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.downRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.AngularVelocityFrd
 */
export const AngularVelocityFrd = new AngularVelocityFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MagneticFieldFrd$Type extends MessageType<MagneticFieldFrd> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.MagneticFieldFrd", [
            { no: 1, name: "forward_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "right_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "down_gauss", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<MagneticFieldFrd>): MagneticFieldFrd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.forwardGauss = 0;
        message.rightGauss = 0;
        message.downGauss = 0;
        if (value !== undefined)
            reflectionMergePartial<MagneticFieldFrd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MagneticFieldFrd): MagneticFieldFrd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float forward_gauss */ 1:
                    message.forwardGauss = reader.float();
                    break;
                case /* float right_gauss */ 2:
                    message.rightGauss = reader.float();
                    break;
                case /* float down_gauss */ 3:
                    message.downGauss = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MagneticFieldFrd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float forward_gauss = 1; */
        if (message.forwardGauss !== 0)
            writer.tag(1, WireType.Bit32).float(message.forwardGauss);
        /* float right_gauss = 2; */
        if (message.rightGauss !== 0)
            writer.tag(2, WireType.Bit32).float(message.rightGauss);
        /* float down_gauss = 3; */
        if (message.downGauss !== 0)
            writer.tag(3, WireType.Bit32).float(message.downGauss);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.MagneticFieldFrd
 */
export const MagneticFieldFrd = new MagneticFieldFrd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Imu$Type extends MessageType<Imu> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.Imu", [
            { no: 1, name: "acceleration_frd", kind: "message", T: () => AccelerationFrd },
            { no: 2, name: "angular_velocity_frd", kind: "message", T: () => AngularVelocityFrd },
            { no: 3, name: "magnetic_field_frd", kind: "message", T: () => MagneticFieldFrd },
            { no: 4, name: "temperature_degc", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Imu>): Imu {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.temperatureDegc = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Imu>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Imu): Imu {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.AccelerationFrd acceleration_frd */ 1:
                    message.accelerationFrd = AccelerationFrd.internalBinaryRead(reader, reader.uint32(), options, message.accelerationFrd);
                    break;
                case /* mavsdk.rpc.telemetry_server.AngularVelocityFrd angular_velocity_frd */ 2:
                    message.angularVelocityFrd = AngularVelocityFrd.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocityFrd);
                    break;
                case /* mavsdk.rpc.telemetry_server.MagneticFieldFrd magnetic_field_frd */ 3:
                    message.magneticFieldFrd = MagneticFieldFrd.internalBinaryRead(reader, reader.uint32(), options, message.magneticFieldFrd);
                    break;
                case /* float temperature_degc */ 4:
                    message.temperatureDegc = reader.float();
                    break;
                case /* uint64 timestamp_us */ 5:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Imu, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.AccelerationFrd acceleration_frd = 1; */
        if (message.accelerationFrd)
            AccelerationFrd.internalBinaryWrite(message.accelerationFrd, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.AngularVelocityFrd angular_velocity_frd = 2; */
        if (message.angularVelocityFrd)
            AngularVelocityFrd.internalBinaryWrite(message.angularVelocityFrd, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.telemetry_server.MagneticFieldFrd magnetic_field_frd = 3; */
        if (message.magneticFieldFrd)
            MagneticFieldFrd.internalBinaryWrite(message.magneticFieldFrd, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* float temperature_degc = 4; */
        if (message.temperatureDegc !== 0)
            writer.tag(4, WireType.Bit32).float(message.temperatureDegc);
        /* uint64 timestamp_us = 5; */
        if (message.timestampUs !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.Imu
 */
export const Imu = new Imu$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelemetryServerResult$Type extends MessageType<TelemetryServerResult> {
    constructor() {
        super("mavsdk.rpc.telemetry_server.TelemetryServerResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.telemetry_server.TelemetryServerResult.Result", TelemetryServerResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TelemetryServerResult>): TelemetryServerResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<TelemetryServerResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelemetryServerResult): TelemetryServerResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.telemetry_server.TelemetryServerResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelemetryServerResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.telemetry_server.TelemetryServerResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.telemetry_server.TelemetryServerResult
 */
export const TelemetryServerResult = new TelemetryServerResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.telemetry_server.TelemetryServerService
 */
export const TelemetryServerService = new ServiceType("mavsdk.rpc.telemetry_server.TelemetryServerService", [
    { name: "PublishPosition", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishPositionRequest, O: PublishPositionResponse },
    { name: "PublishHome", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishHomeRequest, O: PublishHomeResponse },
    { name: "PublishSysStatus", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishSysStatusRequest, O: PublishSysStatusResponse },
    { name: "PublishExtendedSysState", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishExtendedSysStateRequest, O: PublishExtendedSysStateResponse },
    { name: "PublishRawGps", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishRawGpsRequest, O: PublishRawGpsResponse },
    { name: "PublishBattery", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishBatteryRequest, O: PublishBatteryResponse },
    { name: "PublishStatusText", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishStatusTextRequest, O: PublishStatusTextResponse },
    { name: "PublishOdometry", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishOdometryRequest, O: PublishOdometryResponse },
    { name: "PublishPositionVelocityNed", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishPositionVelocityNedRequest, O: PublishPositionVelocityNedResponse },
    { name: "PublishGroundTruth", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishGroundTruthRequest, O: PublishGroundTruthResponse },
    { name: "PublishImu", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishImuRequest, O: PublishImuResponse },
    { name: "PublishScaledImu", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishScaledImuRequest, O: PublishScaledImuResponse },
    { name: "PublishRawImu", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishRawImuRequest, O: PublishRawImuResponse },
    { name: "PublishUnixEpochTime", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishUnixEpochTimeRequest, O: PublishUnixEpochTimeResponse },
    { name: "PublishDistanceSensor", options: { "mavsdk.options.async_type": "SYNC" }, I: PublishDistanceSensorRequest, O: PublishDistanceSensorResponse }
]);
