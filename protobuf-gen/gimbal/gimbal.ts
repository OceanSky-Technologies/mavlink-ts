/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "gimbal/gimbal.proto" (package "mavsdk.rpc.gimbal", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetAnglesRequest
 */
export interface SetAnglesRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal id to address (0 for all gimbals)
    /**
     * @generated from protobuf field: float roll_deg = 2;
     */
    rollDeg: number; // Roll angle in degrees (negative down on the right)
    /**
     * @generated from protobuf field: float pitch_deg = 3;
     */
    pitchDeg: number; // Pitch angle in degrees (negative points down)
    /**
     * @generated from protobuf field: float yaw_deg = 4;
     */
    yawDeg: number; // Yaw angle in degrees (positive is clock-wise, range: -180 to 180 or 0 to 360)
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalMode gimbal_mode = 5;
     */
    gimbalMode: GimbalMode; // Gimbal mode to use
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.SendMode send_mode = 6;
     */
    sendMode: SendMode; // Send mode of command/setpoint
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetAnglesResponse
 */
export interface SetAnglesResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetAngularRatesRequest
 */
export interface SetAngularRatesRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal id to address (0 for all gimbals)
    /**
     * @generated from protobuf field: float roll_rate_deg_s = 2;
     */
    rollRateDegS: number; // Angular rate around roll axis in degrees/second (negative down on the right)
    /**
     * @generated from protobuf field: float pitch_rate_deg_s = 3;
     */
    pitchRateDegS: number; // Angular rate around pitch axis in degrees/second (negative downward)
    /**
     * @generated from protobuf field: float yaw_rate_deg_s = 4;
     */
    yawRateDegS: number; // Angular rate around yaw axis in degrees/second (positive is clock-wise)
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalMode gimbal_mode = 5;
     */
    gimbalMode: GimbalMode; // Gimbal mode to use
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.SendMode send_mode = 6;
     */
    sendMode: SendMode; // Send mode of command/setpoint
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetAngularRatesResponse
 */
export interface SetAngularRatesResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetRoiLocationRequest
 */
export interface SetRoiLocationRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal id to address (0 for all gimbals)
    /**
     * @generated from protobuf field: double latitude_deg = 2;
     */
    latitudeDeg: number; // Latitude in degrees
    /**
     * @generated from protobuf field: double longitude_deg = 3;
     */
    longitudeDeg: number; // Longitude in degrees
    /**
     * @generated from protobuf field: float altitude_m = 4;
     */
    altitudeM: number; // Altitude in metres (AMSL)
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SetRoiLocationResponse
 */
export interface SetRoiLocationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.TakeControlRequest
 */
export interface TakeControlRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal id to address (0 for all gimbals)
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.ControlMode control_mode = 2;
     */
    controlMode: ControlMode; // Control mode (primary or secondary)
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.TakeControlResponse
 */
export interface TakeControlResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.ReleaseControlRequest
 */
export interface ReleaseControlRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal id to address (0 for all gimbals)
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.ReleaseControlResponse
 */
export interface ReleaseControlResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SubscribeControlStatusRequest
 */
export interface SubscribeControlStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.ControlStatusResponse
 */
export interface ControlStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.ControlStatus control_status = 1;
     */
    controlStatus?: ControlStatus; // Control status
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.GetControlStatusRequest
 */
export interface GetControlStatusRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal ID
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.GetControlStatusResponse
 */
export interface GetControlStatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.ControlStatus control_status = 2;
     */
    controlStatus?: ControlStatus; // Control status
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
}
/**
 *
 * Euler angle type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Euler angles are converted using the 3-1-2 sequence instead of standard 3-2-1 in order
 * to avoid the gimbal lock at 90 degrees down.
 *
 * For more info see https://en.wikipedia.org/wiki/Euler_angles
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.EulerAngle
 */
export interface EulerAngle {
    /**
     * @generated from protobuf field: float roll_deg = 1;
     */
    rollDeg: number; // Roll angle in degrees, positive is banking to the right
    /**
     * @generated from protobuf field: float pitch_deg = 2;
     */
    pitchDeg: number; // Pitch angle in degrees, positive is pitching nose up
    /**
     * @generated from protobuf field: float yaw_deg = 3;
     */
    yawDeg: number; // Yaw angle in degrees, positive is clock-wise seen from above
}
/**
 * Gimbal angular rate type
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.AngularVelocityBody
 */
export interface AngularVelocityBody {
    /**
     * @generated from protobuf field: float roll_rad_s = 1;
     */
    rollRadS: number; // Roll angular velocity
    /**
     * @generated from protobuf field: float pitch_rad_s = 2;
     */
    pitchRadS: number; // Pitch angular velocity
    /**
     * @generated from protobuf field: float yaw_rad_s = 3;
     */
    yawRadS: number; // Yaw angular velocity
}
/**
 * Gimbal attitude type
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.Attitude
 */
export interface Attitude {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal ID
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.EulerAngle euler_angle_forward = 2;
     */
    eulerAngleForward?: EulerAngle; // Euler angle relative to forward
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.Quaternion quaternion_forward = 3;
     */
    quaternionForward?: Quaternion; // Quaternion relative to forward
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.EulerAngle euler_angle_north = 4;
     */
    eulerAngleNorth?: EulerAngle; // Euler angle relative to North
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.Quaternion quaternion_north = 5;
     */
    quaternionNorth?: Quaternion; // Quaternion relative to North
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.AngularVelocityBody angular_velocity = 6;
     */
    angularVelocity?: AngularVelocityBody; // The angular rate
    /**
     * @generated from protobuf field: uint64 timestamp_us = 7;
     */
    timestampUs: bigint; // Timestamp in microseconds
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SubscribeAttitudeRequest
 */
export interface SubscribeAttitudeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.AttitudeResponse
 */
export interface AttitudeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.Attitude attitude = 1;
     */
    attitude?: Attitude; // The attitude
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.GetAttitudeRequest
 */
export interface GetAttitudeRequest {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal ID
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.GetAttitudeResponse
 */
export interface GetAttitudeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1;
     */
    gimbalResult?: GimbalResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.Attitude attitude = 2;
     */
    attitude?: Attitude; // The attitude
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.SubscribeGimbalListRequest
 */
export interface SubscribeGimbalListRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.gimbal.GimbalListResponse
 */
export interface GimbalListResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalList gimbal_list = 1;
     */
    gimbalList?: GimbalList; // Gimbal list
}
/**
 * Gimbal list item
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.GimbalItem
 */
export interface GimbalItem {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // ID to address it, starting at 1 (0 means all gimbals)
    /**
     * @generated from protobuf field: string vendor_name = 2;
     */
    vendorName: string; // Vendor name
    /**
     * @generated from protobuf field: string model_name = 3;
     */
    modelName: string; // Model name
    /**
     * @generated from protobuf field: string custom_name = 4;
     */
    customName: string; // Custom name name
    /**
     * @generated from protobuf field: int32 gimbal_manager_component_id = 5;
     */
    gimbalManagerComponentId: number; // MAVLink component of gimbal manager, for debugging purposes
    /**
     * @generated from protobuf field: int32 gimbal_device_id = 6;
     */
    gimbalDeviceId: number; // MAVLink component of gimbal device
}
/**
 * Gimbal list
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.GimbalList
 */
export interface GimbalList {
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.gimbal.GimbalItem gimbals = 1;
     */
    gimbals: GimbalItem[]; // Gimbal item.
}
/**
 * Control status
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.ControlStatus
 */
export interface ControlStatus {
    /**
     * @generated from protobuf field: int32 gimbal_id = 1;
     */
    gimbalId: number; // Gimbal ID
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.ControlMode control_mode = 2;
     */
    controlMode: ControlMode; // Control mode (none, primary or secondary)
    /**
     * @generated from protobuf field: int32 sysid_primary_control = 3;
     */
    sysidPrimaryControl: number; // Sysid of the component that has primary control over the gimbal (0 if no one is in control)
    /**
     * @generated from protobuf field: int32 compid_primary_control = 4;
     */
    compidPrimaryControl: number; // Compid of the component that has primary control over the gimbal (0 if no one is in control)
    /**
     * @generated from protobuf field: int32 sysid_secondary_control = 5;
     */
    sysidSecondaryControl: number; // Sysid of the component that has secondary control over the gimbal (0 if no one is in control)
    /**
     * @generated from protobuf field: int32 compid_secondary_control = 6;
     */
    compidSecondaryControl: number; // Compid of the component that has secondary control over the gimbal (0 if no one is in control)
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.gimbal.GimbalResult
 */
export interface GimbalResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.gimbal.GimbalResult.Result result = 1;
     */
    result: GimbalResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for gimbal commands.
 *
 * @generated from protobuf enum mavsdk.rpc.gimbal.GimbalResult.Result
 */
export enum GimbalResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Command was accepted
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Error occurred sending the command
     *
     * @generated from protobuf enum value: RESULT_ERROR = 2;
     */
    ERROR = 2,
    /**
     * Command timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 3;
     */
    TIMEOUT = 3,
    /**
     * Functionality not supported
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 4;
     */
    UNSUPPORTED = 4,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 5;
     */
    NO_SYSTEM = 5,
    /**
     * Invalid argument
     *
     * @generated from protobuf enum value: RESULT_INVALID_ARGUMENT = 6;
     */
    INVALID_ARGUMENT = 6
}
/**
 * Gimbal mode type.
 *
 * @generated from protobuf enum mavsdk.rpc.gimbal.GimbalMode
 */
export enum GimbalMode {
    /**
     * Yaw follow will point the gimbal to the vehicle heading
     *
     * @generated from protobuf enum value: GIMBAL_MODE_YAW_FOLLOW = 0;
     */
    YAW_FOLLOW = 0,
    /**
     * Yaw lock will fix the gimbal pointing to an absolute direction
     *
     * @generated from protobuf enum value: GIMBAL_MODE_YAW_LOCK = 1;
     */
    YAW_LOCK = 1
}
/**
 * Control mode
 *
 * @generated from protobuf enum mavsdk.rpc.gimbal.ControlMode
 */
export enum ControlMode {
    /**
     * Indicates that the component does not have control over the gimbal
     *
     * @generated from protobuf enum value: CONTROL_MODE_NONE = 0;
     */
    NONE = 0,
    /**
     * To take primary control over the gimbal
     *
     * @generated from protobuf enum value: CONTROL_MODE_PRIMARY = 1;
     */
    PRIMARY = 1,
    /**
     * To take secondary control over the gimbal
     *
     * @generated from protobuf enum value: CONTROL_MODE_SECONDARY = 2;
     */
    SECONDARY = 2
}
/**
 * @generated from protobuf enum mavsdk.rpc.gimbal.SendMode
 */
export enum SendMode {
    /**
     * Send command exactly once with quality of service (use for sporadic commands slower than 1 Hz)
     *
     * @generated from protobuf enum value: SEND_MODE_ONCE = 0;
     */
    ONCE = 0,
    /**
     * Stream setpoint without quality of service (use for setpoints faster than 1 Hz).
     *
     * @generated from protobuf enum value: SEND_MODE_STREAM = 1;
     */
    STREAM = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class SetAnglesRequest$Type extends MessageType<SetAnglesRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetAnglesRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "roll_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "gimbal_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.GimbalMode", GimbalMode, "GIMBAL_MODE_"] },
            { no: 6, name: "send_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.SendMode", SendMode, "SEND_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<SetAnglesRequest>): SetAnglesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.rollDeg = 0;
        message.pitchDeg = 0;
        message.yawDeg = 0;
        message.gimbalMode = 0;
        message.sendMode = 0;
        if (value !== undefined)
            reflectionMergePartial<SetAnglesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAnglesRequest): SetAnglesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* float roll_deg */ 2:
                    message.rollDeg = reader.float();
                    break;
                case /* float pitch_deg */ 3:
                    message.pitchDeg = reader.float();
                    break;
                case /* float yaw_deg */ 4:
                    message.yawDeg = reader.float();
                    break;
                case /* mavsdk.rpc.gimbal.GimbalMode gimbal_mode */ 5:
                    message.gimbalMode = reader.int32();
                    break;
                case /* mavsdk.rpc.gimbal.SendMode send_mode */ 6:
                    message.sendMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAnglesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* float roll_deg = 2; */
        if (message.rollDeg !== 0)
            writer.tag(2, WireType.Bit32).float(message.rollDeg);
        /* float pitch_deg = 3; */
        if (message.pitchDeg !== 0)
            writer.tag(3, WireType.Bit32).float(message.pitchDeg);
        /* float yaw_deg = 4; */
        if (message.yawDeg !== 0)
            writer.tag(4, WireType.Bit32).float(message.yawDeg);
        /* mavsdk.rpc.gimbal.GimbalMode gimbal_mode = 5; */
        if (message.gimbalMode !== 0)
            writer.tag(5, WireType.Varint).int32(message.gimbalMode);
        /* mavsdk.rpc.gimbal.SendMode send_mode = 6; */
        if (message.sendMode !== 0)
            writer.tag(6, WireType.Varint).int32(message.sendMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetAnglesRequest
 */
export const SetAnglesRequest = new SetAnglesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAnglesResponse$Type extends MessageType<SetAnglesResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetAnglesResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult }
        ]);
    }
    create(value?: PartialMessage<SetAnglesResponse>): SetAnglesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAnglesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAnglesResponse): SetAnglesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAnglesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetAnglesResponse
 */
export const SetAnglesResponse = new SetAnglesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAngularRatesRequest$Type extends MessageType<SetAngularRatesRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetAngularRatesRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "roll_rate_deg_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "pitch_rate_deg_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "yaw_rate_deg_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "gimbal_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.GimbalMode", GimbalMode, "GIMBAL_MODE_"] },
            { no: 6, name: "send_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.SendMode", SendMode, "SEND_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<SetAngularRatesRequest>): SetAngularRatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.rollRateDegS = 0;
        message.pitchRateDegS = 0;
        message.yawRateDegS = 0;
        message.gimbalMode = 0;
        message.sendMode = 0;
        if (value !== undefined)
            reflectionMergePartial<SetAngularRatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAngularRatesRequest): SetAngularRatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* float roll_rate_deg_s */ 2:
                    message.rollRateDegS = reader.float();
                    break;
                case /* float pitch_rate_deg_s */ 3:
                    message.pitchRateDegS = reader.float();
                    break;
                case /* float yaw_rate_deg_s */ 4:
                    message.yawRateDegS = reader.float();
                    break;
                case /* mavsdk.rpc.gimbal.GimbalMode gimbal_mode */ 5:
                    message.gimbalMode = reader.int32();
                    break;
                case /* mavsdk.rpc.gimbal.SendMode send_mode */ 6:
                    message.sendMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAngularRatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* float roll_rate_deg_s = 2; */
        if (message.rollRateDegS !== 0)
            writer.tag(2, WireType.Bit32).float(message.rollRateDegS);
        /* float pitch_rate_deg_s = 3; */
        if (message.pitchRateDegS !== 0)
            writer.tag(3, WireType.Bit32).float(message.pitchRateDegS);
        /* float yaw_rate_deg_s = 4; */
        if (message.yawRateDegS !== 0)
            writer.tag(4, WireType.Bit32).float(message.yawRateDegS);
        /* mavsdk.rpc.gimbal.GimbalMode gimbal_mode = 5; */
        if (message.gimbalMode !== 0)
            writer.tag(5, WireType.Varint).int32(message.gimbalMode);
        /* mavsdk.rpc.gimbal.SendMode send_mode = 6; */
        if (message.sendMode !== 0)
            writer.tag(6, WireType.Varint).int32(message.sendMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetAngularRatesRequest
 */
export const SetAngularRatesRequest = new SetAngularRatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAngularRatesResponse$Type extends MessageType<SetAngularRatesResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetAngularRatesResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult }
        ]);
    }
    create(value?: PartialMessage<SetAngularRatesResponse>): SetAngularRatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAngularRatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAngularRatesResponse): SetAngularRatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAngularRatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetAngularRatesResponse
 */
export const SetAngularRatesResponse = new SetAngularRatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRoiLocationRequest$Type extends MessageType<SetRoiLocationRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetRoiLocationRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SetRoiLocationRequest>): SetRoiLocationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.altitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<SetRoiLocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRoiLocationRequest): SetRoiLocationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* double latitude_deg */ 2:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 3:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float altitude_m */ 4:
                    message.altitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRoiLocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* double latitude_deg = 2; */
        if (message.latitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 3; */
        if (message.longitudeDeg !== 0)
            writer.tag(3, WireType.Bit64).double(message.longitudeDeg);
        /* float altitude_m = 4; */
        if (message.altitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.altitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetRoiLocationRequest
 */
export const SetRoiLocationRequest = new SetRoiLocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRoiLocationResponse$Type extends MessageType<SetRoiLocationResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.SetRoiLocationResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult }
        ]);
    }
    create(value?: PartialMessage<SetRoiLocationResponse>): SetRoiLocationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetRoiLocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRoiLocationResponse): SetRoiLocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRoiLocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SetRoiLocationResponse
 */
export const SetRoiLocationResponse = new SetRoiLocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeControlRequest$Type extends MessageType<TakeControlRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.TakeControlRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "control_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.ControlMode", ControlMode, "CONTROL_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<TakeControlRequest>): TakeControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.controlMode = 0;
        if (value !== undefined)
            reflectionMergePartial<TakeControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeControlRequest): TakeControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* mavsdk.rpc.gimbal.ControlMode control_mode */ 2:
                    message.controlMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* mavsdk.rpc.gimbal.ControlMode control_mode = 2; */
        if (message.controlMode !== 0)
            writer.tag(2, WireType.Varint).int32(message.controlMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.TakeControlRequest
 */
export const TakeControlRequest = new TakeControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeControlResponse$Type extends MessageType<TakeControlResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.TakeControlResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult }
        ]);
    }
    create(value?: PartialMessage<TakeControlResponse>): TakeControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TakeControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeControlResponse): TakeControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.TakeControlResponse
 */
export const TakeControlResponse = new TakeControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseControlRequest$Type extends MessageType<ReleaseControlRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.ReleaseControlRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReleaseControlRequest>): ReleaseControlRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        if (value !== undefined)
            reflectionMergePartial<ReleaseControlRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseControlRequest): ReleaseControlRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseControlRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.ReleaseControlRequest
 */
export const ReleaseControlRequest = new ReleaseControlRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReleaseControlResponse$Type extends MessageType<ReleaseControlResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.ReleaseControlResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult }
        ]);
    }
    create(value?: PartialMessage<ReleaseControlResponse>): ReleaseControlResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ReleaseControlResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReleaseControlResponse): ReleaseControlResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReleaseControlResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.ReleaseControlResponse
 */
export const ReleaseControlResponse = new ReleaseControlResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeControlStatusRequest$Type extends MessageType<SubscribeControlStatusRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SubscribeControlStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeControlStatusRequest>): SubscribeControlStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeControlStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeControlStatusRequest): SubscribeControlStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeControlStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SubscribeControlStatusRequest
 */
export const SubscribeControlStatusRequest = new SubscribeControlStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlStatusResponse$Type extends MessageType<ControlStatusResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.ControlStatusResponse", [
            { no: 1, name: "control_status", kind: "message", T: () => ControlStatus }
        ]);
    }
    create(value?: PartialMessage<ControlStatusResponse>): ControlStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ControlStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControlStatusResponse): ControlStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.ControlStatus control_status */ 1:
                    message.controlStatus = ControlStatus.internalBinaryRead(reader, reader.uint32(), options, message.controlStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControlStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.ControlStatus control_status = 1; */
        if (message.controlStatus)
            ControlStatus.internalBinaryWrite(message.controlStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.ControlStatusResponse
 */
export const ControlStatusResponse = new ControlStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetControlStatusRequest$Type extends MessageType<GetControlStatusRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.GetControlStatusRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetControlStatusRequest>): GetControlStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetControlStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetControlStatusRequest): GetControlStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetControlStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GetControlStatusRequest
 */
export const GetControlStatusRequest = new GetControlStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetControlStatusResponse$Type extends MessageType<GetControlStatusResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.GetControlStatusResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult },
            { no: 2, name: "control_status", kind: "message", T: () => ControlStatus }
        ]);
    }
    create(value?: PartialMessage<GetControlStatusResponse>): GetControlStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetControlStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetControlStatusResponse): GetControlStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                case /* mavsdk.rpc.gimbal.ControlStatus control_status */ 2:
                    message.controlStatus = ControlStatus.internalBinaryRead(reader, reader.uint32(), options, message.controlStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetControlStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.ControlStatus control_status = 2; */
        if (message.controlStatus)
            ControlStatus.internalBinaryWrite(message.controlStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GetControlStatusResponse
 */
export const GetControlStatusResponse = new GetControlStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.gimbal.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EulerAngle$Type extends MessageType<EulerAngle> {
    constructor() {
        super("mavsdk.rpc.gimbal.EulerAngle", [
            { no: 1, name: "roll_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<EulerAngle>): EulerAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollDeg = 0;
        message.pitchDeg = 0;
        message.yawDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<EulerAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EulerAngle): EulerAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_deg */ 1:
                    message.rollDeg = reader.float();
                    break;
                case /* float pitch_deg */ 2:
                    message.pitchDeg = reader.float();
                    break;
                case /* float yaw_deg */ 3:
                    message.yawDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EulerAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_deg = 1; */
        if (message.rollDeg !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollDeg);
        /* float pitch_deg = 2; */
        if (message.pitchDeg !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchDeg);
        /* float yaw_deg = 3; */
        if (message.yawDeg !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.EulerAngle
 */
export const EulerAngle = new EulerAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngularVelocityBody$Type extends MessageType<AngularVelocityBody> {
    constructor() {
        super("mavsdk.rpc.gimbal.AngularVelocityBody", [
            { no: 1, name: "roll_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "pitch_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "yaw_rad_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<AngularVelocityBody>): AngularVelocityBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollRadS = 0;
        message.pitchRadS = 0;
        message.yawRadS = 0;
        if (value !== undefined)
            reflectionMergePartial<AngularVelocityBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AngularVelocityBody): AngularVelocityBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_rad_s */ 1:
                    message.rollRadS = reader.float();
                    break;
                case /* float pitch_rad_s */ 2:
                    message.pitchRadS = reader.float();
                    break;
                case /* float yaw_rad_s */ 3:
                    message.yawRadS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AngularVelocityBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_rad_s = 1; */
        if (message.rollRadS !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollRadS);
        /* float pitch_rad_s = 2; */
        if (message.pitchRadS !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchRadS);
        /* float yaw_rad_s = 3; */
        if (message.yawRadS !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawRadS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.AngularVelocityBody
 */
export const AngularVelocityBody = new AngularVelocityBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Attitude$Type extends MessageType<Attitude> {
    constructor() {
        super("mavsdk.rpc.gimbal.Attitude", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "euler_angle_forward", kind: "message", T: () => EulerAngle },
            { no: 3, name: "quaternion_forward", kind: "message", T: () => Quaternion },
            { no: 4, name: "euler_angle_north", kind: "message", T: () => EulerAngle },
            { no: 5, name: "quaternion_north", kind: "message", T: () => Quaternion },
            { no: 6, name: "angular_velocity", kind: "message", T: () => AngularVelocityBody },
            { no: 7, name: "timestamp_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Attitude>): Attitude {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.timestampUs = 0n;
        if (value !== undefined)
            reflectionMergePartial<Attitude>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Attitude): Attitude {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* mavsdk.rpc.gimbal.EulerAngle euler_angle_forward */ 2:
                    message.eulerAngleForward = EulerAngle.internalBinaryRead(reader, reader.uint32(), options, message.eulerAngleForward);
                    break;
                case /* mavsdk.rpc.gimbal.Quaternion quaternion_forward */ 3:
                    message.quaternionForward = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.quaternionForward);
                    break;
                case /* mavsdk.rpc.gimbal.EulerAngle euler_angle_north */ 4:
                    message.eulerAngleNorth = EulerAngle.internalBinaryRead(reader, reader.uint32(), options, message.eulerAngleNorth);
                    break;
                case /* mavsdk.rpc.gimbal.Quaternion quaternion_north */ 5:
                    message.quaternionNorth = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.quaternionNorth);
                    break;
                case /* mavsdk.rpc.gimbal.AngularVelocityBody angular_velocity */ 6:
                    message.angularVelocity = AngularVelocityBody.internalBinaryRead(reader, reader.uint32(), options, message.angularVelocity);
                    break;
                case /* uint64 timestamp_us */ 7:
                    message.timestampUs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Attitude, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* mavsdk.rpc.gimbal.EulerAngle euler_angle_forward = 2; */
        if (message.eulerAngleForward)
            EulerAngle.internalBinaryWrite(message.eulerAngleForward, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.Quaternion quaternion_forward = 3; */
        if (message.quaternionForward)
            Quaternion.internalBinaryWrite(message.quaternionForward, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.EulerAngle euler_angle_north = 4; */
        if (message.eulerAngleNorth)
            EulerAngle.internalBinaryWrite(message.eulerAngleNorth, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.Quaternion quaternion_north = 5; */
        if (message.quaternionNorth)
            Quaternion.internalBinaryWrite(message.quaternionNorth, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.AngularVelocityBody angular_velocity = 6; */
        if (message.angularVelocity)
            AngularVelocityBody.internalBinaryWrite(message.angularVelocity, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 timestamp_us = 7; */
        if (message.timestampUs !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.timestampUs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.Attitude
 */
export const Attitude = new Attitude$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAttitudeRequest$Type extends MessageType<SubscribeAttitudeRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SubscribeAttitudeRequest", []);
    }
    create(value?: PartialMessage<SubscribeAttitudeRequest>): SubscribeAttitudeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeAttitudeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAttitudeRequest): SubscribeAttitudeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAttitudeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SubscribeAttitudeRequest
 */
export const SubscribeAttitudeRequest = new SubscribeAttitudeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttitudeResponse$Type extends MessageType<AttitudeResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.AttitudeResponse", [
            { no: 1, name: "attitude", kind: "message", T: () => Attitude }
        ]);
    }
    create(value?: PartialMessage<AttitudeResponse>): AttitudeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AttitudeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttitudeResponse): AttitudeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.Attitude attitude */ 1:
                    message.attitude = Attitude.internalBinaryRead(reader, reader.uint32(), options, message.attitude);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttitudeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.Attitude attitude = 1; */
        if (message.attitude)
            Attitude.internalBinaryWrite(message.attitude, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.AttitudeResponse
 */
export const AttitudeResponse = new AttitudeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttitudeRequest$Type extends MessageType<GetAttitudeRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.GetAttitudeRequest", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAttitudeRequest>): GetAttitudeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetAttitudeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttitudeRequest): GetAttitudeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttitudeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GetAttitudeRequest
 */
export const GetAttitudeRequest = new GetAttitudeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAttitudeResponse$Type extends MessageType<GetAttitudeResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.GetAttitudeResponse", [
            { no: 1, name: "gimbal_result", kind: "message", T: () => GimbalResult },
            { no: 2, name: "attitude", kind: "message", T: () => Attitude }
        ]);
    }
    create(value?: PartialMessage<GetAttitudeResponse>): GetAttitudeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAttitudeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAttitudeResponse): GetAttitudeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult gimbal_result */ 1:
                    message.gimbalResult = GimbalResult.internalBinaryRead(reader, reader.uint32(), options, message.gimbalResult);
                    break;
                case /* mavsdk.rpc.gimbal.Attitude attitude */ 2:
                    message.attitude = Attitude.internalBinaryRead(reader, reader.uint32(), options, message.attitude);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAttitudeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult gimbal_result = 1; */
        if (message.gimbalResult)
            GimbalResult.internalBinaryWrite(message.gimbalResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.gimbal.Attitude attitude = 2; */
        if (message.attitude)
            Attitude.internalBinaryWrite(message.attitude, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GetAttitudeResponse
 */
export const GetAttitudeResponse = new GetAttitudeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeGimbalListRequest$Type extends MessageType<SubscribeGimbalListRequest> {
    constructor() {
        super("mavsdk.rpc.gimbal.SubscribeGimbalListRequest", []);
    }
    create(value?: PartialMessage<SubscribeGimbalListRequest>): SubscribeGimbalListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeGimbalListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeGimbalListRequest): SubscribeGimbalListRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeGimbalListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.SubscribeGimbalListRequest
 */
export const SubscribeGimbalListRequest = new SubscribeGimbalListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GimbalListResponse$Type extends MessageType<GimbalListResponse> {
    constructor() {
        super("mavsdk.rpc.gimbal.GimbalListResponse", [
            { no: 1, name: "gimbal_list", kind: "message", T: () => GimbalList }
        ]);
    }
    create(value?: PartialMessage<GimbalListResponse>): GimbalListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GimbalListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GimbalListResponse): GimbalListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalList gimbal_list */ 1:
                    message.gimbalList = GimbalList.internalBinaryRead(reader, reader.uint32(), options, message.gimbalList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GimbalListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalList gimbal_list = 1; */
        if (message.gimbalList)
            GimbalList.internalBinaryWrite(message.gimbalList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GimbalListResponse
 */
export const GimbalListResponse = new GimbalListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GimbalItem$Type extends MessageType<GimbalItem> {
    constructor() {
        super("mavsdk.rpc.gimbal.GimbalItem", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "vendor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "model_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "custom_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gimbal_manager_component_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gimbal_device_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GimbalItem>): GimbalItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.vendorName = "";
        message.modelName = "";
        message.customName = "";
        message.gimbalManagerComponentId = 0;
        message.gimbalDeviceId = 0;
        if (value !== undefined)
            reflectionMergePartial<GimbalItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GimbalItem): GimbalItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* string vendor_name */ 2:
                    message.vendorName = reader.string();
                    break;
                case /* string model_name */ 3:
                    message.modelName = reader.string();
                    break;
                case /* string custom_name */ 4:
                    message.customName = reader.string();
                    break;
                case /* int32 gimbal_manager_component_id */ 5:
                    message.gimbalManagerComponentId = reader.int32();
                    break;
                case /* int32 gimbal_device_id */ 6:
                    message.gimbalDeviceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GimbalItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* string vendor_name = 2; */
        if (message.vendorName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.vendorName);
        /* string model_name = 3; */
        if (message.modelName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.modelName);
        /* string custom_name = 4; */
        if (message.customName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.customName);
        /* int32 gimbal_manager_component_id = 5; */
        if (message.gimbalManagerComponentId !== 0)
            writer.tag(5, WireType.Varint).int32(message.gimbalManagerComponentId);
        /* int32 gimbal_device_id = 6; */
        if (message.gimbalDeviceId !== 0)
            writer.tag(6, WireType.Varint).int32(message.gimbalDeviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GimbalItem
 */
export const GimbalItem = new GimbalItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GimbalList$Type extends MessageType<GimbalList> {
    constructor() {
        super("mavsdk.rpc.gimbal.GimbalList", [
            { no: 1, name: "gimbals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GimbalItem }
        ]);
    }
    create(value?: PartialMessage<GimbalList>): GimbalList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbals = [];
        if (value !== undefined)
            reflectionMergePartial<GimbalList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GimbalList): GimbalList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mavsdk.rpc.gimbal.GimbalItem gimbals */ 1:
                    message.gimbals.push(GimbalItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GimbalList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mavsdk.rpc.gimbal.GimbalItem gimbals = 1; */
        for (let i = 0; i < message.gimbals.length; i++)
            GimbalItem.internalBinaryWrite(message.gimbals[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GimbalList
 */
export const GimbalList = new GimbalList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlStatus$Type extends MessageType<ControlStatus> {
    constructor() {
        super("mavsdk.rpc.gimbal.ControlStatus", [
            { no: 1, name: "gimbal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "control_mode", kind: "enum", T: () => ["mavsdk.rpc.gimbal.ControlMode", ControlMode, "CONTROL_MODE_"] },
            { no: 3, name: "sysid_primary_control", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "compid_primary_control", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "sysid_secondary_control", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "compid_secondary_control", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ControlStatus>): ControlStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gimbalId = 0;
        message.controlMode = 0;
        message.sysidPrimaryControl = 0;
        message.compidPrimaryControl = 0;
        message.sysidSecondaryControl = 0;
        message.compidSecondaryControl = 0;
        if (value !== undefined)
            reflectionMergePartial<ControlStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControlStatus): ControlStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 gimbal_id */ 1:
                    message.gimbalId = reader.int32();
                    break;
                case /* mavsdk.rpc.gimbal.ControlMode control_mode */ 2:
                    message.controlMode = reader.int32();
                    break;
                case /* int32 sysid_primary_control */ 3:
                    message.sysidPrimaryControl = reader.int32();
                    break;
                case /* int32 compid_primary_control */ 4:
                    message.compidPrimaryControl = reader.int32();
                    break;
                case /* int32 sysid_secondary_control */ 5:
                    message.sysidSecondaryControl = reader.int32();
                    break;
                case /* int32 compid_secondary_control */ 6:
                    message.compidSecondaryControl = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControlStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 gimbal_id = 1; */
        if (message.gimbalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.gimbalId);
        /* mavsdk.rpc.gimbal.ControlMode control_mode = 2; */
        if (message.controlMode !== 0)
            writer.tag(2, WireType.Varint).int32(message.controlMode);
        /* int32 sysid_primary_control = 3; */
        if (message.sysidPrimaryControl !== 0)
            writer.tag(3, WireType.Varint).int32(message.sysidPrimaryControl);
        /* int32 compid_primary_control = 4; */
        if (message.compidPrimaryControl !== 0)
            writer.tag(4, WireType.Varint).int32(message.compidPrimaryControl);
        /* int32 sysid_secondary_control = 5; */
        if (message.sysidSecondaryControl !== 0)
            writer.tag(5, WireType.Varint).int32(message.sysidSecondaryControl);
        /* int32 compid_secondary_control = 6; */
        if (message.compidSecondaryControl !== 0)
            writer.tag(6, WireType.Varint).int32(message.compidSecondaryControl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.ControlStatus
 */
export const ControlStatus = new ControlStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GimbalResult$Type extends MessageType<GimbalResult> {
    constructor() {
        super("mavsdk.rpc.gimbal.GimbalResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.gimbal.GimbalResult.Result", GimbalResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GimbalResult>): GimbalResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<GimbalResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GimbalResult): GimbalResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.gimbal.GimbalResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GimbalResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.gimbal.GimbalResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.gimbal.GimbalResult
 */
export const GimbalResult = new GimbalResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.gimbal.GimbalService
 */
export const GimbalService = new ServiceType("mavsdk.rpc.gimbal.GimbalService", [
    { name: "SetAngles", options: {}, I: SetAnglesRequest, O: SetAnglesResponse },
    { name: "SetAngularRates", options: {}, I: SetAngularRatesRequest, O: SetAngularRatesResponse },
    { name: "SetRoiLocation", options: {}, I: SetRoiLocationRequest, O: SetRoiLocationResponse },
    { name: "TakeControl", options: {}, I: TakeControlRequest, O: TakeControlResponse },
    { name: "ReleaseControl", options: {}, I: ReleaseControlRequest, O: ReleaseControlResponse },
    { name: "SubscribeGimbalList", serverStreaming: true, options: {}, I: SubscribeGimbalListRequest, O: GimbalListResponse },
    { name: "SubscribeControlStatus", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeControlStatusRequest, O: ControlStatusResponse },
    { name: "GetControlStatus", options: { "mavsdk.options.async_type": "SYNC" }, I: GetControlStatusRequest, O: GetControlStatusResponse },
    { name: "SubscribeAttitude", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeAttitudeRequest, O: AttitudeResponse },
    { name: "GetAttitude", options: { "mavsdk.options.async_type": "SYNC" }, I: GetAttitudeRequest, O: GetAttitudeResponse }
]);
