/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "action_server/action_server.proto" (package "mavsdk.rpc.action_server", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetAllowTakeoffRequest
 */
export interface SetAllowTakeoffRequest {
    /**
     * @generated from protobuf field: bool allow_takeoff = 1;
     */
    allowTakeoff: boolean; // Is takeoff allowed?
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetArmableRequest
 */
export interface SetArmableRequest {
    /**
     * @generated from protobuf field: bool armable = 1;
     */
    armable: boolean; // Is Armable now?
    /**
     * @generated from protobuf field: bool force_armable = 2;
     */
    forceArmable: boolean; // Is armable with force?
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetDisarmableRequest
 */
export interface SetDisarmableRequest {
    /**
     * @generated from protobuf field: bool disarmable = 1;
     */
    disarmable: boolean; // Is disarmable now?
    /**
     * @generated from protobuf field: bool force_disarmable = 2;
     */
    forceDisarmable: boolean; // Is disarmable with force? (Kill)
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetAllowableFlightModesRequest
 */
export interface SetAllowableFlightModesRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.AllowableFlightModes flight_modes = 1;
     */
    flightModes?: AllowableFlightModes;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.GetAllowableFlightModesRequest
 */
export interface GetAllowableFlightModesRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeArmDisarmRequest
 */
export interface SubscribeArmDisarmRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeFlightModeChangeRequest
 */
export interface SubscribeFlightModeChangeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeTakeoffRequest
 */
export interface SubscribeTakeoffRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeLandRequest
 */
export interface SubscribeLandRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeRebootRequest
 */
export interface SubscribeRebootRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeShutdownRequest
 */
export interface SubscribeShutdownRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SubscribeTerminateRequest
 */
export interface SubscribeTerminateRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.ArmDisarmResponse
 */
export interface ArmDisarmResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ArmDisarm arm = 2;
     */
    arm?: ArmDisarm;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.FlightModeChangeResponse
 */
export interface FlightModeChangeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.FlightMode flight_mode = 2;
     */
    flightMode: FlightMode;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.TakeoffResponse
 */
export interface TakeoffResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: bool takeoff = 2;
     */
    takeoff: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.LandResponse
 */
export interface LandResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: bool land = 2;
     */
    land: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.RebootResponse
 */
export interface RebootResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: bool reboot = 2;
     */
    reboot: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.ShutdownResponse
 */
export interface ShutdownResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: bool shutdown = 2;
     */
    shutdown: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.TerminateResponse
 */
export interface TerminateResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
    /**
     * @generated from protobuf field: bool terminate = 2;
     */
    terminate: boolean;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetArmableResponse
 */
export interface SetArmableResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetDisarmableResponse
 */
export interface SetDisarmableResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetAllowableFlightModesResponse
 */
export interface SetAllowableFlightModesResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.SetAllowTakeoffResponse
 */
export interface SetAllowTakeoffResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult action_server_result = 1;
     */
    actionServerResult?: ActionServerResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.action_server.GetAllowableFlightModesResponse
 */
export interface GetAllowableFlightModesResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.AllowableFlightModes flight_modes = 1;
     */
    flightModes?: AllowableFlightModes;
}
/**
 * State to check if the vehicle can transition to
 * respective flightmodes
 *
 * @generated from protobuf message mavsdk.rpc.action_server.AllowableFlightModes
 */
export interface AllowableFlightModes {
    /**
     * @generated from protobuf field: bool can_auto_mode = 1;
     */
    canAutoMode: boolean; // Auto/mission mode 
    /**
     * @generated from protobuf field: bool can_guided_mode = 2;
     */
    canGuidedMode: boolean; // Guided mode
    /**
     * @generated from protobuf field: bool can_stabilize_mode = 3;
     */
    canStabilizeMode: boolean; // Stabilize mode
}
/**
 * Arming message type
 *
 * @generated from protobuf message mavsdk.rpc.action_server.ArmDisarm
 */
export interface ArmDisarm {
    /**
     * @generated from protobuf field: bool arm = 1;
     */
    arm: boolean; // Should vehicle arm
    /**
     * @generated from protobuf field: bool force = 2;
     */
    force: boolean; // Should arm override pre-flight checks
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.action_server.ActionServerResult
 */
export interface ActionServerResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.action_server.ActionServerResult.Result result = 1;
     */
    result: ActionServerResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for action requests.
 *
 * @generated from protobuf enum mavsdk.rpc.action_server.ActionServerResult.Result
 */
export enum ActionServerResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request was successful
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system is connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Connection error
     *
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 3;
     */
    CONNECTION_ERROR = 3,
    /**
     * Vehicle is busy
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Command refused by vehicle
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED = 5;
     */
    COMMAND_DENIED = 5,
    /**
     * Command refused because landed state is unknown
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED_LANDED_STATE_UNKNOWN = 6;
     */
    COMMAND_DENIED_LANDED_STATE_UNKNOWN = 6,
    /**
     * Command refused because vehicle not landed
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED_NOT_LANDED = 7;
     */
    COMMAND_DENIED_NOT_LANDED = 7,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 8;
     */
    TIMEOUT = 8,
    /**
     * Hybrid/VTOL transition support is unknown
     *
     * @generated from protobuf enum value: RESULT_VTOL_TRANSITION_SUPPORT_UNKNOWN = 9;
     */
    VTOL_TRANSITION_SUPPORT_UNKNOWN = 9,
    /**
     * Vehicle does not support hybrid/VTOL transitions
     *
     * @generated from protobuf enum value: RESULT_NO_VTOL_TRANSITION_SUPPORT = 10;
     */
    NO_VTOL_TRANSITION_SUPPORT = 10,
    /**
     * Error getting or setting parameter
     *
     * @generated from protobuf enum value: RESULT_PARAMETER_ERROR = 11;
     */
    PARAMETER_ERROR = 11,
    /**
     * Intermediate message showing progress or instructions on the next steps
     *
     * @generated from protobuf enum value: RESULT_NEXT = 12;
     */
    NEXT = 12
}
/**
 *
 * Flight modes.
 *
 * For more information about flight modes, check out
 * https://docs.px4.io/master/en/config/flight_mode.html.
 *
 * @generated from protobuf enum mavsdk.rpc.action_server.FlightMode
 */
export enum FlightMode {
    /**
     * Mode not known
     *
     * @generated from protobuf enum value: FLIGHT_MODE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Armed and ready to take off
     *
     * @generated from protobuf enum value: FLIGHT_MODE_READY = 1;
     */
    READY = 1,
    /**
     * Taking off
     *
     * @generated from protobuf enum value: FLIGHT_MODE_TAKEOFF = 2;
     */
    TAKEOFF = 2,
    /**
     * Holding (hovering in place (or circling for fixed-wing vehicles)
     *
     * @generated from protobuf enum value: FLIGHT_MODE_HOLD = 3;
     */
    HOLD = 3,
    /**
     * In mission
     *
     * @generated from protobuf enum value: FLIGHT_MODE_MISSION = 4;
     */
    MISSION = 4,
    /**
     * Returning to launch position (then landing)
     *
     * @generated from protobuf enum value: FLIGHT_MODE_RETURN_TO_LAUNCH = 5;
     */
    RETURN_TO_LAUNCH = 5,
    /**
     * Landing
     *
     * @generated from protobuf enum value: FLIGHT_MODE_LAND = 6;
     */
    LAND = 6,
    /**
     * In 'offboard' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_OFFBOARD = 7;
     */
    OFFBOARD = 7,
    /**
     * In 'follow-me' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_FOLLOW_ME = 8;
     */
    FOLLOW_ME = 8,
    /**
     * In 'Manual' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_MANUAL = 9;
     */
    MANUAL = 9,
    /**
     * In 'Altitude Control' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_ALTCTL = 10;
     */
    ALTCTL = 10,
    /**
     * In 'Position Control' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_POSCTL = 11;
     */
    POSCTL = 11,
    /**
     * In 'Acro' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_ACRO = 12;
     */
    ACRO = 12,
    /**
     * In 'Stabilize' mode
     *
     * @generated from protobuf enum value: FLIGHT_MODE_STABILIZED = 13;
     */
    STABILIZED = 13
}
// @generated message type with reflection information, may provide speed optimized methods
class SetAllowTakeoffRequest$Type extends MessageType<SetAllowTakeoffRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SetAllowTakeoffRequest", [
            { no: 1, name: "allow_takeoff", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetAllowTakeoffRequest>): SetAllowTakeoffRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowTakeoff = false;
        if (value !== undefined)
            reflectionMergePartial<SetAllowTakeoffRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAllowTakeoffRequest): SetAllowTakeoffRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool allow_takeoff */ 1:
                    message.allowTakeoff = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAllowTakeoffRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool allow_takeoff = 1; */
        if (message.allowTakeoff !== false)
            writer.tag(1, WireType.Varint).bool(message.allowTakeoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetAllowTakeoffRequest
 */
export const SetAllowTakeoffRequest = new SetAllowTakeoffRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetArmableRequest$Type extends MessageType<SetArmableRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SetArmableRequest", [
            { no: 1, name: "armable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "force_armable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetArmableRequest>): SetArmableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.armable = false;
        message.forceArmable = false;
        if (value !== undefined)
            reflectionMergePartial<SetArmableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetArmableRequest): SetArmableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool armable */ 1:
                    message.armable = reader.bool();
                    break;
                case /* bool force_armable */ 2:
                    message.forceArmable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetArmableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool armable = 1; */
        if (message.armable !== false)
            writer.tag(1, WireType.Varint).bool(message.armable);
        /* bool force_armable = 2; */
        if (message.forceArmable !== false)
            writer.tag(2, WireType.Varint).bool(message.forceArmable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetArmableRequest
 */
export const SetArmableRequest = new SetArmableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDisarmableRequest$Type extends MessageType<SetDisarmableRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SetDisarmableRequest", [
            { no: 1, name: "disarmable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "force_disarmable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetDisarmableRequest>): SetDisarmableRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disarmable = false;
        message.forceDisarmable = false;
        if (value !== undefined)
            reflectionMergePartial<SetDisarmableRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDisarmableRequest): SetDisarmableRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disarmable */ 1:
                    message.disarmable = reader.bool();
                    break;
                case /* bool force_disarmable */ 2:
                    message.forceDisarmable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDisarmableRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disarmable = 1; */
        if (message.disarmable !== false)
            writer.tag(1, WireType.Varint).bool(message.disarmable);
        /* bool force_disarmable = 2; */
        if (message.forceDisarmable !== false)
            writer.tag(2, WireType.Varint).bool(message.forceDisarmable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetDisarmableRequest
 */
export const SetDisarmableRequest = new SetDisarmableRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAllowableFlightModesRequest$Type extends MessageType<SetAllowableFlightModesRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SetAllowableFlightModesRequest", [
            { no: 1, name: "flight_modes", kind: "message", T: () => AllowableFlightModes }
        ]);
    }
    create(value?: PartialMessage<SetAllowableFlightModesRequest>): SetAllowableFlightModesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAllowableFlightModesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAllowableFlightModesRequest): SetAllowableFlightModesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.AllowableFlightModes flight_modes */ 1:
                    message.flightModes = AllowableFlightModes.internalBinaryRead(reader, reader.uint32(), options, message.flightModes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAllowableFlightModesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.AllowableFlightModes flight_modes = 1; */
        if (message.flightModes)
            AllowableFlightModes.internalBinaryWrite(message.flightModes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetAllowableFlightModesRequest
 */
export const SetAllowableFlightModesRequest = new SetAllowableFlightModesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllowableFlightModesRequest$Type extends MessageType<GetAllowableFlightModesRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.GetAllowableFlightModesRequest", []);
    }
    create(value?: PartialMessage<GetAllowableFlightModesRequest>): GetAllowableFlightModesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAllowableFlightModesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllowableFlightModesRequest): GetAllowableFlightModesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAllowableFlightModesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.GetAllowableFlightModesRequest
 */
export const GetAllowableFlightModesRequest = new GetAllowableFlightModesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeArmDisarmRequest$Type extends MessageType<SubscribeArmDisarmRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeArmDisarmRequest", []);
    }
    create(value?: PartialMessage<SubscribeArmDisarmRequest>): SubscribeArmDisarmRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeArmDisarmRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeArmDisarmRequest): SubscribeArmDisarmRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeArmDisarmRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeArmDisarmRequest
 */
export const SubscribeArmDisarmRequest = new SubscribeArmDisarmRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeFlightModeChangeRequest$Type extends MessageType<SubscribeFlightModeChangeRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeFlightModeChangeRequest", []);
    }
    create(value?: PartialMessage<SubscribeFlightModeChangeRequest>): SubscribeFlightModeChangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeFlightModeChangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeFlightModeChangeRequest): SubscribeFlightModeChangeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeFlightModeChangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeFlightModeChangeRequest
 */
export const SubscribeFlightModeChangeRequest = new SubscribeFlightModeChangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTakeoffRequest$Type extends MessageType<SubscribeTakeoffRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeTakeoffRequest", []);
    }
    create(value?: PartialMessage<SubscribeTakeoffRequest>): SubscribeTakeoffRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTakeoffRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTakeoffRequest): SubscribeTakeoffRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTakeoffRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeTakeoffRequest
 */
export const SubscribeTakeoffRequest = new SubscribeTakeoffRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeLandRequest$Type extends MessageType<SubscribeLandRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeLandRequest", []);
    }
    create(value?: PartialMessage<SubscribeLandRequest>): SubscribeLandRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeLandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeLandRequest): SubscribeLandRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeLandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeLandRequest
 */
export const SubscribeLandRequest = new SubscribeLandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRebootRequest$Type extends MessageType<SubscribeRebootRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeRebootRequest", []);
    }
    create(value?: PartialMessage<SubscribeRebootRequest>): SubscribeRebootRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeRebootRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRebootRequest): SubscribeRebootRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeRebootRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeRebootRequest
 */
export const SubscribeRebootRequest = new SubscribeRebootRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeShutdownRequest$Type extends MessageType<SubscribeShutdownRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeShutdownRequest", []);
    }
    create(value?: PartialMessage<SubscribeShutdownRequest>): SubscribeShutdownRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeShutdownRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeShutdownRequest): SubscribeShutdownRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeShutdownRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeShutdownRequest
 */
export const SubscribeShutdownRequest = new SubscribeShutdownRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTerminateRequest$Type extends MessageType<SubscribeTerminateRequest> {
    constructor() {
        super("mavsdk.rpc.action_server.SubscribeTerminateRequest", []);
    }
    create(value?: PartialMessage<SubscribeTerminateRequest>): SubscribeTerminateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTerminateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTerminateRequest): SubscribeTerminateRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeTerminateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SubscribeTerminateRequest
 */
export const SubscribeTerminateRequest = new SubscribeTerminateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArmDisarmResponse$Type extends MessageType<ArmDisarmResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.ArmDisarmResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "arm", kind: "message", T: () => ArmDisarm }
        ]);
    }
    create(value?: PartialMessage<ArmDisarmResponse>): ArmDisarmResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ArmDisarmResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArmDisarmResponse): ArmDisarmResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* mavsdk.rpc.action_server.ArmDisarm arm */ 2:
                    message.arm = ArmDisarm.internalBinaryRead(reader, reader.uint32(), options, message.arm);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArmDisarmResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.action_server.ArmDisarm arm = 2; */
        if (message.arm)
            ArmDisarm.internalBinaryWrite(message.arm, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.ArmDisarmResponse
 */
export const ArmDisarmResponse = new ArmDisarmResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlightModeChangeResponse$Type extends MessageType<FlightModeChangeResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.FlightModeChangeResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "flight_mode", kind: "enum", T: () => ["mavsdk.rpc.action_server.FlightMode", FlightMode, "FLIGHT_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<FlightModeChangeResponse>): FlightModeChangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flightMode = 0;
        if (value !== undefined)
            reflectionMergePartial<FlightModeChangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlightModeChangeResponse): FlightModeChangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* mavsdk.rpc.action_server.FlightMode flight_mode */ 2:
                    message.flightMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlightModeChangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.action_server.FlightMode flight_mode = 2; */
        if (message.flightMode !== 0)
            writer.tag(2, WireType.Varint).int32(message.flightMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.FlightModeChangeResponse
 */
export const FlightModeChangeResponse = new FlightModeChangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeoffResponse$Type extends MessageType<TakeoffResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.TakeoffResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "takeoff", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TakeoffResponse>): TakeoffResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.takeoff = false;
        if (value !== undefined)
            reflectionMergePartial<TakeoffResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeoffResponse): TakeoffResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* bool takeoff */ 2:
                    message.takeoff = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeoffResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool takeoff = 2; */
        if (message.takeoff !== false)
            writer.tag(2, WireType.Varint).bool(message.takeoff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.TakeoffResponse
 */
export const TakeoffResponse = new TakeoffResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LandResponse$Type extends MessageType<LandResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.LandResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "land", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LandResponse>): LandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.land = false;
        if (value !== undefined)
            reflectionMergePartial<LandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LandResponse): LandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* bool land */ 2:
                    message.land = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool land = 2; */
        if (message.land !== false)
            writer.tag(2, WireType.Varint).bool(message.land);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.LandResponse
 */
export const LandResponse = new LandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RebootResponse$Type extends MessageType<RebootResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.RebootResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "reboot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RebootResponse>): RebootResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reboot = false;
        if (value !== undefined)
            reflectionMergePartial<RebootResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RebootResponse): RebootResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* bool reboot */ 2:
                    message.reboot = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RebootResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool reboot = 2; */
        if (message.reboot !== false)
            writer.tag(2, WireType.Varint).bool(message.reboot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.RebootResponse
 */
export const RebootResponse = new RebootResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownResponse$Type extends MessageType<ShutdownResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.ShutdownResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "shutdown", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ShutdownResponse>): ShutdownResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.shutdown = false;
        if (value !== undefined)
            reflectionMergePartial<ShutdownResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShutdownResponse): ShutdownResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* bool shutdown */ 2:
                    message.shutdown = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShutdownResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool shutdown = 2; */
        if (message.shutdown !== false)
            writer.tag(2, WireType.Varint).bool(message.shutdown);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.ShutdownResponse
 */
export const ShutdownResponse = new ShutdownResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminateResponse$Type extends MessageType<TerminateResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.TerminateResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult },
            { no: 2, name: "terminate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TerminateResponse>): TerminateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminate = false;
        if (value !== undefined)
            reflectionMergePartial<TerminateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminateResponse): TerminateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                case /* bool terminate */ 2:
                    message.terminate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool terminate = 2; */
        if (message.terminate !== false)
            writer.tag(2, WireType.Varint).bool(message.terminate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.TerminateResponse
 */
export const TerminateResponse = new TerminateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetArmableResponse$Type extends MessageType<SetArmableResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.SetArmableResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult }
        ]);
    }
    create(value?: PartialMessage<SetArmableResponse>): SetArmableResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetArmableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetArmableResponse): SetArmableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetArmableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetArmableResponse
 */
export const SetArmableResponse = new SetArmableResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetDisarmableResponse$Type extends MessageType<SetDisarmableResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.SetDisarmableResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult }
        ]);
    }
    create(value?: PartialMessage<SetDisarmableResponse>): SetDisarmableResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetDisarmableResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetDisarmableResponse): SetDisarmableResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetDisarmableResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetDisarmableResponse
 */
export const SetDisarmableResponse = new SetDisarmableResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAllowableFlightModesResponse$Type extends MessageType<SetAllowableFlightModesResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.SetAllowableFlightModesResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult }
        ]);
    }
    create(value?: PartialMessage<SetAllowableFlightModesResponse>): SetAllowableFlightModesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAllowableFlightModesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAllowableFlightModesResponse): SetAllowableFlightModesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAllowableFlightModesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetAllowableFlightModesResponse
 */
export const SetAllowableFlightModesResponse = new SetAllowableFlightModesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAllowTakeoffResponse$Type extends MessageType<SetAllowTakeoffResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.SetAllowTakeoffResponse", [
            { no: 1, name: "action_server_result", kind: "message", T: () => ActionServerResult }
        ]);
    }
    create(value?: PartialMessage<SetAllowTakeoffResponse>): SetAllowTakeoffResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetAllowTakeoffResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetAllowTakeoffResponse): SetAllowTakeoffResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult action_server_result */ 1:
                    message.actionServerResult = ActionServerResult.internalBinaryRead(reader, reader.uint32(), options, message.actionServerResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetAllowTakeoffResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult action_server_result = 1; */
        if (message.actionServerResult)
            ActionServerResult.internalBinaryWrite(message.actionServerResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.SetAllowTakeoffResponse
 */
export const SetAllowTakeoffResponse = new SetAllowTakeoffResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllowableFlightModesResponse$Type extends MessageType<GetAllowableFlightModesResponse> {
    constructor() {
        super("mavsdk.rpc.action_server.GetAllowableFlightModesResponse", [
            { no: 1, name: "flight_modes", kind: "message", T: () => AllowableFlightModes }
        ]);
    }
    create(value?: PartialMessage<GetAllowableFlightModesResponse>): GetAllowableFlightModesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAllowableFlightModesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllowableFlightModesResponse): GetAllowableFlightModesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.AllowableFlightModes flight_modes */ 1:
                    message.flightModes = AllowableFlightModes.internalBinaryRead(reader, reader.uint32(), options, message.flightModes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllowableFlightModesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.AllowableFlightModes flight_modes = 1; */
        if (message.flightModes)
            AllowableFlightModes.internalBinaryWrite(message.flightModes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.GetAllowableFlightModesResponse
 */
export const GetAllowableFlightModesResponse = new GetAllowableFlightModesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllowableFlightModes$Type extends MessageType<AllowableFlightModes> {
    constructor() {
        super("mavsdk.rpc.action_server.AllowableFlightModes", [
            { no: 1, name: "can_auto_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "can_guided_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "can_stabilize_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AllowableFlightModes>): AllowableFlightModes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.canAutoMode = false;
        message.canGuidedMode = false;
        message.canStabilizeMode = false;
        if (value !== undefined)
            reflectionMergePartial<AllowableFlightModes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllowableFlightModes): AllowableFlightModes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool can_auto_mode */ 1:
                    message.canAutoMode = reader.bool();
                    break;
                case /* bool can_guided_mode */ 2:
                    message.canGuidedMode = reader.bool();
                    break;
                case /* bool can_stabilize_mode */ 3:
                    message.canStabilizeMode = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AllowableFlightModes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool can_auto_mode = 1; */
        if (message.canAutoMode !== false)
            writer.tag(1, WireType.Varint).bool(message.canAutoMode);
        /* bool can_guided_mode = 2; */
        if (message.canGuidedMode !== false)
            writer.tag(2, WireType.Varint).bool(message.canGuidedMode);
        /* bool can_stabilize_mode = 3; */
        if (message.canStabilizeMode !== false)
            writer.tag(3, WireType.Varint).bool(message.canStabilizeMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.AllowableFlightModes
 */
export const AllowableFlightModes = new AllowableFlightModes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArmDisarm$Type extends MessageType<ArmDisarm> {
    constructor() {
        super("mavsdk.rpc.action_server.ArmDisarm", [
            { no: 1, name: "arm", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ArmDisarm>): ArmDisarm {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.arm = false;
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<ArmDisarm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArmDisarm): ArmDisarm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool arm */ 1:
                    message.arm = reader.bool();
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArmDisarm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool arm = 1; */
        if (message.arm !== false)
            writer.tag(1, WireType.Varint).bool(message.arm);
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.ArmDisarm
 */
export const ArmDisarm = new ArmDisarm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionServerResult$Type extends MessageType<ActionServerResult> {
    constructor() {
        super("mavsdk.rpc.action_server.ActionServerResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.action_server.ActionServerResult.Result", ActionServerResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActionServerResult>): ActionServerResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<ActionServerResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionServerResult): ActionServerResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.action_server.ActionServerResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionServerResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.action_server.ActionServerResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.action_server.ActionServerResult
 */
export const ActionServerResult = new ActionServerResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.action_server.ActionServerService
 */
export const ActionServerService = new ServiceType("mavsdk.rpc.action_server.ActionServerService", [
    { name: "SubscribeArmDisarm", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeArmDisarmRequest, O: ArmDisarmResponse },
    { name: "SubscribeFlightModeChange", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeFlightModeChangeRequest, O: FlightModeChangeResponse },
    { name: "SubscribeTakeoff", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTakeoffRequest, O: TakeoffResponse },
    { name: "SubscribeLand", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeLandRequest, O: LandResponse },
    { name: "SubscribeReboot", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeRebootRequest, O: RebootResponse },
    { name: "SubscribeShutdown", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeShutdownRequest, O: ShutdownResponse },
    { name: "SubscribeTerminate", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeTerminateRequest, O: TerminateResponse },
    { name: "SetAllowTakeoff", options: { "mavsdk.options.async_type": "SYNC" }, I: SetAllowTakeoffRequest, O: SetAllowTakeoffResponse },
    { name: "SetArmable", options: { "mavsdk.options.async_type": "SYNC" }, I: SetArmableRequest, O: SetArmableResponse },
    { name: "SetDisarmable", options: { "mavsdk.options.async_type": "SYNC" }, I: SetDisarmableRequest, O: SetDisarmableResponse },
    { name: "SetAllowableFlightModes", options: { "mavsdk.options.async_type": "SYNC" }, I: SetAllowableFlightModesRequest, O: SetAllowableFlightModesResponse },
    { name: "GetAllowableFlightModes", options: { "mavsdk.options.async_type": "SYNC" }, I: GetAllowableFlightModesRequest, O: GetAllowableFlightModesResponse }
]);
