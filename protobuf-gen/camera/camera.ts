/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "camera/camera.proto" (package "mavsdk.rpc.camera", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.camera.PrepareRequest
 */
export interface PrepareRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.PrepareResponse
 */
export interface PrepareResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TakePhotoRequest
 */
export interface TakePhotoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TakePhotoResponse
 */
export interface TakePhotoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartPhotoIntervalRequest
 */
export interface StartPhotoIntervalRequest {
    /**
     * @generated from protobuf field: float interval_s = 1;
     */
    intervalS: number; // Interval between photos (in seconds)
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartPhotoIntervalResponse
 */
export interface StartPhotoIntervalResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopPhotoIntervalRequest
 */
export interface StopPhotoIntervalRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopPhotoIntervalResponse
 */
export interface StopPhotoIntervalResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartVideoRequest
 */
export interface StartVideoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartVideoResponse
 */
export interface StartVideoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopVideoRequest
 */
export interface StopVideoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopVideoResponse
 */
export interface StopVideoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartVideoStreamingRequest
 */
export interface StartVideoStreamingRequest {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StartVideoStreamingResponse
 */
export interface StartVideoStreamingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopVideoStreamingRequest
 */
export interface StopVideoStreamingRequest {
    /**
     * @generated from protobuf field: int32 stream_id = 1;
     */
    streamId: number; // video stream id
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StopVideoStreamingResponse
 */
export interface StopVideoStreamingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SetModeRequest
 */
export interface SetModeRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Mode mode = 1;
     */
    mode: Mode; // Camera mode to set
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SetModeResponse
 */
export interface SetModeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ListPhotosRequest
 */
export interface ListPhotosRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.PhotosRange photos_range = 1;
     */
    photosRange: PhotosRange; // Which photos should be listed (all or since connection)
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ListPhotosResponse
 */
export interface ListPhotosResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.camera.CaptureInfo capture_infos = 2;
     */
    captureInfos: CaptureInfo[]; // List of capture infos (representing the photos)
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeInformationRequest
 */
export interface SubscribeInformationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.InformationResponse
 */
export interface InformationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Information information = 1;
     */
    information?: Information; // Camera information
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeModeRequest
 */
export interface SubscribeModeRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ModeResponse
 */
export interface ModeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Mode mode = 1;
     */
    mode: Mode; // Camera mode
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest
 */
export interface SubscribeVideoStreamInfoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.VideoStreamInfoResponse
 */
export interface VideoStreamInfoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.VideoStreamInfo video_stream_info = 1;
     */
    videoStreamInfo?: VideoStreamInfo; // Video stream info
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeCaptureInfoRequest
 */
export interface SubscribeCaptureInfoRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.CaptureInfoResponse
 */
export interface CaptureInfoResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CaptureInfo capture_info = 1;
     */
    captureInfo?: CaptureInfo; // Capture info
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeStatusRequest
 */
export interface SubscribeStatusRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.StatusResponse
 */
export interface StatusResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Status camera_status = 1;
     */
    cameraStatus?: Status; // Camera status
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribeCurrentSettingsRequest
 */
export interface SubscribeCurrentSettingsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.CurrentSettingsResponse
 */
export interface CurrentSettingsResponse {
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.camera.Setting current_settings = 1;
     */
    currentSettings: Setting[]; // List of current settings
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest
 */
export interface SubscribePossibleSettingOptionsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.PossibleSettingOptionsResponse
 */
export interface PossibleSettingOptionsResponse {
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.camera.SettingOptions setting_options = 1;
     */
    settingOptions: SettingOptions[]; // List of settings that can be changed
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SetSettingRequest
 */
export interface SetSettingRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Setting setting = 1;
     */
    setting?: Setting; // Desired setting
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SetSettingResponse
 */
export interface SetSettingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.GetSettingRequest
 */
export interface GetSettingRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Setting setting = 1;
     */
    setting?: Setting; // Requested setting
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.GetSettingResponse
 */
export interface GetSettingResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Setting setting = 2;
     */
    setting?: Setting; // Setting
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FormatStorageRequest
 */
export interface FormatStorageRequest {
    /**
     * @generated from protobuf field: int32 storage_id = 1;
     */
    storageId: number; // Storage identify to be format
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FormatStorageResponse
 */
export interface FormatStorageResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SelectCameraResponse
 */
export interface SelectCameraResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.SelectCameraRequest
 */
export interface SelectCameraRequest {
    /**
     * @generated from protobuf field: int32 camera_id = 1;
     */
    cameraId: number; // Id of camera to be selected
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ResetSettingsRequest
 */
export interface ResetSettingsRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ResetSettingsResponse
 */
export interface ResetSettingsResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomInStartRequest
 */
export interface ZoomInStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomInStartResponse
 */
export interface ZoomInStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomOutStartRequest
 */
export interface ZoomOutStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomOutStartResponse
 */
export interface ZoomOutStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomStopRequest
 */
export interface ZoomStopRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomStopResponse
 */
export interface ZoomStopResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomRangeRequest
 */
export interface ZoomRangeRequest {
    /**
     * @generated from protobuf field: float range = 1;
     */
    range: number; // Range must be between 0.0 and 100.0
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.ZoomRangeResponse
 */
export interface ZoomRangeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackPointRequest
 */
export interface TrackPointRequest {
    /**
     * @generated from protobuf field: float point_x = 1;
     */
    pointX: number; // Point in X axis (0..1, 0 is left, 1 is right)
    /**
     * @generated from protobuf field: float point_y = 2;
     */
    pointY: number; // Point in Y axis (0..1, 0 is top, 1 is bottom)
    /**
     * @generated from protobuf field: float radius = 3;
     */
    radius: number; // Radius (0 is one pixel, 1 is full image width)
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackPointResponse
 */
export interface TrackPointResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackRectangleRequest
 */
export interface TrackRectangleRequest {
    /**
     * @generated from protobuf field: float top_left_x = 1;
     */
    topLeftX: number; // Top left corner of rectangle x value (normalized 0..1, 0 is left, 1 is right)
    /**
     * @generated from protobuf field: float top_left_y = 2;
     */
    topLeftY: number; // Top left corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom)
    /**
     * @generated from protobuf field: float bottom_right_x = 3;
     */
    bottomRightX: number; // Bottom right corner of rectangle x value (normalized 0..1, 0 is left, 1 is right)
    /**
     * @generated from protobuf field: float bottom_right_y = 4;
     */
    bottomRightY: number; // Bottom right corner of rectangle y value (normalized 0..1, 0 is top, 1 is bottom)
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackRectangleResponse
 */
export interface TrackRectangleResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackStopRequest
 */
export interface TrackStopRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.TrackStopResponse
 */
export interface TrackStopResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusInStartRequest
 */
export interface FocusInStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusInStartResponse
 */
export interface FocusInStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusOutStartRequest
 */
export interface FocusOutStartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusOutStartResponse
 */
export interface FocusOutStartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusStopRequest
 */
export interface FocusStopRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusStopResponse
 */
export interface FocusStopResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusRangeRequest
 */
export interface FocusRangeRequest {
    /**
     * @generated from protobuf field: float range = 1;
     */
    range: number; // Range must be between 0.0 - 100.0
}
/**
 * @generated from protobuf message mavsdk.rpc.camera.FocusRangeResponse
 */
export interface FocusRangeResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult camera_result = 1;
     */
    cameraResult?: CameraResult;
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.camera.CameraResult
 */
export interface CameraResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.CameraResult.Result result = 1;
     */
    result: CameraResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for camera commands
 *
 * @generated from protobuf enum mavsdk.rpc.camera.CameraResult.Result
 */
export enum CameraResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Command executed successfully
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Command in progress
     *
     * @generated from protobuf enum value: RESULT_IN_PROGRESS = 2;
     */
    IN_PROGRESS = 2,
    /**
     * Camera is busy and rejected command
     *
     * @generated from protobuf enum value: RESULT_BUSY = 3;
     */
    BUSY = 3,
    /**
     * Camera denied the command
     *
     * @generated from protobuf enum value: RESULT_DENIED = 4;
     */
    DENIED = 4,
    /**
     * An error has occurred while executing the command
     *
     * @generated from protobuf enum value: RESULT_ERROR = 5;
     */
    ERROR = 5,
    /**
     * Command timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * Command has wrong argument(s)
     *
     * @generated from protobuf enum value: RESULT_WRONG_ARGUMENT = 7;
     */
    WRONG_ARGUMENT = 7,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 8;
     */
    NO_SYSTEM = 8,
    /**
     * Definition file protocol not supported
     *
     * @generated from protobuf enum value: RESULT_PROTOCOL_UNSUPPORTED = 9;
     */
    PROTOCOL_UNSUPPORTED = 9
}
/**
 * Position type in global coordinates.
 *
 * @generated from protobuf message mavsdk.rpc.camera.Position
 */
export interface Position {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Latitude in degrees (range: -90 to +90)
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Longitude in degrees (range: -180 to +180)
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Altitude AMSL (above mean sea level) in metres
    /**
     * @generated from protobuf field: float relative_altitude_m = 4;
     */
    relativeAltitudeM: number; // Altitude relative to takeoff altitude in metres
}
/**
 *
 * Quaternion type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Hamilton quaternion product definition is used.
 * A zero-rotation quaternion is represented by (1,0,0,0).
 * The quaternion could also be written as w + xi + yj + zk.
 *
 * For more info see: https://en.wikipedia.org/wiki/Quaternion
 *
 * @generated from protobuf message mavsdk.rpc.camera.Quaternion
 */
export interface Quaternion {
    /**
     * @generated from protobuf field: float w = 1;
     */
    w: number; // Quaternion entry 0, also denoted as a
    /**
     * @generated from protobuf field: float x = 2;
     */
    x: number; // Quaternion entry 1, also denoted as b
    /**
     * @generated from protobuf field: float y = 3;
     */
    y: number; // Quaternion entry 2, also denoted as c
    /**
     * @generated from protobuf field: float z = 4;
     */
    z: number; // Quaternion entry 3, also denoted as d
}
/**
 *
 * Euler angle type.
 *
 * All rotations and axis systems follow the right-hand rule.
 * The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
 *
 * For more info see https://en.wikipedia.org/wiki/Euler_angles
 *
 * @generated from protobuf message mavsdk.rpc.camera.EulerAngle
 */
export interface EulerAngle {
    /**
     * @generated from protobuf field: float roll_deg = 1;
     */
    rollDeg: number; // Roll angle in degrees, positive is banking to the right
    /**
     * @generated from protobuf field: float pitch_deg = 2;
     */
    pitchDeg: number; // Pitch angle in degrees, positive is pitching nose up
    /**
     * @generated from protobuf field: float yaw_deg = 3;
     */
    yawDeg: number; // Yaw angle in degrees, positive is clock-wise seen from above
}
/**
 * Information about a picture just captured.
 *
 * @generated from protobuf message mavsdk.rpc.camera.CaptureInfo
 */
export interface CaptureInfo {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Position position = 1;
     */
    position?: Position; // Location where the picture was taken
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Quaternion attitude_quaternion = 2;
     */
    attitudeQuaternion?: Quaternion; // Attitude of the camera when the picture was taken (quaternion)
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.EulerAngle attitude_euler_angle = 3;
     */
    attitudeEulerAngle?: EulerAngle; // Attitude of the camera when the picture was taken (euler angle)
    /**
     * @generated from protobuf field: uint64 time_utc_us = 4;
     */
    timeUtcUs: bigint; // Timestamp in UTC (since UNIX epoch) in microseconds
    /**
     * @generated from protobuf field: bool is_success = 5;
     */
    isSuccess: boolean; // True if the capture was successful
    /**
     * @generated from protobuf field: int32 index = 6;
     */
    index: number; // Zero-based index of this image since vehicle was armed
    /**
     * @generated from protobuf field: string file_url = 7;
     */
    fileUrl: string; // Download URL of this image
}
/**
 * Type for video stream settings.
 *
 * @generated from protobuf message mavsdk.rpc.camera.VideoStreamSettings
 */
export interface VideoStreamSettings {
    /**
     * @generated from protobuf field: float frame_rate_hz = 1;
     */
    frameRateHz: number; // Frames per second
    /**
     * @generated from protobuf field: uint32 horizontal_resolution_pix = 2;
     */
    horizontalResolutionPix: number; // Horizontal resolution (in pixels)
    /**
     * @generated from protobuf field: uint32 vertical_resolution_pix = 3;
     */
    verticalResolutionPix: number; // Vertical resolution (in pixels)
    /**
     * @generated from protobuf field: uint32 bit_rate_b_s = 4;
     */
    bitRateBS: number; // Bit rate (in bits per second)
    /**
     * @generated from protobuf field: uint32 rotation_deg = 5;
     */
    rotationDeg: number; // Video image rotation (clockwise, 0-359 degrees)
    /**
     * @generated from protobuf field: string uri = 6;
     */
    uri: string; // Video stream URI
    /**
     * @generated from protobuf field: float horizontal_fov_deg = 7;
     */
    horizontalFovDeg: number; // Horizontal fov in degrees
}
/**
 * Information about the video stream.
 *
 * @generated from protobuf message mavsdk.rpc.camera.VideoStreamInfo
 */
export interface VideoStreamInfo {
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.VideoStreamSettings settings = 1;
     */
    settings?: VideoStreamSettings; // Video stream settings
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus status = 2;
     */
    status: VideoStreamInfo_VideoStreamStatus; // Current status of video streaming
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum spectrum = 3;
     */
    spectrum: VideoStreamInfo_VideoStreamSpectrum; // Light-spectrum of the video stream
}
/**
 * Video stream status type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus
 */
export enum VideoStreamInfo_VideoStreamStatus {
    /**
     * Video stream is not running
     *
     * @generated from protobuf enum value: VIDEO_STREAM_STATUS_NOT_RUNNING = 0;
     */
    NOT_RUNNING = 0,
    /**
     * Video stream is running
     *
     * @generated from protobuf enum value: VIDEO_STREAM_STATUS_IN_PROGRESS = 1;
     */
    IN_PROGRESS = 1
}
/**
 * Video stream light spectrum type
 *
 * @generated from protobuf enum mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum
 */
export enum VideoStreamInfo_VideoStreamSpectrum {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: VIDEO_STREAM_SPECTRUM_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Visible light
     *
     * @generated from protobuf enum value: VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT = 1;
     */
    VISIBLE_LIGHT = 1,
    /**
     * Infrared
     *
     * @generated from protobuf enum value: VIDEO_STREAM_SPECTRUM_INFRARED = 2;
     */
    INFRARED = 2
}
/**
 * Information about the camera status.
 *
 * @generated from protobuf message mavsdk.rpc.camera.Status
 */
export interface Status {
    /**
     * @generated from protobuf field: bool video_on = 1;
     */
    videoOn: boolean; // Whether video recording is currently in process
    /**
     * @generated from protobuf field: bool photo_interval_on = 2;
     */
    photoIntervalOn: boolean; // Whether a photo interval is currently in process
    /**
     * @generated from protobuf field: float used_storage_mib = 3;
     */
    usedStorageMib: number; // Used storage (in MiB)
    /**
     * @generated from protobuf field: float available_storage_mib = 4;
     */
    availableStorageMib: number; // Available storage (in MiB)
    /**
     * @generated from protobuf field: float total_storage_mib = 5;
     */
    totalStorageMib: number; // Total storage (in MiB)
    /**
     * @generated from protobuf field: float recording_time_s = 6;
     */
    recordingTimeS: number; // Elapsed time since starting the video recording (in seconds)
    /**
     * @generated from protobuf field: string media_folder_name = 7;
     */
    mediaFolderName: string; // Current folder name where media are saved
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Status.StorageStatus storage_status = 8;
     */
    storageStatus: Status_StorageStatus; // Storage status
    /**
     * @generated from protobuf field: uint32 storage_id = 9;
     */
    storageId: number; // Storage ID starting at 1
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Status.StorageType storage_type = 10;
     */
    storageType: Status_StorageType; // Storage type
}
/**
 * Storage status type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera.Status.StorageStatus
 */
export enum Status_StorageStatus {
    /**
     * Status not available
     *
     * @generated from protobuf enum value: STORAGE_STATUS_NOT_AVAILABLE = 0;
     */
    NOT_AVAILABLE = 0,
    /**
     * Storage is not formatted (i.e. has no recognized file system)
     *
     * @generated from protobuf enum value: STORAGE_STATUS_UNFORMATTED = 1;
     */
    UNFORMATTED = 1,
    /**
     * Storage is formatted (i.e. has recognized a file system)
     *
     * @generated from protobuf enum value: STORAGE_STATUS_FORMATTED = 2;
     */
    FORMATTED = 2,
    /**
     * Storage status is not supported
     *
     * @generated from protobuf enum value: STORAGE_STATUS_NOT_SUPPORTED = 3;
     */
    NOT_SUPPORTED = 3
}
/**
 * Storage type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera.Status.StorageType
 */
export enum Status_StorageType {
    /**
     * Storage type unknown
     *
     * @generated from protobuf enum value: STORAGE_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Storage type USB stick
     *
     * @generated from protobuf enum value: STORAGE_TYPE_USB_STICK = 1;
     */
    USB_STICK = 1,
    /**
     * Storage type SD card
     *
     * @generated from protobuf enum value: STORAGE_TYPE_SD = 2;
     */
    SD = 2,
    /**
     * Storage type MicroSD card
     *
     * @generated from protobuf enum value: STORAGE_TYPE_MICROSD = 3;
     */
    MICROSD = 3,
    /**
     * Storage type HD mass storage
     *
     * @generated from protobuf enum value: STORAGE_TYPE_HD = 7;
     */
    HD = 7,
    /**
     * Storage type other, not listed
     *
     * @generated from protobuf enum value: STORAGE_TYPE_OTHER = 254;
     */
    OTHER = 254
}
/**
 * Type to represent a setting option.
 *
 * @generated from protobuf message mavsdk.rpc.camera.Option
 */
export interface Option {
    /**
     * @generated from protobuf field: string option_id = 1;
     */
    optionId: string; // Name of the option (machine readable)
    /**
     * @generated from protobuf field: string option_description = 2;
     */
    optionDescription: string; // Description of the option (human readable)
}
/**
 * Type to represent a setting with a selected option.
 *
 * @generated from protobuf message mavsdk.rpc.camera.Setting
 */
export interface Setting {
    /**
     * @generated from protobuf field: string setting_id = 1;
     */
    settingId: string; // Name of a setting (machine readable)
    /**
     * @generated from protobuf field: string setting_description = 2;
     */
    settingDescription: string; // Description of the setting (human readable). This field is meant to be read from the drone, ignore it when setting.
    /**
     * @generated from protobuf field: mavsdk.rpc.camera.Option option = 3;
     */
    option?: Option; // Selected option
    /**
     * @generated from protobuf field: bool is_range = 4;
     */
    isRange: boolean; // If option is given as a range. This field is meant to be read from the drone, ignore it when setting.
}
/**
 * Type to represent a setting with a list of options to choose from.
 *
 * @generated from protobuf message mavsdk.rpc.camera.SettingOptions
 */
export interface SettingOptions {
    /**
     * @generated from protobuf field: string setting_id = 1;
     */
    settingId: string; // Name of the setting (machine readable)
    /**
     * @generated from protobuf field: string setting_description = 2;
     */
    settingDescription: string; // Description of the setting (human readable)
    /**
     * @generated from protobuf field: repeated mavsdk.rpc.camera.Option options = 3;
     */
    options: Option[]; // List of options or if range [min, max] or [min, max, interval]
    /**
     * @generated from protobuf field: bool is_range = 4;
     */
    isRange: boolean; // If option is given as a range
}
/**
 * Type to represent a camera information.
 *
 * @generated from protobuf message mavsdk.rpc.camera.Information
 */
export interface Information {
    /**
     * @generated from protobuf field: string vendor_name = 1;
     */
    vendorName: string; // Name of the camera vendor
    /**
     * @generated from protobuf field: string model_name = 2;
     */
    modelName: string; // Name of the camera model
    /**
     * @generated from protobuf field: float focal_length_mm = 3;
     */
    focalLengthMm: number; // Focal length
    /**
     * @generated from protobuf field: float horizontal_sensor_size_mm = 4;
     */
    horizontalSensorSizeMm: number; // Horizontal sensor size
    /**
     * @generated from protobuf field: float vertical_sensor_size_mm = 5;
     */
    verticalSensorSizeMm: number; // Vertical sensor size
    /**
     * @generated from protobuf field: uint32 horizontal_resolution_px = 6;
     */
    horizontalResolutionPx: number; // Horizontal image resolution in pixels
    /**
     * @generated from protobuf field: uint32 vertical_resolution_px = 7;
     */
    verticalResolutionPx: number; // Vertical image resolution in pixels
}
/**
 * Camera mode type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera.Mode
 */
export enum Mode {
    /**
     * Unknown
     *
     * @generated from protobuf enum value: MODE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Photo mode
     *
     * @generated from protobuf enum value: MODE_PHOTO = 1;
     */
    PHOTO = 1,
    /**
     * Video mode
     *
     * @generated from protobuf enum value: MODE_VIDEO = 2;
     */
    VIDEO = 2
}
/**
 * Photos range type.
 *
 * @generated from protobuf enum mavsdk.rpc.camera.PhotosRange
 */
export enum PhotosRange {
    /**
     * All the photos present on the camera
     *
     * @generated from protobuf enum value: PHOTOS_RANGE_ALL = 0;
     */
    ALL = 0,
    /**
     * Photos taken since MAVSDK got connected
     *
     * @generated from protobuf enum value: PHOTOS_RANGE_SINCE_CONNECTION = 1;
     */
    SINCE_CONNECTION = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class PrepareRequest$Type extends MessageType<PrepareRequest> {
    constructor() {
        super("mavsdk.rpc.camera.PrepareRequest", []);
    }
    create(value?: PartialMessage<PrepareRequest>): PrepareRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PrepareRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareRequest): PrepareRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PrepareRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.PrepareRequest
 */
export const PrepareRequest = new PrepareRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareResponse$Type extends MessageType<PrepareResponse> {
    constructor() {
        super("mavsdk.rpc.camera.PrepareResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<PrepareResponse>): PrepareResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PrepareResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareResponse): PrepareResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.PrepareResponse
 */
export const PrepareResponse = new PrepareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakePhotoRequest$Type extends MessageType<TakePhotoRequest> {
    constructor() {
        super("mavsdk.rpc.camera.TakePhotoRequest", []);
    }
    create(value?: PartialMessage<TakePhotoRequest>): TakePhotoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TakePhotoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakePhotoRequest): TakePhotoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TakePhotoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TakePhotoRequest
 */
export const TakePhotoRequest = new TakePhotoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakePhotoResponse$Type extends MessageType<TakePhotoResponse> {
    constructor() {
        super("mavsdk.rpc.camera.TakePhotoResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<TakePhotoResponse>): TakePhotoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TakePhotoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakePhotoResponse): TakePhotoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakePhotoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TakePhotoResponse
 */
export const TakePhotoResponse = new TakePhotoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartPhotoIntervalRequest$Type extends MessageType<StartPhotoIntervalRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StartPhotoIntervalRequest", [
            { no: 1, name: "interval_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<StartPhotoIntervalRequest>): StartPhotoIntervalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.intervalS = 0;
        if (value !== undefined)
            reflectionMergePartial<StartPhotoIntervalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartPhotoIntervalRequest): StartPhotoIntervalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float interval_s */ 1:
                    message.intervalS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartPhotoIntervalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float interval_s = 1; */
        if (message.intervalS !== 0)
            writer.tag(1, WireType.Bit32).float(message.intervalS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartPhotoIntervalRequest
 */
export const StartPhotoIntervalRequest = new StartPhotoIntervalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartPhotoIntervalResponse$Type extends MessageType<StartPhotoIntervalResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StartPhotoIntervalResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StartPhotoIntervalResponse>): StartPhotoIntervalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartPhotoIntervalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartPhotoIntervalResponse): StartPhotoIntervalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartPhotoIntervalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartPhotoIntervalResponse
 */
export const StartPhotoIntervalResponse = new StartPhotoIntervalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopPhotoIntervalRequest$Type extends MessageType<StopPhotoIntervalRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StopPhotoIntervalRequest", []);
    }
    create(value?: PartialMessage<StopPhotoIntervalRequest>): StopPhotoIntervalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopPhotoIntervalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopPhotoIntervalRequest): StopPhotoIntervalRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StopPhotoIntervalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopPhotoIntervalRequest
 */
export const StopPhotoIntervalRequest = new StopPhotoIntervalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopPhotoIntervalResponse$Type extends MessageType<StopPhotoIntervalResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StopPhotoIntervalResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StopPhotoIntervalResponse>): StopPhotoIntervalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopPhotoIntervalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopPhotoIntervalResponse): StopPhotoIntervalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopPhotoIntervalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopPhotoIntervalResponse
 */
export const StopPhotoIntervalResponse = new StopPhotoIntervalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoRequest$Type extends MessageType<StartVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StartVideoRequest", []);
    }
    create(value?: PartialMessage<StartVideoRequest>): StartVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoRequest): StartVideoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StartVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartVideoRequest
 */
export const StartVideoRequest = new StartVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoResponse$Type extends MessageType<StartVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StartVideoResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StartVideoResponse>): StartVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoResponse): StartVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartVideoResponse
 */
export const StartVideoResponse = new StartVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoRequest$Type extends MessageType<StopVideoRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StopVideoRequest", []);
    }
    create(value?: PartialMessage<StopVideoRequest>): StopVideoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopVideoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoRequest): StopVideoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StopVideoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopVideoRequest
 */
export const StopVideoRequest = new StopVideoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoResponse$Type extends MessageType<StopVideoResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StopVideoResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StopVideoResponse>): StopVideoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopVideoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoResponse): StopVideoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopVideoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopVideoResponse
 */
export const StopVideoResponse = new StopVideoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoStreamingRequest$Type extends MessageType<StartVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StartVideoStreamingRequest", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartVideoStreamingRequest>): StartVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StartVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoStreamingRequest): StartVideoStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartVideoStreamingRequest
 */
export const StartVideoStreamingRequest = new StartVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartVideoStreamingResponse$Type extends MessageType<StartVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StartVideoStreamingResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StartVideoStreamingResponse>): StartVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartVideoStreamingResponse): StartVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StartVideoStreamingResponse
 */
export const StartVideoStreamingResponse = new StartVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoStreamingRequest$Type extends MessageType<StopVideoStreamingRequest> {
    constructor() {
        super("mavsdk.rpc.camera.StopVideoStreamingRequest", [
            { no: 1, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopVideoStreamingRequest>): StopVideoStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        if (value !== undefined)
            reflectionMergePartial<StopVideoStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoStreamingRequest): StopVideoStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 1:
                    message.streamId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopVideoStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 1; */
        if (message.streamId !== 0)
            writer.tag(1, WireType.Varint).int32(message.streamId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopVideoStreamingRequest
 */
export const StopVideoStreamingRequest = new StopVideoStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopVideoStreamingResponse$Type extends MessageType<StopVideoStreamingResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StopVideoStreamingResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<StopVideoStreamingResponse>): StopVideoStreamingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopVideoStreamingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopVideoStreamingResponse): StopVideoStreamingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopVideoStreamingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StopVideoStreamingResponse
 */
export const StopVideoStreamingResponse = new StopVideoStreamingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetModeRequest$Type extends MessageType<SetModeRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SetModeRequest", [
            { no: 1, name: "mode", kind: "enum", T: () => ["mavsdk.rpc.camera.Mode", Mode, "MODE_"] }
        ]);
    }
    create(value?: PartialMessage<SetModeRequest>): SetModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<SetModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetModeRequest): SetModeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Mode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Mode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SetModeRequest
 */
export const SetModeRequest = new SetModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetModeResponse$Type extends MessageType<SetModeResponse> {
    constructor() {
        super("mavsdk.rpc.camera.SetModeResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<SetModeResponse>): SetModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetModeResponse): SetModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SetModeResponse
 */
export const SetModeResponse = new SetModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPhotosRequest$Type extends MessageType<ListPhotosRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ListPhotosRequest", [
            { no: 1, name: "photos_range", kind: "enum", T: () => ["mavsdk.rpc.camera.PhotosRange", PhotosRange, "PHOTOS_RANGE_"] }
        ]);
    }
    create(value?: PartialMessage<ListPhotosRequest>): ListPhotosRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.photosRange = 0;
        if (value !== undefined)
            reflectionMergePartial<ListPhotosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPhotosRequest): ListPhotosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.PhotosRange photos_range */ 1:
                    message.photosRange = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPhotosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.PhotosRange photos_range = 1; */
        if (message.photosRange !== 0)
            writer.tag(1, WireType.Varint).int32(message.photosRange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ListPhotosRequest
 */
export const ListPhotosRequest = new ListPhotosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListPhotosResponse$Type extends MessageType<ListPhotosResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ListPhotosResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult },
            { no: 2, name: "capture_infos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CaptureInfo }
        ]);
    }
    create(value?: PartialMessage<ListPhotosResponse>): ListPhotosResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.captureInfos = [];
        if (value !== undefined)
            reflectionMergePartial<ListPhotosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPhotosResponse): ListPhotosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                case /* repeated mavsdk.rpc.camera.CaptureInfo capture_infos */ 2:
                    message.captureInfos.push(CaptureInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListPhotosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated mavsdk.rpc.camera.CaptureInfo capture_infos = 2; */
        for (let i = 0; i < message.captureInfos.length; i++)
            CaptureInfo.internalBinaryWrite(message.captureInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ListPhotosResponse
 */
export const ListPhotosResponse = new ListPhotosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeInformationRequest$Type extends MessageType<SubscribeInformationRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeInformationRequest", []);
    }
    create(value?: PartialMessage<SubscribeInformationRequest>): SubscribeInformationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeInformationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeInformationRequest): SubscribeInformationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeInformationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeInformationRequest
 */
export const SubscribeInformationRequest = new SubscribeInformationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InformationResponse$Type extends MessageType<InformationResponse> {
    constructor() {
        super("mavsdk.rpc.camera.InformationResponse", [
            { no: 1, name: "information", kind: "message", T: () => Information }
        ]);
    }
    create(value?: PartialMessage<InformationResponse>): InformationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<InformationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InformationResponse): InformationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Information information */ 1:
                    message.information = Information.internalBinaryRead(reader, reader.uint32(), options, message.information);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InformationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Information information = 1; */
        if (message.information)
            Information.internalBinaryWrite(message.information, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.InformationResponse
 */
export const InformationResponse = new InformationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeModeRequest$Type extends MessageType<SubscribeModeRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeModeRequest", []);
    }
    create(value?: PartialMessage<SubscribeModeRequest>): SubscribeModeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeModeRequest): SubscribeModeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeModeRequest
 */
export const SubscribeModeRequest = new SubscribeModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModeResponse$Type extends MessageType<ModeResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ModeResponse", [
            { no: 1, name: "mode", kind: "enum", T: () => ["mavsdk.rpc.camera.Mode", Mode, "MODE_"] }
        ]);
    }
    create(value?: PartialMessage<ModeResponse>): ModeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<ModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModeResponse): ModeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Mode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Mode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ModeResponse
 */
export const ModeResponse = new ModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeVideoStreamInfoRequest$Type extends MessageType<SubscribeVideoStreamInfoRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest", []);
    }
    create(value?: PartialMessage<SubscribeVideoStreamInfoRequest>): SubscribeVideoStreamInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeVideoStreamInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeVideoStreamInfoRequest): SubscribeVideoStreamInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeVideoStreamInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest
 */
export const SubscribeVideoStreamInfoRequest = new SubscribeVideoStreamInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreamInfoResponse$Type extends MessageType<VideoStreamInfoResponse> {
    constructor() {
        super("mavsdk.rpc.camera.VideoStreamInfoResponse", [
            { no: 1, name: "video_stream_info", kind: "message", T: () => VideoStreamInfo }
        ]);
    }
    create(value?: PartialMessage<VideoStreamInfoResponse>): VideoStreamInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VideoStreamInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreamInfoResponse): VideoStreamInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.VideoStreamInfo video_stream_info */ 1:
                    message.videoStreamInfo = VideoStreamInfo.internalBinaryRead(reader, reader.uint32(), options, message.videoStreamInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreamInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.VideoStreamInfo video_stream_info = 1; */
        if (message.videoStreamInfo)
            VideoStreamInfo.internalBinaryWrite(message.videoStreamInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.VideoStreamInfoResponse
 */
export const VideoStreamInfoResponse = new VideoStreamInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCaptureInfoRequest$Type extends MessageType<SubscribeCaptureInfoRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeCaptureInfoRequest", []);
    }
    create(value?: PartialMessage<SubscribeCaptureInfoRequest>): SubscribeCaptureInfoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeCaptureInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCaptureInfoRequest): SubscribeCaptureInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeCaptureInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeCaptureInfoRequest
 */
export const SubscribeCaptureInfoRequest = new SubscribeCaptureInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureInfoResponse$Type extends MessageType<CaptureInfoResponse> {
    constructor() {
        super("mavsdk.rpc.camera.CaptureInfoResponse", [
            { no: 1, name: "capture_info", kind: "message", T: () => CaptureInfo }
        ]);
    }
    create(value?: PartialMessage<CaptureInfoResponse>): CaptureInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CaptureInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureInfoResponse): CaptureInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CaptureInfo capture_info */ 1:
                    message.captureInfo = CaptureInfo.internalBinaryRead(reader, reader.uint32(), options, message.captureInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CaptureInfo capture_info = 1; */
        if (message.captureInfo)
            CaptureInfo.internalBinaryWrite(message.captureInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.CaptureInfoResponse
 */
export const CaptureInfoResponse = new CaptureInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeStatusRequest$Type extends MessageType<SubscribeStatusRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeStatusRequest", []);
    }
    create(value?: PartialMessage<SubscribeStatusRequest>): SubscribeStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeStatusRequest): SubscribeStatusRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeStatusRequest
 */
export const SubscribeStatusRequest = new SubscribeStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusResponse$Type extends MessageType<StatusResponse> {
    constructor() {
        super("mavsdk.rpc.camera.StatusResponse", [
            { no: 1, name: "camera_status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StatusResponse>): StatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusResponse): StatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Status camera_status */ 1:
                    message.cameraStatus = Status.internalBinaryRead(reader, reader.uint32(), options, message.cameraStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Status camera_status = 1; */
        if (message.cameraStatus)
            Status.internalBinaryWrite(message.cameraStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.StatusResponse
 */
export const StatusResponse = new StatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeCurrentSettingsRequest$Type extends MessageType<SubscribeCurrentSettingsRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribeCurrentSettingsRequest", []);
    }
    create(value?: PartialMessage<SubscribeCurrentSettingsRequest>): SubscribeCurrentSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeCurrentSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeCurrentSettingsRequest): SubscribeCurrentSettingsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeCurrentSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribeCurrentSettingsRequest
 */
export const SubscribeCurrentSettingsRequest = new SubscribeCurrentSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentSettingsResponse$Type extends MessageType<CurrentSettingsResponse> {
    constructor() {
        super("mavsdk.rpc.camera.CurrentSettingsResponse", [
            { no: 1, name: "current_settings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Setting }
        ]);
    }
    create(value?: PartialMessage<CurrentSettingsResponse>): CurrentSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentSettings = [];
        if (value !== undefined)
            reflectionMergePartial<CurrentSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentSettingsResponse): CurrentSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mavsdk.rpc.camera.Setting current_settings */ 1:
                    message.currentSettings.push(Setting.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mavsdk.rpc.camera.Setting current_settings = 1; */
        for (let i = 0; i < message.currentSettings.length; i++)
            Setting.internalBinaryWrite(message.currentSettings[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.CurrentSettingsResponse
 */
export const CurrentSettingsResponse = new CurrentSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribePossibleSettingOptionsRequest$Type extends MessageType<SubscribePossibleSettingOptionsRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest", []);
    }
    create(value?: PartialMessage<SubscribePossibleSettingOptionsRequest>): SubscribePossibleSettingOptionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribePossibleSettingOptionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribePossibleSettingOptionsRequest): SubscribePossibleSettingOptionsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribePossibleSettingOptionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest
 */
export const SubscribePossibleSettingOptionsRequest = new SubscribePossibleSettingOptionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PossibleSettingOptionsResponse$Type extends MessageType<PossibleSettingOptionsResponse> {
    constructor() {
        super("mavsdk.rpc.camera.PossibleSettingOptionsResponse", [
            { no: 1, name: "setting_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SettingOptions }
        ]);
    }
    create(value?: PartialMessage<PossibleSettingOptionsResponse>): PossibleSettingOptionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settingOptions = [];
        if (value !== undefined)
            reflectionMergePartial<PossibleSettingOptionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PossibleSettingOptionsResponse): PossibleSettingOptionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated mavsdk.rpc.camera.SettingOptions setting_options */ 1:
                    message.settingOptions.push(SettingOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PossibleSettingOptionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated mavsdk.rpc.camera.SettingOptions setting_options = 1; */
        for (let i = 0; i < message.settingOptions.length; i++)
            SettingOptions.internalBinaryWrite(message.settingOptions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.PossibleSettingOptionsResponse
 */
export const PossibleSettingOptionsResponse = new PossibleSettingOptionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSettingRequest$Type extends MessageType<SetSettingRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SetSettingRequest", [
            { no: 1, name: "setting", kind: "message", T: () => Setting }
        ]);
    }
    create(value?: PartialMessage<SetSettingRequest>): SetSettingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSettingRequest): SetSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Setting setting */ 1:
                    message.setting = Setting.internalBinaryRead(reader, reader.uint32(), options, message.setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Setting setting = 1; */
        if (message.setting)
            Setting.internalBinaryWrite(message.setting, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SetSettingRequest
 */
export const SetSettingRequest = new SetSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSettingResponse$Type extends MessageType<SetSettingResponse> {
    constructor() {
        super("mavsdk.rpc.camera.SetSettingResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<SetSettingResponse>): SetSettingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSettingResponse): SetSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SetSettingResponse
 */
export const SetSettingResponse = new SetSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSettingRequest$Type extends MessageType<GetSettingRequest> {
    constructor() {
        super("mavsdk.rpc.camera.GetSettingRequest", [
            { no: 1, name: "setting", kind: "message", T: () => Setting }
        ]);
    }
    create(value?: PartialMessage<GetSettingRequest>): GetSettingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSettingRequest): GetSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Setting setting */ 1:
                    message.setting = Setting.internalBinaryRead(reader, reader.uint32(), options, message.setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Setting setting = 1; */
        if (message.setting)
            Setting.internalBinaryWrite(message.setting, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.GetSettingRequest
 */
export const GetSettingRequest = new GetSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSettingResponse$Type extends MessageType<GetSettingResponse> {
    constructor() {
        super("mavsdk.rpc.camera.GetSettingResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult },
            { no: 2, name: "setting", kind: "message", T: () => Setting }
        ]);
    }
    create(value?: PartialMessage<GetSettingResponse>): GetSettingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSettingResponse): GetSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                case /* mavsdk.rpc.camera.Setting setting */ 2:
                    message.setting = Setting.internalBinaryRead(reader, reader.uint32(), options, message.setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.camera.Setting setting = 2; */
        if (message.setting)
            Setting.internalBinaryWrite(message.setting, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.GetSettingResponse
 */
export const GetSettingResponse = new GetSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormatStorageRequest$Type extends MessageType<FormatStorageRequest> {
    constructor() {
        super("mavsdk.rpc.camera.FormatStorageRequest", [
            { no: 1, name: "storage_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FormatStorageRequest>): FormatStorageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.storageId = 0;
        if (value !== undefined)
            reflectionMergePartial<FormatStorageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormatStorageRequest): FormatStorageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 storage_id */ 1:
                    message.storageId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormatStorageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 storage_id = 1; */
        if (message.storageId !== 0)
            writer.tag(1, WireType.Varint).int32(message.storageId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FormatStorageRequest
 */
export const FormatStorageRequest = new FormatStorageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormatStorageResponse$Type extends MessageType<FormatStorageResponse> {
    constructor() {
        super("mavsdk.rpc.camera.FormatStorageResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<FormatStorageResponse>): FormatStorageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FormatStorageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormatStorageResponse): FormatStorageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormatStorageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FormatStorageResponse
 */
export const FormatStorageResponse = new FormatStorageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectCameraResponse$Type extends MessageType<SelectCameraResponse> {
    constructor() {
        super("mavsdk.rpc.camera.SelectCameraResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<SelectCameraResponse>): SelectCameraResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SelectCameraResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectCameraResponse): SelectCameraResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectCameraResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SelectCameraResponse
 */
export const SelectCameraResponse = new SelectCameraResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectCameraRequest$Type extends MessageType<SelectCameraRequest> {
    constructor() {
        super("mavsdk.rpc.camera.SelectCameraRequest", [
            { no: 1, name: "camera_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SelectCameraRequest>): SelectCameraRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cameraId = 0;
        if (value !== undefined)
            reflectionMergePartial<SelectCameraRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectCameraRequest): SelectCameraRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 camera_id */ 1:
                    message.cameraId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectCameraRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 camera_id = 1; */
        if (message.cameraId !== 0)
            writer.tag(1, WireType.Varint).int32(message.cameraId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SelectCameraRequest
 */
export const SelectCameraRequest = new SelectCameraRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetSettingsRequest$Type extends MessageType<ResetSettingsRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ResetSettingsRequest", []);
    }
    create(value?: PartialMessage<ResetSettingsRequest>): ResetSettingsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResetSettingsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetSettingsRequest): ResetSettingsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResetSettingsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ResetSettingsRequest
 */
export const ResetSettingsRequest = new ResetSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetSettingsResponse$Type extends MessageType<ResetSettingsResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ResetSettingsResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<ResetSettingsResponse>): ResetSettingsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResetSettingsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetSettingsResponse): ResetSettingsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetSettingsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ResetSettingsResponse
 */
export const ResetSettingsResponse = new ResetSettingsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomInStartRequest$Type extends MessageType<ZoomInStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomInStartRequest", []);
    }
    create(value?: PartialMessage<ZoomInStartRequest>): ZoomInStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomInStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomInStartRequest): ZoomInStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ZoomInStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomInStartRequest
 */
export const ZoomInStartRequest = new ZoomInStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomInStartResponse$Type extends MessageType<ZoomInStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomInStartResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<ZoomInStartResponse>): ZoomInStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomInStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomInStartResponse): ZoomInStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomInStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomInStartResponse
 */
export const ZoomInStartResponse = new ZoomInStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomOutStartRequest$Type extends MessageType<ZoomOutStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomOutStartRequest", []);
    }
    create(value?: PartialMessage<ZoomOutStartRequest>): ZoomOutStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomOutStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomOutStartRequest): ZoomOutStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ZoomOutStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomOutStartRequest
 */
export const ZoomOutStartRequest = new ZoomOutStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomOutStartResponse$Type extends MessageType<ZoomOutStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomOutStartResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<ZoomOutStartResponse>): ZoomOutStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomOutStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomOutStartResponse): ZoomOutStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomOutStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomOutStartResponse
 */
export const ZoomOutStartResponse = new ZoomOutStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomStopRequest$Type extends MessageType<ZoomStopRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomStopRequest", []);
    }
    create(value?: PartialMessage<ZoomStopRequest>): ZoomStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomStopRequest): ZoomStopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ZoomStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomStopRequest
 */
export const ZoomStopRequest = new ZoomStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomStopResponse$Type extends MessageType<ZoomStopResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomStopResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<ZoomStopResponse>): ZoomStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomStopResponse): ZoomStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomStopResponse
 */
export const ZoomStopResponse = new ZoomStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomRangeRequest$Type extends MessageType<ZoomRangeRequest> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomRangeRequest", [
            { no: 1, name: "range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ZoomRangeRequest>): ZoomRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.range = 0;
        if (value !== undefined)
            reflectionMergePartial<ZoomRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomRangeRequest): ZoomRangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float range */ 1:
                    message.range = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float range = 1; */
        if (message.range !== 0)
            writer.tag(1, WireType.Bit32).float(message.range);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomRangeRequest
 */
export const ZoomRangeRequest = new ZoomRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoomRangeResponse$Type extends MessageType<ZoomRangeResponse> {
    constructor() {
        super("mavsdk.rpc.camera.ZoomRangeResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<ZoomRangeResponse>): ZoomRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ZoomRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoomRangeResponse): ZoomRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoomRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.ZoomRangeResponse
 */
export const ZoomRangeResponse = new ZoomRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPointRequest$Type extends MessageType<TrackPointRequest> {
    constructor() {
        super("mavsdk.rpc.camera.TrackPointRequest", [
            { no: 1, name: "point_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "point_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "radius", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TrackPointRequest>): TrackPointRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pointX = 0;
        message.pointY = 0;
        message.radius = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackPointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPointRequest): TrackPointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float point_x */ 1:
                    message.pointX = reader.float();
                    break;
                case /* float point_y */ 2:
                    message.pointY = reader.float();
                    break;
                case /* float radius */ 3:
                    message.radius = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float point_x = 1; */
        if (message.pointX !== 0)
            writer.tag(1, WireType.Bit32).float(message.pointX);
        /* float point_y = 2; */
        if (message.pointY !== 0)
            writer.tag(2, WireType.Bit32).float(message.pointY);
        /* float radius = 3; */
        if (message.radius !== 0)
            writer.tag(3, WireType.Bit32).float(message.radius);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackPointRequest
 */
export const TrackPointRequest = new TrackPointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackPointResponse$Type extends MessageType<TrackPointResponse> {
    constructor() {
        super("mavsdk.rpc.camera.TrackPointResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<TrackPointResponse>): TrackPointResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackPointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackPointResponse): TrackPointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackPointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackPointResponse
 */
export const TrackPointResponse = new TrackPointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackRectangleRequest$Type extends MessageType<TrackRectangleRequest> {
    constructor() {
        super("mavsdk.rpc.camera.TrackRectangleRequest", [
            { no: 1, name: "top_left_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "top_left_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bottom_right_x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bottom_right_y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<TrackRectangleRequest>): TrackRectangleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.topLeftX = 0;
        message.topLeftY = 0;
        message.bottomRightX = 0;
        message.bottomRightY = 0;
        if (value !== undefined)
            reflectionMergePartial<TrackRectangleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackRectangleRequest): TrackRectangleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float top_left_x */ 1:
                    message.topLeftX = reader.float();
                    break;
                case /* float top_left_y */ 2:
                    message.topLeftY = reader.float();
                    break;
                case /* float bottom_right_x */ 3:
                    message.bottomRightX = reader.float();
                    break;
                case /* float bottom_right_y */ 4:
                    message.bottomRightY = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackRectangleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float top_left_x = 1; */
        if (message.topLeftX !== 0)
            writer.tag(1, WireType.Bit32).float(message.topLeftX);
        /* float top_left_y = 2; */
        if (message.topLeftY !== 0)
            writer.tag(2, WireType.Bit32).float(message.topLeftY);
        /* float bottom_right_x = 3; */
        if (message.bottomRightX !== 0)
            writer.tag(3, WireType.Bit32).float(message.bottomRightX);
        /* float bottom_right_y = 4; */
        if (message.bottomRightY !== 0)
            writer.tag(4, WireType.Bit32).float(message.bottomRightY);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackRectangleRequest
 */
export const TrackRectangleRequest = new TrackRectangleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackRectangleResponse$Type extends MessageType<TrackRectangleResponse> {
    constructor() {
        super("mavsdk.rpc.camera.TrackRectangleResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<TrackRectangleResponse>): TrackRectangleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackRectangleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackRectangleResponse): TrackRectangleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackRectangleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackRectangleResponse
 */
export const TrackRectangleResponse = new TrackRectangleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackStopRequest$Type extends MessageType<TrackStopRequest> {
    constructor() {
        super("mavsdk.rpc.camera.TrackStopRequest", []);
    }
    create(value?: PartialMessage<TrackStopRequest>): TrackStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackStopRequest): TrackStopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TrackStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackStopRequest
 */
export const TrackStopRequest = new TrackStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackStopResponse$Type extends MessageType<TrackStopResponse> {
    constructor() {
        super("mavsdk.rpc.camera.TrackStopResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<TrackStopResponse>): TrackStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrackStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrackStopResponse): TrackStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrackStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.TrackStopResponse
 */
export const TrackStopResponse = new TrackStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusInStartRequest$Type extends MessageType<FocusInStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera.FocusInStartRequest", []);
    }
    create(value?: PartialMessage<FocusInStartRequest>): FocusInStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusInStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusInStartRequest): FocusInStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FocusInStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusInStartRequest
 */
export const FocusInStartRequest = new FocusInStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusInStartResponse$Type extends MessageType<FocusInStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera.FocusInStartResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<FocusInStartResponse>): FocusInStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusInStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusInStartResponse): FocusInStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusInStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusInStartResponse
 */
export const FocusInStartResponse = new FocusInStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusOutStartRequest$Type extends MessageType<FocusOutStartRequest> {
    constructor() {
        super("mavsdk.rpc.camera.FocusOutStartRequest", []);
    }
    create(value?: PartialMessage<FocusOutStartRequest>): FocusOutStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusOutStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusOutStartRequest): FocusOutStartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FocusOutStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusOutStartRequest
 */
export const FocusOutStartRequest = new FocusOutStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusOutStartResponse$Type extends MessageType<FocusOutStartResponse> {
    constructor() {
        super("mavsdk.rpc.camera.FocusOutStartResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<FocusOutStartResponse>): FocusOutStartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusOutStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusOutStartResponse): FocusOutStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusOutStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusOutStartResponse
 */
export const FocusOutStartResponse = new FocusOutStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusStopRequest$Type extends MessageType<FocusStopRequest> {
    constructor() {
        super("mavsdk.rpc.camera.FocusStopRequest", []);
    }
    create(value?: PartialMessage<FocusStopRequest>): FocusStopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusStopRequest): FocusStopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FocusStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusStopRequest
 */
export const FocusStopRequest = new FocusStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusStopResponse$Type extends MessageType<FocusStopResponse> {
    constructor() {
        super("mavsdk.rpc.camera.FocusStopResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<FocusStopResponse>): FocusStopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusStopResponse): FocusStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusStopResponse
 */
export const FocusStopResponse = new FocusStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusRangeRequest$Type extends MessageType<FocusRangeRequest> {
    constructor() {
        super("mavsdk.rpc.camera.FocusRangeRequest", [
            { no: 1, name: "range", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FocusRangeRequest>): FocusRangeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.range = 0;
        if (value !== undefined)
            reflectionMergePartial<FocusRangeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusRangeRequest): FocusRangeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float range */ 1:
                    message.range = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusRangeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float range = 1; */
        if (message.range !== 0)
            writer.tag(1, WireType.Bit32).float(message.range);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusRangeRequest
 */
export const FocusRangeRequest = new FocusRangeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FocusRangeResponse$Type extends MessageType<FocusRangeResponse> {
    constructor() {
        super("mavsdk.rpc.camera.FocusRangeResponse", [
            { no: 1, name: "camera_result", kind: "message", T: () => CameraResult }
        ]);
    }
    create(value?: PartialMessage<FocusRangeResponse>): FocusRangeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FocusRangeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusRangeResponse): FocusRangeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult camera_result */ 1:
                    message.cameraResult = CameraResult.internalBinaryRead(reader, reader.uint32(), options, message.cameraResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusRangeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult camera_result = 1; */
        if (message.cameraResult)
            CameraResult.internalBinaryWrite(message.cameraResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.FocusRangeResponse
 */
export const FocusRangeResponse = new FocusRangeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CameraResult$Type extends MessageType<CameraResult> {
    constructor() {
        super("mavsdk.rpc.camera.CameraResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.camera.CameraResult.Result", CameraResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CameraResult>): CameraResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<CameraResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CameraResult): CameraResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.CameraResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CameraResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.CameraResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.CameraResult
 */
export const CameraResult = new CameraResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("mavsdk.rpc.camera.Position", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "relative_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.relativeAltitudeM = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float relative_altitude_m */ 4:
                    message.relativeAltitudeM = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float relative_altitude_m = 4; */
        if (message.relativeAltitudeM !== 0)
            writer.tag(4, WireType.Bit32).float(message.relativeAltitudeM);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Quaternion$Type extends MessageType<Quaternion> {
    constructor() {
        super("mavsdk.rpc.camera.Quaternion", [
            { no: 1, name: "w", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "z", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Quaternion>): Quaternion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.w = 0;
        message.x = 0;
        message.y = 0;
        message.z = 0;
        if (value !== undefined)
            reflectionMergePartial<Quaternion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Quaternion): Quaternion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float w */ 1:
                    message.w = reader.float();
                    break;
                case /* float x */ 2:
                    message.x = reader.float();
                    break;
                case /* float y */ 3:
                    message.y = reader.float();
                    break;
                case /* float z */ 4:
                    message.z = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Quaternion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float w = 1; */
        if (message.w !== 0)
            writer.tag(1, WireType.Bit32).float(message.w);
        /* float x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Bit32).float(message.x);
        /* float y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Bit32).float(message.y);
        /* float z = 4; */
        if (message.z !== 0)
            writer.tag(4, WireType.Bit32).float(message.z);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Quaternion
 */
export const Quaternion = new Quaternion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EulerAngle$Type extends MessageType<EulerAngle> {
    constructor() {
        super("mavsdk.rpc.camera.EulerAngle", [
            { no: 1, name: "roll_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "pitch_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "yaw_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EulerAngle>): EulerAngle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollDeg = 0;
        message.pitchDeg = 0;
        message.yawDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<EulerAngle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EulerAngle): EulerAngle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float roll_deg */ 1:
                    message.rollDeg = reader.float();
                    break;
                case /* float pitch_deg */ 2:
                    message.pitchDeg = reader.float();
                    break;
                case /* float yaw_deg */ 3:
                    message.yawDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EulerAngle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float roll_deg = 1; */
        if (message.rollDeg !== 0)
            writer.tag(1, WireType.Bit32).float(message.rollDeg);
        /* float pitch_deg = 2; */
        if (message.pitchDeg !== 0)
            writer.tag(2, WireType.Bit32).float(message.pitchDeg);
        /* float yaw_deg = 3; */
        if (message.yawDeg !== 0)
            writer.tag(3, WireType.Bit32).float(message.yawDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.EulerAngle
 */
export const EulerAngle = new EulerAngle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureInfo$Type extends MessageType<CaptureInfo> {
    constructor() {
        super("mavsdk.rpc.camera.CaptureInfo", [
            { no: 1, name: "position", kind: "message", T: () => Position },
            { no: 2, name: "attitude_quaternion", kind: "message", T: () => Quaternion },
            { no: 3, name: "attitude_euler_angle", kind: "message", T: () => EulerAngle },
            { no: 4, name: "time_utc_us", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "is_success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "file_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CaptureInfo>): CaptureInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.timeUtcUs = 0n;
        message.isSuccess = false;
        message.index = 0;
        message.fileUrl = "";
        if (value !== undefined)
            reflectionMergePartial<CaptureInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureInfo): CaptureInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.Position position */ 1:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* mavsdk.rpc.camera.Quaternion attitude_quaternion */ 2:
                    message.attitudeQuaternion = Quaternion.internalBinaryRead(reader, reader.uint32(), options, message.attitudeQuaternion);
                    break;
                case /* mavsdk.rpc.camera.EulerAngle attitude_euler_angle */ 3:
                    message.attitudeEulerAngle = EulerAngle.internalBinaryRead(reader, reader.uint32(), options, message.attitudeEulerAngle);
                    break;
                case /* uint64 time_utc_us */ 4:
                    message.timeUtcUs = reader.uint64().toBigInt();
                    break;
                case /* bool is_success */ 5:
                    message.isSuccess = reader.bool();
                    break;
                case /* int32 index */ 6:
                    message.index = reader.int32();
                    break;
                case /* string file_url */ 7:
                    message.fileUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.Position position = 1; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.camera.Quaternion attitude_quaternion = 2; */
        if (message.attitudeQuaternion)
            Quaternion.internalBinaryWrite(message.attitudeQuaternion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.camera.EulerAngle attitude_euler_angle = 3; */
        if (message.attitudeEulerAngle)
            EulerAngle.internalBinaryWrite(message.attitudeEulerAngle, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 time_utc_us = 4; */
        if (message.timeUtcUs !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.timeUtcUs);
        /* bool is_success = 5; */
        if (message.isSuccess !== false)
            writer.tag(5, WireType.Varint).bool(message.isSuccess);
        /* int32 index = 6; */
        if (message.index !== 0)
            writer.tag(6, WireType.Varint).int32(message.index);
        /* string file_url = 7; */
        if (message.fileUrl !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fileUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.CaptureInfo
 */
export const CaptureInfo = new CaptureInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreamSettings$Type extends MessageType<VideoStreamSettings> {
    constructor() {
        super("mavsdk.rpc.camera.VideoStreamSettings", [
            { no: 1, name: "frame_rate_hz", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "horizontal_resolution_pix", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "vertical_resolution_pix", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bit_rate_b_s", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "rotation_deg", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "horizontal_fov_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<VideoStreamSettings>): VideoStreamSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frameRateHz = 0;
        message.horizontalResolutionPix = 0;
        message.verticalResolutionPix = 0;
        message.bitRateBS = 0;
        message.rotationDeg = 0;
        message.uri = "";
        message.horizontalFovDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<VideoStreamSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreamSettings): VideoStreamSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float frame_rate_hz */ 1:
                    message.frameRateHz = reader.float();
                    break;
                case /* uint32 horizontal_resolution_pix */ 2:
                    message.horizontalResolutionPix = reader.uint32();
                    break;
                case /* uint32 vertical_resolution_pix */ 3:
                    message.verticalResolutionPix = reader.uint32();
                    break;
                case /* uint32 bit_rate_b_s */ 4:
                    message.bitRateBS = reader.uint32();
                    break;
                case /* uint32 rotation_deg */ 5:
                    message.rotationDeg = reader.uint32();
                    break;
                case /* string uri */ 6:
                    message.uri = reader.string();
                    break;
                case /* float horizontal_fov_deg */ 7:
                    message.horizontalFovDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreamSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float frame_rate_hz = 1; */
        if (message.frameRateHz !== 0)
            writer.tag(1, WireType.Bit32).float(message.frameRateHz);
        /* uint32 horizontal_resolution_pix = 2; */
        if (message.horizontalResolutionPix !== 0)
            writer.tag(2, WireType.Varint).uint32(message.horizontalResolutionPix);
        /* uint32 vertical_resolution_pix = 3; */
        if (message.verticalResolutionPix !== 0)
            writer.tag(3, WireType.Varint).uint32(message.verticalResolutionPix);
        /* uint32 bit_rate_b_s = 4; */
        if (message.bitRateBS !== 0)
            writer.tag(4, WireType.Varint).uint32(message.bitRateBS);
        /* uint32 rotation_deg = 5; */
        if (message.rotationDeg !== 0)
            writer.tag(5, WireType.Varint).uint32(message.rotationDeg);
        /* string uri = 6; */
        if (message.uri !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.uri);
        /* float horizontal_fov_deg = 7; */
        if (message.horizontalFovDeg !== 0)
            writer.tag(7, WireType.Bit32).float(message.horizontalFovDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.VideoStreamSettings
 */
export const VideoStreamSettings = new VideoStreamSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoStreamInfo$Type extends MessageType<VideoStreamInfo> {
    constructor() {
        super("mavsdk.rpc.camera.VideoStreamInfo", [
            { no: 1, name: "settings", kind: "message", T: () => VideoStreamSettings },
            { no: 2, name: "status", kind: "enum", T: () => ["mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus", VideoStreamInfo_VideoStreamStatus, "VIDEO_STREAM_STATUS_"] },
            { no: 3, name: "spectrum", kind: "enum", T: () => ["mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum", VideoStreamInfo_VideoStreamSpectrum, "VIDEO_STREAM_SPECTRUM_"] }
        ]);
    }
    create(value?: PartialMessage<VideoStreamInfo>): VideoStreamInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.spectrum = 0;
        if (value !== undefined)
            reflectionMergePartial<VideoStreamInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoStreamInfo): VideoStreamInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.camera.VideoStreamSettings settings */ 1:
                    message.settings = VideoStreamSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum spectrum */ 3:
                    message.spectrum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoStreamInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.camera.VideoStreamSettings settings = 1; */
        if (message.settings)
            VideoStreamSettings.internalBinaryWrite(message.settings, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum spectrum = 3; */
        if (message.spectrum !== 0)
            writer.tag(3, WireType.Varint).int32(message.spectrum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.VideoStreamInfo
 */
export const VideoStreamInfo = new VideoStreamInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("mavsdk.rpc.camera.Status", [
            { no: 1, name: "video_on", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "photo_interval_on", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "used_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "available_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "total_storage_mib", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "recording_time_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "media_folder_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "storage_status", kind: "enum", T: () => ["mavsdk.rpc.camera.Status.StorageStatus", Status_StorageStatus, "STORAGE_STATUS_"] },
            { no: 9, name: "storage_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "storage_type", kind: "enum", T: () => ["mavsdk.rpc.camera.Status.StorageType", Status_StorageType, "STORAGE_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.videoOn = false;
        message.photoIntervalOn = false;
        message.usedStorageMib = 0;
        message.availableStorageMib = 0;
        message.totalStorageMib = 0;
        message.recordingTimeS = 0;
        message.mediaFolderName = "";
        message.storageStatus = 0;
        message.storageId = 0;
        message.storageType = 0;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool video_on */ 1:
                    message.videoOn = reader.bool();
                    break;
                case /* bool photo_interval_on */ 2:
                    message.photoIntervalOn = reader.bool();
                    break;
                case /* float used_storage_mib */ 3:
                    message.usedStorageMib = reader.float();
                    break;
                case /* float available_storage_mib */ 4:
                    message.availableStorageMib = reader.float();
                    break;
                case /* float total_storage_mib */ 5:
                    message.totalStorageMib = reader.float();
                    break;
                case /* float recording_time_s */ 6:
                    message.recordingTimeS = reader.float();
                    break;
                case /* string media_folder_name */ 7:
                    message.mediaFolderName = reader.string();
                    break;
                case /* mavsdk.rpc.camera.Status.StorageStatus storage_status */ 8:
                    message.storageStatus = reader.int32();
                    break;
                case /* uint32 storage_id */ 9:
                    message.storageId = reader.uint32();
                    break;
                case /* mavsdk.rpc.camera.Status.StorageType storage_type */ 10:
                    message.storageType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool video_on = 1; */
        if (message.videoOn !== false)
            writer.tag(1, WireType.Varint).bool(message.videoOn);
        /* bool photo_interval_on = 2; */
        if (message.photoIntervalOn !== false)
            writer.tag(2, WireType.Varint).bool(message.photoIntervalOn);
        /* float used_storage_mib = 3; */
        if (message.usedStorageMib !== 0)
            writer.tag(3, WireType.Bit32).float(message.usedStorageMib);
        /* float available_storage_mib = 4; */
        if (message.availableStorageMib !== 0)
            writer.tag(4, WireType.Bit32).float(message.availableStorageMib);
        /* float total_storage_mib = 5; */
        if (message.totalStorageMib !== 0)
            writer.tag(5, WireType.Bit32).float(message.totalStorageMib);
        /* float recording_time_s = 6; */
        if (message.recordingTimeS !== 0)
            writer.tag(6, WireType.Bit32).float(message.recordingTimeS);
        /* string media_folder_name = 7; */
        if (message.mediaFolderName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.mediaFolderName);
        /* mavsdk.rpc.camera.Status.StorageStatus storage_status = 8; */
        if (message.storageStatus !== 0)
            writer.tag(8, WireType.Varint).int32(message.storageStatus);
        /* uint32 storage_id = 9; */
        if (message.storageId !== 0)
            writer.tag(9, WireType.Varint).uint32(message.storageId);
        /* mavsdk.rpc.camera.Status.StorageType storage_type = 10; */
        if (message.storageType !== 0)
            writer.tag(10, WireType.Varint).int32(message.storageType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Option$Type extends MessageType<Option> {
    constructor() {
        super("mavsdk.rpc.camera.Option", [
            { no: 1, name: "option_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "option_description", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Option>): Option {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionId = "";
        message.optionDescription = "";
        if (value !== undefined)
            reflectionMergePartial<Option>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Option): Option {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string option_id */ 1:
                    message.optionId = reader.string();
                    break;
                case /* string option_description */ 2:
                    message.optionDescription = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Option, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string option_id = 1; */
        if (message.optionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.optionId);
        /* string option_description = 2; */
        if (message.optionDescription !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Option
 */
export const Option = new Option$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Setting$Type extends MessageType<Setting> {
    constructor() {
        super("mavsdk.rpc.camera.Setting", [
            { no: 1, name: "setting_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "setting_description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "option", kind: "message", T: () => Option },
            { no: 4, name: "is_range", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Setting>): Setting {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settingId = "";
        message.settingDescription = "";
        message.isRange = false;
        if (value !== undefined)
            reflectionMergePartial<Setting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Setting): Setting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string setting_id */ 1:
                    message.settingId = reader.string();
                    break;
                case /* string setting_description */ 2:
                    message.settingDescription = reader.string();
                    break;
                case /* mavsdk.rpc.camera.Option option */ 3:
                    message.option = Option.internalBinaryRead(reader, reader.uint32(), options, message.option);
                    break;
                case /* bool is_range */ 4:
                    message.isRange = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Setting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string setting_id = 1; */
        if (message.settingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.settingId);
        /* string setting_description = 2; */
        if (message.settingDescription !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settingDescription);
        /* mavsdk.rpc.camera.Option option = 3; */
        if (message.option)
            Option.internalBinaryWrite(message.option, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_range = 4; */
        if (message.isRange !== false)
            writer.tag(4, WireType.Varint).bool(message.isRange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Setting
 */
export const Setting = new Setting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingOptions$Type extends MessageType<SettingOptions> {
    constructor() {
        super("mavsdk.rpc.camera.SettingOptions", [
            { no: 1, name: "setting_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "setting_description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Option },
            { no: 4, name: "is_range", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SettingOptions>): SettingOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settingId = "";
        message.settingDescription = "";
        message.options = [];
        message.isRange = false;
        if (value !== undefined)
            reflectionMergePartial<SettingOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SettingOptions): SettingOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string setting_id */ 1:
                    message.settingId = reader.string();
                    break;
                case /* string setting_description */ 2:
                    message.settingDescription = reader.string();
                    break;
                case /* repeated mavsdk.rpc.camera.Option options */ 3:
                    message.options.push(Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_range */ 4:
                    message.isRange = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SettingOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string setting_id = 1; */
        if (message.settingId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.settingId);
        /* string setting_description = 2; */
        if (message.settingDescription !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.settingDescription);
        /* repeated mavsdk.rpc.camera.Option options = 3; */
        for (let i = 0; i < message.options.length; i++)
            Option.internalBinaryWrite(message.options[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool is_range = 4; */
        if (message.isRange !== false)
            writer.tag(4, WireType.Varint).bool(message.isRange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.SettingOptions
 */
export const SettingOptions = new SettingOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Information$Type extends MessageType<Information> {
    constructor() {
        super("mavsdk.rpc.camera.Information", [
            { no: 1, name: "vendor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "model_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "focal_length_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "horizontal_sensor_size_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "vertical_sensor_size_mm", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "horizontal_resolution_px", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "vertical_resolution_px", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Information>): Information {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vendorName = "";
        message.modelName = "";
        message.focalLengthMm = 0;
        message.horizontalSensorSizeMm = 0;
        message.verticalSensorSizeMm = 0;
        message.horizontalResolutionPx = 0;
        message.verticalResolutionPx = 0;
        if (value !== undefined)
            reflectionMergePartial<Information>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Information): Information {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vendor_name */ 1:
                    message.vendorName = reader.string();
                    break;
                case /* string model_name */ 2:
                    message.modelName = reader.string();
                    break;
                case /* float focal_length_mm */ 3:
                    message.focalLengthMm = reader.float();
                    break;
                case /* float horizontal_sensor_size_mm */ 4:
                    message.horizontalSensorSizeMm = reader.float();
                    break;
                case /* float vertical_sensor_size_mm */ 5:
                    message.verticalSensorSizeMm = reader.float();
                    break;
                case /* uint32 horizontal_resolution_px */ 6:
                    message.horizontalResolutionPx = reader.uint32();
                    break;
                case /* uint32 vertical_resolution_px */ 7:
                    message.verticalResolutionPx = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Information, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vendor_name = 1; */
        if (message.vendorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vendorName);
        /* string model_name = 2; */
        if (message.modelName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.modelName);
        /* float focal_length_mm = 3; */
        if (message.focalLengthMm !== 0)
            writer.tag(3, WireType.Bit32).float(message.focalLengthMm);
        /* float horizontal_sensor_size_mm = 4; */
        if (message.horizontalSensorSizeMm !== 0)
            writer.tag(4, WireType.Bit32).float(message.horizontalSensorSizeMm);
        /* float vertical_sensor_size_mm = 5; */
        if (message.verticalSensorSizeMm !== 0)
            writer.tag(5, WireType.Bit32).float(message.verticalSensorSizeMm);
        /* uint32 horizontal_resolution_px = 6; */
        if (message.horizontalResolutionPx !== 0)
            writer.tag(6, WireType.Varint).uint32(message.horizontalResolutionPx);
        /* uint32 vertical_resolution_px = 7; */
        if (message.verticalResolutionPx !== 0)
            writer.tag(7, WireType.Varint).uint32(message.verticalResolutionPx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.camera.Information
 */
export const Information = new Information$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.camera.CameraService
 */
export const CameraService = new ServiceType("mavsdk.rpc.camera.CameraService", [
    { name: "Prepare", options: {}, I: PrepareRequest, O: PrepareResponse },
    { name: "TakePhoto", options: {}, I: TakePhotoRequest, O: TakePhotoResponse },
    { name: "StartPhotoInterval", options: {}, I: StartPhotoIntervalRequest, O: StartPhotoIntervalResponse },
    { name: "StopPhotoInterval", options: {}, I: StopPhotoIntervalRequest, O: StopPhotoIntervalResponse },
    { name: "StartVideo", options: {}, I: StartVideoRequest, O: StartVideoResponse },
    { name: "StopVideo", options: {}, I: StopVideoRequest, O: StopVideoResponse },
    { name: "StartVideoStreaming", options: { "mavsdk.options.async_type": "SYNC" }, I: StartVideoStreamingRequest, O: StartVideoStreamingResponse },
    { name: "StopVideoStreaming", options: { "mavsdk.options.async_type": "SYNC" }, I: StopVideoStreamingRequest, O: StopVideoStreamingResponse },
    { name: "SetMode", options: {}, I: SetModeRequest, O: SetModeResponse },
    { name: "ListPhotos", options: {}, I: ListPhotosRequest, O: ListPhotosResponse },
    { name: "SubscribeMode", serverStreaming: true, options: {}, I: SubscribeModeRequest, O: ModeResponse },
    { name: "SubscribeInformation", serverStreaming: true, options: {}, I: SubscribeInformationRequest, O: InformationResponse },
    { name: "SubscribeVideoStreamInfo", serverStreaming: true, options: {}, I: SubscribeVideoStreamInfoRequest, O: VideoStreamInfoResponse },
    { name: "SubscribeCaptureInfo", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeCaptureInfoRequest, O: CaptureInfoResponse },
    { name: "SubscribeStatus", serverStreaming: true, options: {}, I: SubscribeStatusRequest, O: StatusResponse },
    { name: "SubscribeCurrentSettings", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC" }, I: SubscribeCurrentSettingsRequest, O: CurrentSettingsResponse },
    { name: "SubscribePossibleSettingOptions", serverStreaming: true, options: {}, I: SubscribePossibleSettingOptionsRequest, O: PossibleSettingOptionsResponse },
    { name: "SetSetting", options: {}, I: SetSettingRequest, O: SetSettingResponse },
    { name: "GetSetting", options: {}, I: GetSettingRequest, O: GetSettingResponse },
    { name: "FormatStorage", options: {}, I: FormatStorageRequest, O: FormatStorageResponse },
    { name: "SelectCamera", options: { "mavsdk.options.async_type": "SYNC" }, I: SelectCameraRequest, O: SelectCameraResponse },
    { name: "ResetSettings", options: {}, I: ResetSettingsRequest, O: ResetSettingsResponse },
    { name: "ZoomInStart", options: {}, I: ZoomInStartRequest, O: ZoomInStartResponse },
    { name: "ZoomOutStart", options: {}, I: ZoomOutStartRequest, O: ZoomOutStartResponse },
    { name: "ZoomStop", options: {}, I: ZoomStopRequest, O: ZoomStopResponse },
    { name: "ZoomRange", options: {}, I: ZoomRangeRequest, O: ZoomRangeResponse },
    { name: "TrackPoint", options: {}, I: TrackPointRequest, O: TrackPointResponse },
    { name: "TrackRectangle", options: {}, I: TrackRectangleRequest, O: TrackRectangleResponse },
    { name: "TrackStop", options: {}, I: TrackStopRequest, O: TrackStopResponse },
    { name: "FocusInStart", options: {}, I: FocusInStartRequest, O: FocusInStartResponse },
    { name: "FocusOutStart", options: {}, I: FocusOutStartRequest, O: FocusOutStartResponse },
    { name: "FocusStop", options: {}, I: FocusStopRequest, O: FocusStopResponse },
    { name: "FocusRange", options: {}, I: FocusRangeRequest, O: FocusRangeResponse }
]);
