/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "ftp/ftp.proto" (package "mavsdk.rpc.ftp", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message mavsdk.rpc.ftp.SubscribeDownloadRequest
 */
export interface SubscribeDownloadRequest {
    /**
     * @generated from protobuf field: string remote_file_path = 1;
     */
    remoteFilePath: string; // The path of the remote file to download.
    /**
     * @generated from protobuf field: string local_dir = 2;
     */
    localDir: string; // The local directory to download to.
    /**
     * @generated from protobuf field: bool use_burst = 3;
     */
    useBurst: boolean; // Use burst for faster downloading.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.DownloadResponse
 */
export interface DownloadResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.ProgressData progress_data = 2;
     */
    progressData?: ProgressData; // The progress data if result is next
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.SubscribeUploadRequest
 */
export interface SubscribeUploadRequest {
    /**
     * @generated from protobuf field: string local_file_path = 1;
     */
    localFilePath: string; // The local file path to upload.
    /**
     * @generated from protobuf field: string remote_dir = 2;
     */
    remoteDir: string; // The remote directory to upload to.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.UploadResponse
 */
export interface UploadResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.ProgressData progress_data = 2;
     */
    progressData?: ProgressData; // The progress data if result is next
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.ListDirectoryRequest
 */
export interface ListDirectoryRequest {
    /**
     * @generated from protobuf field: string remote_dir = 1;
     */
    remoteDir: string; // The remote directory to list the contents for.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.ListDirectoryData
 */
export interface ListDirectoryData {
    /**
     * @generated from protobuf field: repeated string dirs = 1;
     */
    dirs: string[]; // The found directories.
    /**
     * @generated from protobuf field: repeated string files = 2;
     */
    files: string[]; // The found files.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.ListDirectoryResponse
 */
export interface ListDirectoryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.ListDirectoryData data = 2;
     */
    data?: ListDirectoryData; // The found directories and files.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.CreateDirectoryRequest
 */
export interface CreateDirectoryRequest {
    /**
     * @generated from protobuf field: string remote_dir = 1;
     */
    remoteDir: string; // The remote directory to create.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.CreateDirectoryResponse
 */
export interface CreateDirectoryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RemoveDirectoryRequest
 */
export interface RemoveDirectoryRequest {
    /**
     * @generated from protobuf field: string remote_dir = 1;
     */
    remoteDir: string; // The remote directory to remove.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RemoveDirectoryResponse
 */
export interface RemoveDirectoryResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RemoveFileRequest
 */
export interface RemoveFileRequest {
    /**
     * @generated from protobuf field: string remote_file_path = 1;
     */
    remoteFilePath: string; // The path of the remote file to remove.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RemoveFileResponse
 */
export interface RemoveFileResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RenameRequest
 */
export interface RenameRequest {
    /**
     * @generated from protobuf field: string remote_from_path = 1;
     */
    remoteFromPath: string; // The remote source path.
    /**
     * @generated from protobuf field: string remote_to_path = 2;
     */
    remoteToPath: string; // The remote destination path.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.RenameResponse
 */
export interface RenameResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.AreFilesIdenticalRequest
 */
export interface AreFilesIdenticalRequest {
    /**
     * @generated from protobuf field: string local_file_path = 1;
     */
    localFilePath: string; // The path of the local file.
    /**
     * @generated from protobuf field: string remote_file_path = 2;
     */
    remoteFilePath: string; // The path of the remote file.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.AreFilesIdenticalResponse
 */
export interface AreFilesIdenticalResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
    /**
     * @generated from protobuf field: bool are_identical = 2;
     */
    areIdentical: boolean; // Whether the files are identical.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.SetTargetCompidRequest
 */
export interface SetTargetCompidRequest {
    /**
     * @generated from protobuf field: uint32 compid = 1;
     */
    compid: number; // The component ID to set.
}
/**
 * @generated from protobuf message mavsdk.rpc.ftp.SetTargetCompidResponse
 */
export interface SetTargetCompidResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult ftp_result = 1;
     */
    ftpResult?: FtpResult;
}
/**
 * Progress data type for file transfer.
 *
 * @generated from protobuf message mavsdk.rpc.ftp.ProgressData
 */
export interface ProgressData {
    /**
     * @generated from protobuf field: uint32 bytes_transferred = 1;
     */
    bytesTransferred: number; // The number of bytes already transferred.
    /**
     * @generated from protobuf field: uint32 total_bytes = 2;
     */
    totalBytes: number; // The total bytes to transfer.
}
/**
 * Result type.
 *
 * @generated from protobuf message mavsdk.rpc.ftp.FtpResult
 */
export interface FtpResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.ftp.FtpResult.Result result = 1;
     */
    result: FtpResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for FTP commands
 *
 * @generated from protobuf enum mavsdk.rpc.ftp.FtpResult.Result
 */
export enum FtpResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Success
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * Intermediate message showing progress
     *
     * @generated from protobuf enum value: RESULT_NEXT = 2;
     */
    NEXT = 2,
    /**
     * Timeout
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 3;
     */
    TIMEOUT = 3,
    /**
     * Operation is already in progress
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * File IO operation error
     *
     * @generated from protobuf enum value: RESULT_FILE_IO_ERROR = 5;
     */
    FILE_IO_ERROR = 5,
    /**
     * File exists already
     *
     * @generated from protobuf enum value: RESULT_FILE_EXISTS = 6;
     */
    FILE_EXISTS = 6,
    /**
     * File does not exist
     *
     * @generated from protobuf enum value: RESULT_FILE_DOES_NOT_EXIST = 7;
     */
    FILE_DOES_NOT_EXIST = 7,
    /**
     * File is write protected
     *
     * @generated from protobuf enum value: RESULT_FILE_PROTECTED = 8;
     */
    FILE_PROTECTED = 8,
    /**
     * Invalid parameter
     *
     * @generated from protobuf enum value: RESULT_INVALID_PARAMETER = 9;
     */
    INVALID_PARAMETER = 9,
    /**
     * Unsupported command
     *
     * @generated from protobuf enum value: RESULT_UNSUPPORTED = 10;
     */
    UNSUPPORTED = 10,
    /**
     * General protocol error
     *
     * @generated from protobuf enum value: RESULT_PROTOCOL_ERROR = 11;
     */
    PROTOCOL_ERROR = 11,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 12;
     */
    NO_SYSTEM = 12
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeDownloadRequest$Type extends MessageType<SubscribeDownloadRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.SubscribeDownloadRequest", [
            { no: 1, name: "remote_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "local_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "use_burst", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeDownloadRequest>): SubscribeDownloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteFilePath = "";
        message.localDir = "";
        message.useBurst = false;
        if (value !== undefined)
            reflectionMergePartial<SubscribeDownloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeDownloadRequest): SubscribeDownloadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_file_path */ 1:
                    message.remoteFilePath = reader.string();
                    break;
                case /* string local_dir */ 2:
                    message.localDir = reader.string();
                    break;
                case /* bool use_burst */ 3:
                    message.useBurst = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeDownloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_file_path = 1; */
        if (message.remoteFilePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteFilePath);
        /* string local_dir = 2; */
        if (message.localDir !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.localDir);
        /* bool use_burst = 3; */
        if (message.useBurst !== false)
            writer.tag(3, WireType.Varint).bool(message.useBurst);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.SubscribeDownloadRequest
 */
export const SubscribeDownloadRequest = new SubscribeDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadResponse$Type extends MessageType<DownloadResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.DownloadResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult },
            { no: 2, name: "progress_data", kind: "message", T: () => ProgressData }
        ]);
    }
    create(value?: PartialMessage<DownloadResponse>): DownloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DownloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadResponse): DownloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                case /* mavsdk.rpc.ftp.ProgressData progress_data */ 2:
                    message.progressData = ProgressData.internalBinaryRead(reader, reader.uint32(), options, message.progressData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.ftp.ProgressData progress_data = 2; */
        if (message.progressData)
            ProgressData.internalBinaryWrite(message.progressData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.DownloadResponse
 */
export const DownloadResponse = new DownloadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeUploadRequest$Type extends MessageType<SubscribeUploadRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.SubscribeUploadRequest", [
            { no: 1, name: "local_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeUploadRequest>): SubscribeUploadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localFilePath = "";
        message.remoteDir = "";
        if (value !== undefined)
            reflectionMergePartial<SubscribeUploadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeUploadRequest): SubscribeUploadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string local_file_path */ 1:
                    message.localFilePath = reader.string();
                    break;
                case /* string remote_dir */ 2:
                    message.remoteDir = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeUploadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string local_file_path = 1; */
        if (message.localFilePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localFilePath);
        /* string remote_dir = 2; */
        if (message.remoteDir !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.SubscribeUploadRequest
 */
export const SubscribeUploadRequest = new SubscribeUploadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadResponse$Type extends MessageType<UploadResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.UploadResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult },
            { no: 2, name: "progress_data", kind: "message", T: () => ProgressData }
        ]);
    }
    create(value?: PartialMessage<UploadResponse>): UploadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UploadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadResponse): UploadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                case /* mavsdk.rpc.ftp.ProgressData progress_data */ 2:
                    message.progressData = ProgressData.internalBinaryRead(reader, reader.uint32(), options, message.progressData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.ftp.ProgressData progress_data = 2; */
        if (message.progressData)
            ProgressData.internalBinaryWrite(message.progressData, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.UploadResponse
 */
export const UploadResponse = new UploadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDirectoryRequest$Type extends MessageType<ListDirectoryRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.ListDirectoryRequest", [
            { no: 1, name: "remote_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDirectoryRequest>): ListDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteDir = "";
        if (value !== undefined)
            reflectionMergePartial<ListDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDirectoryRequest): ListDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_dir */ 1:
                    message.remoteDir = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_dir = 1; */
        if (message.remoteDir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.ListDirectoryRequest
 */
export const ListDirectoryRequest = new ListDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDirectoryData$Type extends MessageType<ListDirectoryData> {
    constructor() {
        super("mavsdk.rpc.ftp.ListDirectoryData", [
            { no: 1, name: "dirs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDirectoryData>): ListDirectoryData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dirs = [];
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<ListDirectoryData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDirectoryData): ListDirectoryData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string dirs */ 1:
                    message.dirs.push(reader.string());
                    break;
                case /* repeated string files */ 2:
                    message.files.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDirectoryData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string dirs = 1; */
        for (let i = 0; i < message.dirs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.dirs[i]);
        /* repeated string files = 2; */
        for (let i = 0; i < message.files.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.files[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.ListDirectoryData
 */
export const ListDirectoryData = new ListDirectoryData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDirectoryResponse$Type extends MessageType<ListDirectoryResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.ListDirectoryResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult },
            { no: 2, name: "data", kind: "message", T: () => ListDirectoryData }
        ]);
    }
    create(value?: PartialMessage<ListDirectoryResponse>): ListDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDirectoryResponse): ListDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                case /* mavsdk.rpc.ftp.ListDirectoryData data */ 2:
                    message.data = ListDirectoryData.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* mavsdk.rpc.ftp.ListDirectoryData data = 2; */
        if (message.data)
            ListDirectoryData.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.ListDirectoryResponse
 */
export const ListDirectoryResponse = new ListDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateDirectoryRequest$Type extends MessageType<CreateDirectoryRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.CreateDirectoryRequest", [
            { no: 1, name: "remote_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateDirectoryRequest>): CreateDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteDir = "";
        if (value !== undefined)
            reflectionMergePartial<CreateDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDirectoryRequest): CreateDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_dir */ 1:
                    message.remoteDir = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_dir = 1; */
        if (message.remoteDir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.CreateDirectoryRequest
 */
export const CreateDirectoryRequest = new CreateDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateDirectoryResponse$Type extends MessageType<CreateDirectoryResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.CreateDirectoryResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult }
        ]);
    }
    create(value?: PartialMessage<CreateDirectoryResponse>): CreateDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateDirectoryResponse): CreateDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.CreateDirectoryResponse
 */
export const CreateDirectoryResponse = new CreateDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveDirectoryRequest$Type extends MessageType<RemoveDirectoryRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.RemoveDirectoryRequest", [
            { no: 1, name: "remote_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveDirectoryRequest>): RemoveDirectoryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteDir = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveDirectoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveDirectoryRequest): RemoveDirectoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_dir */ 1:
                    message.remoteDir = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveDirectoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_dir = 1; */
        if (message.remoteDir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RemoveDirectoryRequest
 */
export const RemoveDirectoryRequest = new RemoveDirectoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveDirectoryResponse$Type extends MessageType<RemoveDirectoryResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.RemoveDirectoryResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult }
        ]);
    }
    create(value?: PartialMessage<RemoveDirectoryResponse>): RemoveDirectoryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoveDirectoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveDirectoryResponse): RemoveDirectoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveDirectoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RemoveDirectoryResponse
 */
export const RemoveDirectoryResponse = new RemoveDirectoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFileRequest$Type extends MessageType<RemoveFileRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.RemoveFileRequest", [
            { no: 1, name: "remote_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveFileRequest>): RemoveFileRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteFilePath = "";
        if (value !== undefined)
            reflectionMergePartial<RemoveFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveFileRequest): RemoveFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_file_path */ 1:
                    message.remoteFilePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_file_path = 1; */
        if (message.remoteFilePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteFilePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RemoveFileRequest
 */
export const RemoveFileRequest = new RemoveFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFileResponse$Type extends MessageType<RemoveFileResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.RemoveFileResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult }
        ]);
    }
    create(value?: PartialMessage<RemoveFileResponse>): RemoveFileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoveFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveFileResponse): RemoveFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RemoveFileResponse
 */
export const RemoveFileResponse = new RemoveFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenameRequest$Type extends MessageType<RenameRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.RenameRequest", [
            { no: 1, name: "remote_from_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_to_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RenameRequest>): RenameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remoteFromPath = "";
        message.remoteToPath = "";
        if (value !== undefined)
            reflectionMergePartial<RenameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenameRequest): RenameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remote_from_path */ 1:
                    message.remoteFromPath = reader.string();
                    break;
                case /* string remote_to_path */ 2:
                    message.remoteToPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remote_from_path = 1; */
        if (message.remoteFromPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.remoteFromPath);
        /* string remote_to_path = 2; */
        if (message.remoteToPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteToPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RenameRequest
 */
export const RenameRequest = new RenameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenameResponse$Type extends MessageType<RenameResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.RenameResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult }
        ]);
    }
    create(value?: PartialMessage<RenameResponse>): RenameResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RenameResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenameResponse): RenameResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenameResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.RenameResponse
 */
export const RenameResponse = new RenameResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AreFilesIdenticalRequest$Type extends MessageType<AreFilesIdenticalRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.AreFilesIdenticalRequest", [
            { no: 1, name: "local_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remote_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AreFilesIdenticalRequest>): AreFilesIdenticalRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localFilePath = "";
        message.remoteFilePath = "";
        if (value !== undefined)
            reflectionMergePartial<AreFilesIdenticalRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AreFilesIdenticalRequest): AreFilesIdenticalRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string local_file_path */ 1:
                    message.localFilePath = reader.string();
                    break;
                case /* string remote_file_path */ 2:
                    message.remoteFilePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AreFilesIdenticalRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string local_file_path = 1; */
        if (message.localFilePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localFilePath);
        /* string remote_file_path = 2; */
        if (message.remoteFilePath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.remoteFilePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.AreFilesIdenticalRequest
 */
export const AreFilesIdenticalRequest = new AreFilesIdenticalRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AreFilesIdenticalResponse$Type extends MessageType<AreFilesIdenticalResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.AreFilesIdenticalResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult },
            { no: 2, name: "are_identical", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AreFilesIdenticalResponse>): AreFilesIdenticalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.areIdentical = false;
        if (value !== undefined)
            reflectionMergePartial<AreFilesIdenticalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AreFilesIdenticalResponse): AreFilesIdenticalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                case /* bool are_identical */ 2:
                    message.areIdentical = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AreFilesIdenticalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool are_identical = 2; */
        if (message.areIdentical !== false)
            writer.tag(2, WireType.Varint).bool(message.areIdentical);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.AreFilesIdenticalResponse
 */
export const AreFilesIdenticalResponse = new AreFilesIdenticalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTargetCompidRequest$Type extends MessageType<SetTargetCompidRequest> {
    constructor() {
        super("mavsdk.rpc.ftp.SetTargetCompidRequest", [
            { no: 1, name: "compid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetTargetCompidRequest>): SetTargetCompidRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compid = 0;
        if (value !== undefined)
            reflectionMergePartial<SetTargetCompidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTargetCompidRequest): SetTargetCompidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 compid */ 1:
                    message.compid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTargetCompidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 compid = 1; */
        if (message.compid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.compid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.SetTargetCompidRequest
 */
export const SetTargetCompidRequest = new SetTargetCompidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTargetCompidResponse$Type extends MessageType<SetTargetCompidResponse> {
    constructor() {
        super("mavsdk.rpc.ftp.SetTargetCompidResponse", [
            { no: 1, name: "ftp_result", kind: "message", T: () => FtpResult }
        ]);
    }
    create(value?: PartialMessage<SetTargetCompidResponse>): SetTargetCompidResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTargetCompidResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTargetCompidResponse): SetTargetCompidResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult ftp_result */ 1:
                    message.ftpResult = FtpResult.internalBinaryRead(reader, reader.uint32(), options, message.ftpResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTargetCompidResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult ftp_result = 1; */
        if (message.ftpResult)
            FtpResult.internalBinaryWrite(message.ftpResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.SetTargetCompidResponse
 */
export const SetTargetCompidResponse = new SetTargetCompidResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgressData$Type extends MessageType<ProgressData> {
    constructor() {
        super("mavsdk.rpc.ftp.ProgressData", [
            { no: 1, name: "bytes_transferred", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "total_bytes", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProgressData>): ProgressData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bytesTransferred = 0;
        message.totalBytes = 0;
        if (value !== undefined)
            reflectionMergePartial<ProgressData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProgressData): ProgressData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bytes_transferred */ 1:
                    message.bytesTransferred = reader.uint32();
                    break;
                case /* uint32 total_bytes */ 2:
                    message.totalBytes = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProgressData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 bytes_transferred = 1; */
        if (message.bytesTransferred !== 0)
            writer.tag(1, WireType.Varint).uint32(message.bytesTransferred);
        /* uint32 total_bytes = 2; */
        if (message.totalBytes !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.ProgressData
 */
export const ProgressData = new ProgressData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FtpResult$Type extends MessageType<FtpResult> {
    constructor() {
        super("mavsdk.rpc.ftp.FtpResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.ftp.FtpResult.Result", FtpResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FtpResult>): FtpResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<FtpResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FtpResult): FtpResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.ftp.FtpResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FtpResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.ftp.FtpResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.ftp.FtpResult
 */
export const FtpResult = new FtpResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.ftp.FtpService
 */
export const FtpService = new ServiceType("mavsdk.rpc.ftp.FtpService", [
    { name: "SubscribeDownload", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC", "mavsdk.options.is_finite": true }, I: SubscribeDownloadRequest, O: DownloadResponse },
    { name: "SubscribeUpload", serverStreaming: true, options: { "mavsdk.options.async_type": "ASYNC", "mavsdk.options.is_finite": true }, I: SubscribeUploadRequest, O: UploadResponse },
    { name: "ListDirectory", options: {}, I: ListDirectoryRequest, O: ListDirectoryResponse },
    { name: "CreateDirectory", options: {}, I: CreateDirectoryRequest, O: CreateDirectoryResponse },
    { name: "RemoveDirectory", options: {}, I: RemoveDirectoryRequest, O: RemoveDirectoryResponse },
    { name: "RemoveFile", options: {}, I: RemoveFileRequest, O: RemoveFileResponse },
    { name: "Rename", options: {}, I: RenameRequest, O: RenameResponse },
    { name: "AreFilesIdentical", options: {}, I: AreFilesIdenticalRequest, O: AreFilesIdenticalResponse },
    { name: "SetTargetCompid", options: { "mavsdk.options.async_type": "SYNC" }, I: SetTargetCompidRequest, O: SetTargetCompidResponse }
]);
