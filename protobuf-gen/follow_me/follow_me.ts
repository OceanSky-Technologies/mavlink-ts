/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter ts_nocheck,eslint_disable
// @generated from protobuf file "follow_me/follow_me.proto" (package "mavsdk.rpc.follow_me", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Configuration type.
 *
 * @generated from protobuf message mavsdk.rpc.follow_me.Config
 */
export interface Config {
    /**
     * @generated from protobuf field: float follow_height_m = 1;
     */
    followHeightM: number; // [m] Follow height in meters (recommended minimum 8 meters)
    /**
     * @generated from protobuf field: float follow_distance_m = 2;
     */
    followDistanceM: number; // [m] Follow distance to target in meters (recommended minimum 4 meter)
    /**
     * FollowDirection follow_direction = 3; // [!DEPRECIATED!] Direction to follow target at. Exists as a legacy to old PX4 Follow-Me, but now only used for setting the follow_angle_deg. This value never gets sent to the PX4 side!
     *
     * @generated from protobuf field: float responsiveness = 4;
     */
    responsiveness: number; // How responsive the vehicle is to the motion of the target, Lower value = More responsive (range 0.0 to 1.0)
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.Config.FollowAltitudeMode altitude_mode = 5;
     */
    altitudeMode: Config_FollowAltitudeMode; // Follow Altitude control mode
    /**
     * @generated from protobuf field: float max_tangential_vel_m_s = 6;
     */
    maxTangentialVelMS: number; // [m/s] Maximum orbit tangential velocity relative to the target, in meters per second. Higher value = More aggressive follow angle tracking.
    /**
     * @generated from protobuf field: float follow_angle_deg = 7;
     */
    followAngleDeg: number; // [deg] Follow Angle relative to the target. 0 equals following in front of the target's direction. Angle increases in Clockwise direction, so following from right would be 90 degrees, from the left is -90 degrees, and so on.
}
/**
 * Altitude mode to configure which altitude the follow me will assume the target to be at.
 *
 * @generated from protobuf enum mavsdk.rpc.follow_me.Config.FollowAltitudeMode
 */
export enum Config_FollowAltitudeMode {
    /**
     * Target assumed to be mobing at a constant altitude of home position (where the vehicle armed)
     *
     * @generated from protobuf enum value: FOLLOW_ALTITUDE_MODE_CONSTANT = 0;
     */
    CONSTANT = 0,
    /**
     * Target assumed to be at the terrain level sensed by the distance sensor
     *
     * @generated from protobuf enum value: FOLLOW_ALTITUDE_MODE_TERRAIN = 1;
     */
    TERRAIN = 1,
    /**
     * Target GPS altitude taken into account to do 3D tracking
     *
     * @generated from protobuf enum value: FOLLOW_ALTITUDE_MODE_TARGET_GPS = 2;
     */
    TARGET_GPS = 2
}
/**
 * Target location for the vehicle to follow
 *
 * @generated from protobuf message mavsdk.rpc.follow_me.TargetLocation
 */
export interface TargetLocation {
    /**
     * @generated from protobuf field: double latitude_deg = 1;
     */
    latitudeDeg: number; // Target latitude in degrees
    /**
     * @generated from protobuf field: double longitude_deg = 2;
     */
    longitudeDeg: number; // Target longitude in degrees
    /**
     * @generated from protobuf field: float absolute_altitude_m = 3;
     */
    absoluteAltitudeM: number; // Target altitude in meters above MSL
    /**
     * @generated from protobuf field: float velocity_x_m_s = 4;
     */
    velocityXMS: number; // Target velocity in X axis, in meters per second
    /**
     * @generated from protobuf field: float velocity_y_m_s = 5;
     */
    velocityYMS: number; // Target velocity in Y axis, in meters per second
    /**
     * @generated from protobuf field: float velocity_z_m_s = 6;
     */
    velocityZMS: number; // Target velocity in Z axis, in meters per second
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.GetConfigRequest
 */
export interface GetConfigRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.GetConfigResponse
 */
export interface GetConfigResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.Config config = 1;
     */
    config?: Config; // The current configuration
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.SetConfigRequest
 */
export interface SetConfigRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.Config config = 1;
     */
    config?: Config; // The new configuration to be set
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.SetConfigResponse
 */
export interface SetConfigResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1;
     */
    followMeResult?: FollowMeResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.IsActiveRequest
 */
export interface IsActiveRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.IsActiveResponse
 */
export interface IsActiveResponse {
    /**
     * @generated from protobuf field: bool is_active = 1;
     */
    isActive: boolean; // Whether follow me is active or not
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.SetTargetLocationRequest
 */
export interface SetTargetLocationRequest {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.TargetLocation location = 1;
     */
    location?: TargetLocation; // The new TargetLocation to follow
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.SetTargetLocationResponse
 */
export interface SetTargetLocationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1;
     */
    followMeResult?: FollowMeResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.GetLastLocationRequest
 */
export interface GetLastLocationRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.GetLastLocationResponse
 */
export interface GetLastLocationResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.TargetLocation location = 1;
     */
    location?: TargetLocation; // The last target location that was set
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.StartRequest
 */
export interface StartRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.StartResponse
 */
export interface StartResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1;
     */
    followMeResult?: FollowMeResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.StopRequest
 */
export interface StopRequest {
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.StopResponse
 */
export interface StopResponse {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1;
     */
    followMeResult?: FollowMeResult;
}
/**
 * @generated from protobuf message mavsdk.rpc.follow_me.FollowMeResult
 */
export interface FollowMeResult {
    /**
     * @generated from protobuf field: mavsdk.rpc.follow_me.FollowMeResult.Result result = 1;
     */
    result: FollowMeResult_Result; // Result enum value
    /**
     * @generated from protobuf field: string result_str = 2;
     */
    resultStr: string; // Human-readable English string describing the result
}
/**
 * Possible results returned for followme operations
 *
 * @generated from protobuf enum mavsdk.rpc.follow_me.FollowMeResult.Result
 */
export enum FollowMeResult_Result {
    /**
     * Unknown result
     *
     * @generated from protobuf enum value: RESULT_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Request succeeded
     *
     * @generated from protobuf enum value: RESULT_SUCCESS = 1;
     */
    SUCCESS = 1,
    /**
     * No system connected
     *
     * @generated from protobuf enum value: RESULT_NO_SYSTEM = 2;
     */
    NO_SYSTEM = 2,
    /**
     * Connection error
     *
     * @generated from protobuf enum value: RESULT_CONNECTION_ERROR = 3;
     */
    CONNECTION_ERROR = 3,
    /**
     * Vehicle is busy
     *
     * @generated from protobuf enum value: RESULT_BUSY = 4;
     */
    BUSY = 4,
    /**
     * Command denied
     *
     * @generated from protobuf enum value: RESULT_COMMAND_DENIED = 5;
     */
    COMMAND_DENIED = 5,
    /**
     * Request timed out
     *
     * @generated from protobuf enum value: RESULT_TIMEOUT = 6;
     */
    TIMEOUT = 6,
    /**
     * FollowMe is not active
     *
     * @generated from protobuf enum value: RESULT_NOT_ACTIVE = 7;
     */
    NOT_ACTIVE = 7,
    /**
     * Failed to set FollowMe configuration
     *
     * @generated from protobuf enum value: RESULT_SET_CONFIG_FAILED = 8;
     */
    SET_CONFIG_FAILED = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("mavsdk.rpc.follow_me.Config", [
            { no: 1, name: "follow_height_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "8.0f" } },
            { no: 2, name: "follow_distance_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "8.0f" } },
            { no: 4, name: "responsiveness", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "0.1f" } },
            { no: 5, name: "altitude_mode", kind: "enum", T: () => ["mavsdk.rpc.follow_me.Config.FollowAltitudeMode", Config_FollowAltitudeMode, "FOLLOW_ALTITUDE_MODE_"] },
            { no: 6, name: "max_tangential_vel_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "8.0f" } },
            { no: 7, name: "follow_angle_deg", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "180.0f" } }
        ]);
    }
    create(value?: PartialMessage<Config>): Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.followHeightM = 0;
        message.followDistanceM = 0;
        message.responsiveness = 0;
        message.altitudeMode = 0;
        message.maxTangentialVelMS = 0;
        message.followAngleDeg = 0;
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float follow_height_m */ 1:
                    message.followHeightM = reader.float();
                    break;
                case /* float follow_distance_m */ 2:
                    message.followDistanceM = reader.float();
                    break;
                case /* float responsiveness */ 4:
                    message.responsiveness = reader.float();
                    break;
                case /* mavsdk.rpc.follow_me.Config.FollowAltitudeMode altitude_mode */ 5:
                    message.altitudeMode = reader.int32();
                    break;
                case /* float max_tangential_vel_m_s */ 6:
                    message.maxTangentialVelMS = reader.float();
                    break;
                case /* float follow_angle_deg */ 7:
                    message.followAngleDeg = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float follow_height_m = 1; */
        if (message.followHeightM !== 0)
            writer.tag(1, WireType.Bit32).float(message.followHeightM);
        /* float follow_distance_m = 2; */
        if (message.followDistanceM !== 0)
            writer.tag(2, WireType.Bit32).float(message.followDistanceM);
        /* float responsiveness = 4; */
        if (message.responsiveness !== 0)
            writer.tag(4, WireType.Bit32).float(message.responsiveness);
        /* mavsdk.rpc.follow_me.Config.FollowAltitudeMode altitude_mode = 5; */
        if (message.altitudeMode !== 0)
            writer.tag(5, WireType.Varint).int32(message.altitudeMode);
        /* float max_tangential_vel_m_s = 6; */
        if (message.maxTangentialVelMS !== 0)
            writer.tag(6, WireType.Bit32).float(message.maxTangentialVelMS);
        /* float follow_angle_deg = 7; */
        if (message.followAngleDeg !== 0)
            writer.tag(7, WireType.Bit32).float(message.followAngleDeg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TargetLocation$Type extends MessageType<TargetLocation> {
    constructor() {
        super("mavsdk.rpc.follow_me.TargetLocation", [
            { no: 1, name: "latitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 2, name: "longitude_deg", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 3, name: "absolute_altitude_m", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 4, name: "velocity_x_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 5, name: "velocity_y_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } },
            { no: 6, name: "velocity_z_m_s", kind: "scalar", T: 2 /*ScalarType.FLOAT*/, options: { "mavsdk.options.default_value": "NaN" } }
        ]);
    }
    create(value?: PartialMessage<TargetLocation>): TargetLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.latitudeDeg = 0;
        message.longitudeDeg = 0;
        message.absoluteAltitudeM = 0;
        message.velocityXMS = 0;
        message.velocityYMS = 0;
        message.velocityZMS = 0;
        if (value !== undefined)
            reflectionMergePartial<TargetLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TargetLocation): TargetLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude_deg */ 1:
                    message.latitudeDeg = reader.double();
                    break;
                case /* double longitude_deg */ 2:
                    message.longitudeDeg = reader.double();
                    break;
                case /* float absolute_altitude_m */ 3:
                    message.absoluteAltitudeM = reader.float();
                    break;
                case /* float velocity_x_m_s */ 4:
                    message.velocityXMS = reader.float();
                    break;
                case /* float velocity_y_m_s */ 5:
                    message.velocityYMS = reader.float();
                    break;
                case /* float velocity_z_m_s */ 6:
                    message.velocityZMS = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TargetLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude_deg = 1; */
        if (message.latitudeDeg !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitudeDeg);
        /* double longitude_deg = 2; */
        if (message.longitudeDeg !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitudeDeg);
        /* float absolute_altitude_m = 3; */
        if (message.absoluteAltitudeM !== 0)
            writer.tag(3, WireType.Bit32).float(message.absoluteAltitudeM);
        /* float velocity_x_m_s = 4; */
        if (message.velocityXMS !== 0)
            writer.tag(4, WireType.Bit32).float(message.velocityXMS);
        /* float velocity_y_m_s = 5; */
        if (message.velocityYMS !== 0)
            writer.tag(5, WireType.Bit32).float(message.velocityYMS);
        /* float velocity_z_m_s = 6; */
        if (message.velocityZMS !== 0)
            writer.tag(6, WireType.Bit32).float(message.velocityZMS);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.TargetLocation
 */
export const TargetLocation = new TargetLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigRequest$Type extends MessageType<GetConfigRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.GetConfigRequest", []);
    }
    create(value?: PartialMessage<GetConfigRequest>): GetConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigRequest): GetConfigRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.GetConfigRequest
 */
export const GetConfigRequest = new GetConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigResponse$Type extends MessageType<GetConfigResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.GetConfigResponse", [
            { no: 1, name: "config", kind: "message", T: () => Config }
        ]);
    }
    create(value?: PartialMessage<GetConfigResponse>): GetConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigResponse): GetConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.Config config */ 1:
                    message.config = Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.Config config = 1; */
        if (message.config)
            Config.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.GetConfigResponse
 */
export const GetConfigResponse = new GetConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetConfigRequest$Type extends MessageType<SetConfigRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.SetConfigRequest", [
            { no: 1, name: "config", kind: "message", T: () => Config }
        ]);
    }
    create(value?: PartialMessage<SetConfigRequest>): SetConfigRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetConfigRequest): SetConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.Config config */ 1:
                    message.config = Config.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.Config config = 1; */
        if (message.config)
            Config.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.SetConfigRequest
 */
export const SetConfigRequest = new SetConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetConfigResponse$Type extends MessageType<SetConfigResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.SetConfigResponse", [
            { no: 1, name: "follow_me_result", kind: "message", T: () => FollowMeResult }
        ]);
    }
    create(value?: PartialMessage<SetConfigResponse>): SetConfigResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetConfigResponse): SetConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result */ 1:
                    message.followMeResult = FollowMeResult.internalBinaryRead(reader, reader.uint32(), options, message.followMeResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1; */
        if (message.followMeResult)
            FollowMeResult.internalBinaryWrite(message.followMeResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.SetConfigResponse
 */
export const SetConfigResponse = new SetConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsActiveRequest$Type extends MessageType<IsActiveRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.IsActiveRequest", []);
    }
    create(value?: PartialMessage<IsActiveRequest>): IsActiveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<IsActiveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsActiveRequest): IsActiveRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: IsActiveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.IsActiveRequest
 */
export const IsActiveRequest = new IsActiveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IsActiveResponse$Type extends MessageType<IsActiveResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.IsActiveResponse", [
            { no: 1, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IsActiveResponse>): IsActiveResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<IsActiveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsActiveResponse): IsActiveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_active */ 1:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsActiveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_active = 1; */
        if (message.isActive !== false)
            writer.tag(1, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.IsActiveResponse
 */
export const IsActiveResponse = new IsActiveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTargetLocationRequest$Type extends MessageType<SetTargetLocationRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.SetTargetLocationRequest", [
            { no: 1, name: "location", kind: "message", T: () => TargetLocation }
        ]);
    }
    create(value?: PartialMessage<SetTargetLocationRequest>): SetTargetLocationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTargetLocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTargetLocationRequest): SetTargetLocationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.TargetLocation location */ 1:
                    message.location = TargetLocation.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTargetLocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.TargetLocation location = 1; */
        if (message.location)
            TargetLocation.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.SetTargetLocationRequest
 */
export const SetTargetLocationRequest = new SetTargetLocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetTargetLocationResponse$Type extends MessageType<SetTargetLocationResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.SetTargetLocationResponse", [
            { no: 1, name: "follow_me_result", kind: "message", T: () => FollowMeResult }
        ]);
    }
    create(value?: PartialMessage<SetTargetLocationResponse>): SetTargetLocationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetTargetLocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetTargetLocationResponse): SetTargetLocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result */ 1:
                    message.followMeResult = FollowMeResult.internalBinaryRead(reader, reader.uint32(), options, message.followMeResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetTargetLocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1; */
        if (message.followMeResult)
            FollowMeResult.internalBinaryWrite(message.followMeResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.SetTargetLocationResponse
 */
export const SetTargetLocationResponse = new SetTargetLocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastLocationRequest$Type extends MessageType<GetLastLocationRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.GetLastLocationRequest", []);
    }
    create(value?: PartialMessage<GetLastLocationRequest>): GetLastLocationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetLastLocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastLocationRequest): GetLastLocationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetLastLocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.GetLastLocationRequest
 */
export const GetLastLocationRequest = new GetLastLocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLastLocationResponse$Type extends MessageType<GetLastLocationResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.GetLastLocationResponse", [
            { no: 1, name: "location", kind: "message", T: () => TargetLocation }
        ]);
    }
    create(value?: PartialMessage<GetLastLocationResponse>): GetLastLocationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetLastLocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLastLocationResponse): GetLastLocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.TargetLocation location */ 1:
                    message.location = TargetLocation.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLastLocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.TargetLocation location = 1; */
        if (message.location)
            TargetLocation.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.GetLastLocationResponse
 */
export const GetLastLocationResponse = new GetLastLocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartRequest$Type extends MessageType<StartRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.StartRequest", []);
    }
    create(value?: PartialMessage<StartRequest>): StartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartRequest): StartRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.StartRequest
 */
export const StartRequest = new StartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartResponse$Type extends MessageType<StartResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.StartResponse", [
            { no: 1, name: "follow_me_result", kind: "message", T: () => FollowMeResult }
        ]);
    }
    create(value?: PartialMessage<StartResponse>): StartResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartResponse): StartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result */ 1:
                    message.followMeResult = FollowMeResult.internalBinaryRead(reader, reader.uint32(), options, message.followMeResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1; */
        if (message.followMeResult)
            FollowMeResult.internalBinaryWrite(message.followMeResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.StartResponse
 */
export const StartResponse = new StartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopRequest$Type extends MessageType<StopRequest> {
    constructor() {
        super("mavsdk.rpc.follow_me.StopRequest", []);
    }
    create(value?: PartialMessage<StopRequest>): StopRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopRequest): StopRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.StopRequest
 */
export const StopRequest = new StopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopResponse$Type extends MessageType<StopResponse> {
    constructor() {
        super("mavsdk.rpc.follow_me.StopResponse", [
            { no: 1, name: "follow_me_result", kind: "message", T: () => FollowMeResult }
        ]);
    }
    create(value?: PartialMessage<StopResponse>): StopResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopResponse): StopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result */ 1:
                    message.followMeResult = FollowMeResult.internalBinaryRead(reader, reader.uint32(), options, message.followMeResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.FollowMeResult follow_me_result = 1; */
        if (message.followMeResult)
            FollowMeResult.internalBinaryWrite(message.followMeResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.StopResponse
 */
export const StopResponse = new StopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FollowMeResult$Type extends MessageType<FollowMeResult> {
    constructor() {
        super("mavsdk.rpc.follow_me.FollowMeResult", [
            { no: 1, name: "result", kind: "enum", T: () => ["mavsdk.rpc.follow_me.FollowMeResult.Result", FollowMeResult_Result, "RESULT_"] },
            { no: 2, name: "result_str", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FollowMeResult>): FollowMeResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.resultStr = "";
        if (value !== undefined)
            reflectionMergePartial<FollowMeResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FollowMeResult): FollowMeResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* mavsdk.rpc.follow_me.FollowMeResult.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string result_str */ 2:
                    message.resultStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FollowMeResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* mavsdk.rpc.follow_me.FollowMeResult.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string result_str = 2; */
        if (message.resultStr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resultStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message mavsdk.rpc.follow_me.FollowMeResult
 */
export const FollowMeResult = new FollowMeResult$Type();
/**
 * @generated ServiceType for protobuf service mavsdk.rpc.follow_me.FollowMeService
 */
export const FollowMeService = new ServiceType("mavsdk.rpc.follow_me.FollowMeService", [
    { name: "GetConfig", options: { "mavsdk.options.async_type": "SYNC" }, I: GetConfigRequest, O: GetConfigResponse },
    { name: "SetConfig", options: { "mavsdk.options.async_type": "SYNC" }, I: SetConfigRequest, O: SetConfigResponse },
    { name: "IsActive", options: { "mavsdk.options.async_type": "SYNC" }, I: IsActiveRequest, O: IsActiveResponse },
    { name: "SetTargetLocation", options: { "mavsdk.options.async_type": "SYNC" }, I: SetTargetLocationRequest, O: SetTargetLocationResponse },
    { name: "GetLastLocation", options: { "mavsdk.options.async_type": "SYNC" }, I: GetLastLocationRequest, O: GetLastLocationResponse },
    { name: "Start", options: { "mavsdk.options.async_type": "SYNC" }, I: StartRequest, O: StartResponse },
    { name: "Stop", options: { "mavsdk.options.async_type": "SYNC" }, I: StopRequest, O: StopResponse }
]);
